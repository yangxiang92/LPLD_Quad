###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     07/Aug/2014  15:34:36 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\source\modu #
#                    le\WFLY_RC.c                                             #
#    Command line =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\source\modu #
#                    le\WFLY_RC.c -D LPLD_K60 -lCN                            #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\FLASH_M #
#                    INE\List\ -lB E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_ #
#                    V3\iar\FLASH_MINE\List\ -o E:\ShawnDocuments\IAR_WorkSpa #
#                    ce\LPLD_Quad_V3\iar\FLASH_MINE\Obj\ --no_cse             #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\app\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\ #
#                    iar\..\source\app\Control\ -I                            #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\app\Others\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Q #
#                    uad_V3\iar\..\source\app\Communicate\ -I                 #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\app\Algorithm\ -I E:\ShawnDocuments\IAR_WorkSpace\LPL #
#                    D_Quad_V3\iar\..\source\app\SignalProcess\ -I            #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\module\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_ #
#                    V3\iar\..\source\module\anbt_dmp\ -I                     #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\module\eMPL\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_ #
#                    Quad_V3\iar\..\source\lib\CPU\ -I                        #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\common\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Q #
#                    uad_V3\iar\..\source\lib\LPLD\ -I                        #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\LPLD\HW\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_ #
#                    Quad_V3\iar\..\source\lib\LPLD\DEV\ -I                   #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\uCOS-II\Ports\ -I E:\ShawnDocuments\IAR_WorkSpace #
#                    \LPLD_Quad_V3\iar\..\source\lib\uCOS-II\Source\ -I       #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\FatFs\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Qu #
#                    ad_V3\iar\..\source\lib\FatFs\option\ -I                 #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\USB\common\ -I E:\ShawnDocuments\IAR_WorkSpace\LP #
#                    LD_Quad_V3\iar\..\source\lib\USB\driver\ -I              #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\USB\descriptor\ -I E:\ShawnDocuments\IAR_WorkSpac #
#                    e\LPLD_Quad_V3\iar\..\source\lib\USB\class\ -I           #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\MyLib\ -On -I "D:\Program Files\IAR               #
#                    Systems\Embedded Workbench 6.4\arm\CMSIS\Include\" -D    #
#                    ARM_MATH_CM4                                             #
#    List file    =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\FLASH_M #
#                    INE\List\WFLY_RC.lst                                     #
#    Object file  =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\FLASH_M #
#                    INE\Obj\WFLY_RC.o                                        #
#                                                                             #
#                                                                             #
###############################################################################

E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\source\module\WFLY_RC.c
      1          /****************************************************************************** 
      2           *       WFLY_RC.c ----- The function to use the remote controller of WFLY 6e *
      3           *       (c) Copyright 2012 HUST RENESAS LAB,The Department of CSE, HUST       *
      4           *                        All Rights Reserved                                  *
      5           *Filename             :  WFLY_RC.c                                           *
      6           *Programmer(s)        :  Yang Xiang                                           *
      7           *Description          :                                                       *
      8           *Modification History :                                                       *
      9           *01a 2014/4/28 13:38:19                                                       *
     10           ******************************************************************************/
     11          #include "WFLY_RC.h"
     12          

   \                                 In section .bss, align 1
     13          uint8 g_WFLY_RC_timer_out_flag = 0;
   \                     g_WFLY_RC_timer_out_flag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     14          uint32 g_WFLY_RC_pluse_width_us[WFLY_RC_CHANNEL_NUM] = {0,0,0,0,0,0};
   \                     g_WFLY_RC_pluse_width_us:
   \   00000000                      DS8 24

   \                                 In section .bss, align 4
     15          static PIT_InitTypeDef WFLY_RC_PWM_width_measure_timer_init_struct;
   \                     WFLY_RC_PWM_width_measure_timer_init_struct:
   \   00000000                      DS8 20
     16          

   \                                 In section .text, align 2, keep-with-next
     17          void InitWFLY_RC(void)
     18          {
   \                     InitWFLY_RC:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
     19              GPIO_InitTypeDef WFLY_RC_PWM_input_pins_init_struct = {0};
   \   00000004   0xA801             ADD      R0,SP,#+4
   \   00000006   0x2114             MOVS     R1,#+20
   \   00000008   0x.... 0x....      BL       __aeabi_memclr4
     20          
     21              WFLY_RC_PWM_input_pins_init_struct.GPIO_PTx = WFLY_RC_CH0_PWM_INPUT_PIN_PORT;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable5  ;; 0x400ff000
   \   00000010   0x9001             STR      R0,[SP, #+4]
     22              WFLY_RC_PWM_input_pins_init_struct.GPIO_Pins = PinNum2GpioPin(WFLY_RC_CH0_PWM_INPUT_PIN_NUM);
   \   00000012   0x201A             MOVS     R0,#+26
   \   00000014   0x.... 0x....      BL       PinNum2GpioPin
   \   00000018   0x9002             STR      R0,[SP, #+8]
     23              WFLY_RC_PWM_input_pins_init_struct.GPIO_Dir = DIR_INPUT;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF88D 0x0010      STRB     R0,[SP, #+16]
     24              WFLY_RC_PWM_input_pins_init_struct.GPIO_PinControl = IRQC_ET;
   \   00000020   0xF45F 0x2030      MOVS     R0,#+720896
   \   00000024   0x9003             STR      R0,[SP, #+12]
     25              WFLY_RC_PWM_input_pins_init_struct.GPIO_Isr = PORTA_ExtIsr;
   \   00000026   0x.... 0x....      ADR.W    R0,PORTA_ExtIsr
   \   0000002A   0x9005             STR      R0,[SP, #+20]
     26              LPLD_GPIO_Init(WFLY_RC_PWM_input_pins_init_struct);
   \   0000002C   0xA901             ADD      R1,SP,#+4
   \   0000002E   0xB084             SUB      SP,SP,#+16
   \   00000030   0x4668             MOV      R0,SP
   \   00000032   0x2214             MOVS     R2,#+20
   \   00000034   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000038   0xBC0F             POP      {R0-R3}
   \   0000003A   0x.... 0x....      BL       LPLD_GPIO_Init
     27              LPLD_GPIO_EnableIrq(WFLY_RC_PWM_input_pins_init_struct);
   \   0000003E   0xA901             ADD      R1,SP,#+4
   \   00000040   0xB084             SUB      SP,SP,#+16
   \   00000042   0x4668             MOV      R0,SP
   \   00000044   0x2214             MOVS     R2,#+20
   \   00000046   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000004A   0xBC0F             POP      {R0-R3}
   \   0000004C   0x.... 0x....      BL       LPLD_GPIO_EnableIrq
     28          
     29              WFLY_RC_PWM_input_pins_init_struct.GPIO_PTx = WFLY_RC_CH1_PWM_INPUT_PIN_PORT;
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable5  ;; 0x400ff000
   \   00000054   0x9001             STR      R0,[SP, #+4]
     30              WFLY_RC_PWM_input_pins_init_struct.GPIO_Pins = PinNum2GpioPin(WFLY_RC_CH1_PWM_INPUT_PIN_NUM);
   \   00000056   0x201B             MOVS     R0,#+27
   \   00000058   0x.... 0x....      BL       PinNum2GpioPin
   \   0000005C   0x9002             STR      R0,[SP, #+8]
     31              WFLY_RC_PWM_input_pins_init_struct.GPIO_Dir = DIR_INPUT;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF88D 0x0010      STRB     R0,[SP, #+16]
     32              WFLY_RC_PWM_input_pins_init_struct.GPIO_PinControl = IRQC_ET;
   \   00000064   0xF45F 0x2030      MOVS     R0,#+720896
   \   00000068   0x9003             STR      R0,[SP, #+12]
     33              WFLY_RC_PWM_input_pins_init_struct.GPIO_Isr = PORTA_ExtIsr;
   \   0000006A   0x.... 0x....      ADR.W    R0,PORTA_ExtIsr
   \   0000006E   0x9005             STR      R0,[SP, #+20]
     34              LPLD_GPIO_Init(WFLY_RC_PWM_input_pins_init_struct);
   \   00000070   0xA901             ADD      R1,SP,#+4
   \   00000072   0xB084             SUB      SP,SP,#+16
   \   00000074   0x4668             MOV      R0,SP
   \   00000076   0x2214             MOVS     R2,#+20
   \   00000078   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000007C   0xBC0F             POP      {R0-R3}
   \   0000007E   0x.... 0x....      BL       LPLD_GPIO_Init
     35              LPLD_GPIO_EnableIrq(WFLY_RC_PWM_input_pins_init_struct);
   \   00000082   0xA901             ADD      R1,SP,#+4
   \   00000084   0xB084             SUB      SP,SP,#+16
   \   00000086   0x4668             MOV      R0,SP
   \   00000088   0x2214             MOVS     R2,#+20
   \   0000008A   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000008E   0xBC0F             POP      {R0-R3}
   \   00000090   0x.... 0x....      BL       LPLD_GPIO_EnableIrq
     36          
     37              WFLY_RC_PWM_input_pins_init_struct.GPIO_PTx = WFLY_RC_CH2_PWM_INPUT_PIN_PORT;
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable5  ;; 0x400ff000
   \   00000098   0x9001             STR      R0,[SP, #+4]
     38              WFLY_RC_PWM_input_pins_init_struct.GPIO_Pins = PinNum2GpioPin(WFLY_RC_CH2_PWM_INPUT_PIN_NUM);
   \   0000009A   0x201C             MOVS     R0,#+28
   \   0000009C   0x.... 0x....      BL       PinNum2GpioPin
   \   000000A0   0x9002             STR      R0,[SP, #+8]
     39              WFLY_RC_PWM_input_pins_init_struct.GPIO_Dir = DIR_INPUT;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xF88D 0x0010      STRB     R0,[SP, #+16]
     40              WFLY_RC_PWM_input_pins_init_struct.GPIO_PinControl = IRQC_ET;
   \   000000A8   0xF45F 0x2030      MOVS     R0,#+720896
   \   000000AC   0x9003             STR      R0,[SP, #+12]
     41              WFLY_RC_PWM_input_pins_init_struct.GPIO_Isr = PORTA_ExtIsr;
   \   000000AE   0x.... 0x....      ADR.W    R0,PORTA_ExtIsr
   \   000000B2   0x9005             STR      R0,[SP, #+20]
     42              LPLD_GPIO_Init(WFLY_RC_PWM_input_pins_init_struct);
   \   000000B4   0xA901             ADD      R1,SP,#+4
   \   000000B6   0xB084             SUB      SP,SP,#+16
   \   000000B8   0x4668             MOV      R0,SP
   \   000000BA   0x2214             MOVS     R2,#+20
   \   000000BC   0x.... 0x....      BL       __aeabi_memcpy4
   \   000000C0   0xBC0F             POP      {R0-R3}
   \   000000C2   0x.... 0x....      BL       LPLD_GPIO_Init
     43              LPLD_GPIO_EnableIrq(WFLY_RC_PWM_input_pins_init_struct);
   \   000000C6   0xA901             ADD      R1,SP,#+4
   \   000000C8   0xB084             SUB      SP,SP,#+16
   \   000000CA   0x4668             MOV      R0,SP
   \   000000CC   0x2214             MOVS     R2,#+20
   \   000000CE   0x.... 0x....      BL       __aeabi_memcpy4
   \   000000D2   0xBC0F             POP      {R0-R3}
   \   000000D4   0x.... 0x....      BL       LPLD_GPIO_EnableIrq
     44          
     45              WFLY_RC_PWM_input_pins_init_struct.GPIO_PTx = WFLY_RC_CH3_PWM_INPUT_PIN_PORT;
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable5  ;; 0x400ff000
   \   000000DC   0x9001             STR      R0,[SP, #+4]
     46              WFLY_RC_PWM_input_pins_init_struct.GPIO_Pins = PinNum2GpioPin(WFLY_RC_CH3_PWM_INPUT_PIN_NUM);
   \   000000DE   0x201D             MOVS     R0,#+29
   \   000000E0   0x.... 0x....      BL       PinNum2GpioPin
   \   000000E4   0x9002             STR      R0,[SP, #+8]
     47              WFLY_RC_PWM_input_pins_init_struct.GPIO_Dir = DIR_INPUT;
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0xF88D 0x0010      STRB     R0,[SP, #+16]
     48              WFLY_RC_PWM_input_pins_init_struct.GPIO_PinControl = IRQC_ET;
   \   000000EC   0xF45F 0x2030      MOVS     R0,#+720896
   \   000000F0   0x9003             STR      R0,[SP, #+12]
     49              WFLY_RC_PWM_input_pins_init_struct.GPIO_Isr = PORTA_ExtIsr;
   \   000000F2   0x.... 0x....      ADR.W    R0,PORTA_ExtIsr
   \   000000F6   0x9005             STR      R0,[SP, #+20]
     50              LPLD_GPIO_Init(WFLY_RC_PWM_input_pins_init_struct);
   \   000000F8   0xA901             ADD      R1,SP,#+4
   \   000000FA   0xB084             SUB      SP,SP,#+16
   \   000000FC   0x4668             MOV      R0,SP
   \   000000FE   0x2214             MOVS     R2,#+20
   \   00000100   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000104   0xBC0F             POP      {R0-R3}
   \   00000106   0x.... 0x....      BL       LPLD_GPIO_Init
     51              LPLD_GPIO_EnableIrq(WFLY_RC_PWM_input_pins_init_struct);
   \   0000010A   0xA901             ADD      R1,SP,#+4
   \   0000010C   0xB084             SUB      SP,SP,#+16
   \   0000010E   0x4668             MOV      R0,SP
   \   00000110   0x2214             MOVS     R2,#+20
   \   00000112   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000116   0xBC0F             POP      {R0-R3}
   \   00000118   0x.... 0x....      BL       LPLD_GPIO_EnableIrq
     52          
     53              WFLY_RC_PWM_input_pins_init_struct.GPIO_PTx = WFLY_RC_CH4_PWM_INPUT_PIN_PORT;
   \   0000011C   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x400ff040
   \   00000120   0x9001             STR      R0,[SP, #+4]
     54              WFLY_RC_PWM_input_pins_init_struct.GPIO_Pins = PinNum2GpioPin(WFLY_RC_CH4_PWM_INPUT_PIN_NUM);
   \   00000122   0x2005             MOVS     R0,#+5
   \   00000124   0x.... 0x....      BL       PinNum2GpioPin
   \   00000128   0x9002             STR      R0,[SP, #+8]
     55              WFLY_RC_PWM_input_pins_init_struct.GPIO_Dir = DIR_INPUT;
   \   0000012A   0x2000             MOVS     R0,#+0
   \   0000012C   0xF88D 0x0010      STRB     R0,[SP, #+16]
     56              WFLY_RC_PWM_input_pins_init_struct.GPIO_PinControl = IRQC_ET;
   \   00000130   0xF45F 0x2030      MOVS     R0,#+720896
   \   00000134   0x9003             STR      R0,[SP, #+12]
     57              WFLY_RC_PWM_input_pins_init_struct.GPIO_Isr = PORTB_ExtIsr;
   \   00000136   0x.... 0x....      ADR.W    R0,PORTB_ExtIsr
   \   0000013A   0x9005             STR      R0,[SP, #+20]
     58              LPLD_GPIO_Init(WFLY_RC_PWM_input_pins_init_struct);
   \   0000013C   0xA901             ADD      R1,SP,#+4
   \   0000013E   0xB084             SUB      SP,SP,#+16
   \   00000140   0x4668             MOV      R0,SP
   \   00000142   0x2214             MOVS     R2,#+20
   \   00000144   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000148   0xBC0F             POP      {R0-R3}
   \   0000014A   0x.... 0x....      BL       LPLD_GPIO_Init
     59              LPLD_GPIO_EnableIrq(WFLY_RC_PWM_input_pins_init_struct);
   \   0000014E   0xA901             ADD      R1,SP,#+4
   \   00000150   0xB084             SUB      SP,SP,#+16
   \   00000152   0x4668             MOV      R0,SP
   \   00000154   0x2214             MOVS     R2,#+20
   \   00000156   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000015A   0xBC0F             POP      {R0-R3}
   \   0000015C   0x.... 0x....      BL       LPLD_GPIO_EnableIrq
     60          
     61              WFLY_RC_PWM_input_pins_init_struct.GPIO_PTx = WFLY_RC_CH5_PWM_INPUT_PIN_PORT;
   \   00000160   0x....             LDR.N    R0,??DataTable5_1  ;; 0x400ff040
   \   00000162   0x9001             STR      R0,[SP, #+4]
     62              WFLY_RC_PWM_input_pins_init_struct.GPIO_Pins = PinNum2GpioPin(WFLY_RC_CH5_PWM_INPUT_PIN_NUM);
   \   00000164   0x2006             MOVS     R0,#+6
   \   00000166   0x.... 0x....      BL       PinNum2GpioPin
   \   0000016A   0x9002             STR      R0,[SP, #+8]
     63              WFLY_RC_PWM_input_pins_init_struct.GPIO_Dir = DIR_INPUT;
   \   0000016C   0x2000             MOVS     R0,#+0
   \   0000016E   0xF88D 0x0010      STRB     R0,[SP, #+16]
     64              WFLY_RC_PWM_input_pins_init_struct.GPIO_PinControl = IRQC_ET;
   \   00000172   0xF45F 0x2030      MOVS     R0,#+720896
   \   00000176   0x9003             STR      R0,[SP, #+12]
     65              WFLY_RC_PWM_input_pins_init_struct.GPIO_Isr = PORTB_ExtIsr;
   \   00000178   0x.... 0x....      ADR.W    R0,PORTB_ExtIsr
   \   0000017C   0x9005             STR      R0,[SP, #+20]
     66              LPLD_GPIO_Init(WFLY_RC_PWM_input_pins_init_struct);
   \   0000017E   0xA901             ADD      R1,SP,#+4
   \   00000180   0xB084             SUB      SP,SP,#+16
   \   00000182   0x4668             MOV      R0,SP
   \   00000184   0x2214             MOVS     R2,#+20
   \   00000186   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000018A   0xBC0F             POP      {R0-R3}
   \   0000018C   0x.... 0x....      BL       LPLD_GPIO_Init
     67              LPLD_GPIO_EnableIrq(WFLY_RC_PWM_input_pins_init_struct);    
   \   00000190   0xA901             ADD      R1,SP,#+4
   \   00000192   0xB084             SUB      SP,SP,#+16
   \   00000194   0x4668             MOV      R0,SP
   \   00000196   0x2214             MOVS     R2,#+20
   \   00000198   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000019C   0xBC0F             POP      {R0-R3}
   \   0000019E   0x.... 0x....      BL       LPLD_GPIO_EnableIrq
     68          
     69              WFLY_RC_PWM_width_measure_timer_init_struct.PIT_Pitx = WFLY_RC_PWM_WIDTH_MEASURE_TIMER_PITX;
   \   000001A2   0x....             LDR.N    R0,??DataTable5_2
   \   000001A4   0x2103             MOVS     R1,#+3
   \   000001A6   0x7001             STRB     R1,[R0, #+0]
     70              WFLY_RC_PWM_width_measure_timer_init_struct.PIT_PeriodS = 0;
   \   000001A8   0x....             LDR.N    R0,??DataTable5_2
   \   000001AA   0x2100             MOVS     R1,#+0
   \   000001AC   0x60C1             STR      R1,[R0, #+12]
     71              WFLY_RC_PWM_width_measure_timer_init_struct.PIT_PeriodMs = WFLY_RC_PWM_WIDTH_MEASURE_PERIOD_MS;
   \   000001AE   0x....             LDR.N    R0,??DataTable5_2
   \   000001B0   0x2164             MOVS     R1,#+100
   \   000001B2   0x6081             STR      R1,[R0, #+8]
     72              WFLY_RC_PWM_width_measure_timer_init_struct.PIT_PeriodUs = 0;
   \   000001B4   0x....             LDR.N    R0,??DataTable5_2
   \   000001B6   0x2100             MOVS     R1,#+0
   \   000001B8   0x6041             STR      R1,[R0, #+4]
     73              WFLY_RC_PWM_width_measure_timer_init_struct.PIT_Isr = WFLY_RC_TimerOutIsr;
   \   000001BA   0x....             LDR.N    R0,??DataTable5_2
   \   000001BC   0x.... 0x....      ADR.W    R1,WFLY_RC_TimerOutIsr
   \   000001C0   0x6101             STR      R1,[R0, #+16]
     74              LPLD_PIT_Init(WFLY_RC_PWM_width_measure_timer_init_struct);
   \   000001C2   0x....             LDR.N    R1,??DataTable5_2
   \   000001C4   0xB084             SUB      SP,SP,#+16
   \   000001C6   0x4668             MOV      R0,SP
   \   000001C8   0x2214             MOVS     R2,#+20
   \   000001CA   0x.... 0x....      BL       __aeabi_memcpy4
   \   000001CE   0xBC0F             POP      {R0-R3}
   \   000001D0   0x.... 0x....      BL       LPLD_PIT_Init
     75              LPLD_PIT_EnableIrq(WFLY_RC_PWM_width_measure_timer_init_struct);
   \   000001D4   0x....             LDR.N    R1,??DataTable5_2
   \   000001D6   0xB084             SUB      SP,SP,#+16
   \   000001D8   0x4668             MOV      R0,SP
   \   000001DA   0x2214             MOVS     R2,#+20
   \   000001DC   0x.... 0x....      BL       __aeabi_memcpy4
   \   000001E0   0xBC0F             POP      {R0-R3}
   \   000001E2   0x.... 0x....      BL       LPLD_PIT_EnableIrq
     76          }
   \   000001E6   0xB007             ADD      SP,SP,#+28
   \   000001E8   0xBD00             POP      {PC}             ;; return
     77          

   \                                 In section .text, align 4, keep-with-next
     78          void PORTA_ExtIsr(void)
     79          {
   \                     PORTA_ExtIsr:
   \   00000000   0xB510             PUSH     {R4,LR}
     80              if(LPLD_GPIO_IsPinxExt(PORTA, PinNum2GpioPin(WFLY_RC_CH0_PWM_INPUT_PIN_NUM)))    
   \   00000002   0x....             LDR.N    R0,??DataTable5_3  ;; 0x400490a0
   \   00000004   0x6804             LDR      R4,[R0, #+0]
   \   00000006   0x201A             MOVS     R0,#+26
   \   00000008   0x.... 0x....      BL       PinNum2GpioPin
   \   0000000C   0x4204             TST      R4,R0
   \   0000000E   0xD002             BEQ.N    ??PORTA_ExtIsr_0
     81              {
     82                  WFLY_RC_CHX_InputPWMMeasureIsr(0);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      BL       WFLY_RC_CHX_InputPWMMeasureIsr
     83              }
     84              if(LPLD_GPIO_IsPinxExt(PORTA, PinNum2GpioPin(WFLY_RC_CH1_PWM_INPUT_PIN_NUM)))    
   \                     ??PORTA_ExtIsr_0:
   \   00000016   0x....             LDR.N    R0,??DataTable5_3  ;; 0x400490a0
   \   00000018   0x6804             LDR      R4,[R0, #+0]
   \   0000001A   0x201B             MOVS     R0,#+27
   \   0000001C   0x.... 0x....      BL       PinNum2GpioPin
   \   00000020   0x4204             TST      R4,R0
   \   00000022   0xD002             BEQ.N    ??PORTA_ExtIsr_1
     85              {
     86                  WFLY_RC_CHX_InputPWMMeasureIsr(1);
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x.... 0x....      BL       WFLY_RC_CHX_InputPWMMeasureIsr
     87              }
     88              if(LPLD_GPIO_IsPinxExt(PORTA, PinNum2GpioPin(WFLY_RC_CH2_PWM_INPUT_PIN_NUM)))    
   \                     ??PORTA_ExtIsr_1:
   \   0000002A   0x....             LDR.N    R0,??DataTable5_3  ;; 0x400490a0
   \   0000002C   0x6804             LDR      R4,[R0, #+0]
   \   0000002E   0x201C             MOVS     R0,#+28
   \   00000030   0x.... 0x....      BL       PinNum2GpioPin
   \   00000034   0x4204             TST      R4,R0
   \   00000036   0xD002             BEQ.N    ??PORTA_ExtIsr_2
     89              {
     90                  WFLY_RC_CHX_InputPWMMeasureIsr(2);
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0x.... 0x....      BL       WFLY_RC_CHX_InputPWMMeasureIsr
     91              }
     92              if(LPLD_GPIO_IsPinxExt(PORTA, PinNum2GpioPin(WFLY_RC_CH3_PWM_INPUT_PIN_NUM)))    
   \                     ??PORTA_ExtIsr_2:
   \   0000003E   0x....             LDR.N    R0,??DataTable5_3  ;; 0x400490a0
   \   00000040   0x6804             LDR      R4,[R0, #+0]
   \   00000042   0x201D             MOVS     R0,#+29
   \   00000044   0x.... 0x....      BL       PinNum2GpioPin
   \   00000048   0x4204             TST      R4,R0
   \   0000004A   0xD002             BEQ.N    ??PORTA_ExtIsr_3
     93              {
     94                  WFLY_RC_CHX_InputPWMMeasureIsr(3);
   \   0000004C   0x2003             MOVS     R0,#+3
   \   0000004E   0x.... 0x....      BL       WFLY_RC_CHX_InputPWMMeasureIsr
     95              }
     96          }
   \                     ??PORTA_ExtIsr_3:
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
     97          

   \                                 In section .text, align 4, keep-with-next
     98          void PORTB_ExtIsr(void)
     99          {
   \                     PORTB_ExtIsr:
   \   00000000   0xB510             PUSH     {R4,LR}
    100              if(LPLD_GPIO_IsPinxExt(PORTB, PinNum2GpioPin(WFLY_RC_CH4_PWM_INPUT_PIN_NUM)))    
   \   00000002   0x....             LDR.N    R0,??DataTable5_4  ;; 0x4004a0a0
   \   00000004   0x6804             LDR      R4,[R0, #+0]
   \   00000006   0x2005             MOVS     R0,#+5
   \   00000008   0x.... 0x....      BL       PinNum2GpioPin
   \   0000000C   0x4204             TST      R4,R0
   \   0000000E   0xD002             BEQ.N    ??PORTB_ExtIsr_0
    101              {
    102                  WFLY_RC_CHX_InputPWMMeasureIsr(4);
   \   00000010   0x2004             MOVS     R0,#+4
   \   00000012   0x.... 0x....      BL       WFLY_RC_CHX_InputPWMMeasureIsr
    103              }
    104              if(LPLD_GPIO_IsPinxExt(PORTB, PinNum2GpioPin(WFLY_RC_CH5_PWM_INPUT_PIN_NUM)))    
   \                     ??PORTB_ExtIsr_0:
   \   00000016   0x....             LDR.N    R0,??DataTable5_4  ;; 0x4004a0a0
   \   00000018   0x6804             LDR      R4,[R0, #+0]
   \   0000001A   0x2006             MOVS     R0,#+6
   \   0000001C   0x.... 0x....      BL       PinNum2GpioPin
   \   00000020   0x4204             TST      R4,R0
   \   00000022   0xD002             BEQ.N    ??PORTB_ExtIsr_1
    105              {
    106                  WFLY_RC_CHX_InputPWMMeasureIsr(5);
   \   00000024   0x2005             MOVS     R0,#+5
   \   00000026   0x.... 0x....      BL       WFLY_RC_CHX_InputPWMMeasureIsr
    107              }
    108          }
   \                     ??PORTB_ExtIsr_1:
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    109          

   \                                 In section .text, align 4, keep-with-next
    110          void WFLY_RC_TimerOutIsr(void)
    111          {
    112              int i = 0;
   \                     WFLY_RC_TimerOutIsr:
   \   00000000   0x2000             MOVS     R0,#+0
    113              g_WFLY_RC_timer_out_flag = 1;
   \   00000002   0x....             LDR.N    R1,??DataTable5_5
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x700A             STRB     R2,[R1, #+0]
    114              
    115              for(i = 0; i < WFLY_RC_CHANNEL_NUM; i ++)
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x0008             MOVS     R0,R1
   \                     ??WFLY_RC_TimerOutIsr_0:
   \   0000000C   0x2806             CMP      R0,#+6
   \   0000000E   0xDA05             BGE.N    ??WFLY_RC_TimerOutIsr_1
    116              {
    117                  g_WFLY_RC_pluse_width_us[i] = 0;
   \   00000010   0x....             LDR.N    R1,??DataTable5_6
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    118              }
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \   0000001A   0xE7F7             B.N      ??WFLY_RC_TimerOutIsr_0
    119          }
   \                     ??WFLY_RC_TimerOutIsr_1:
   \   0000001C   0x4770             BX       LR               ;; return
    120          

   \                                 In section .text, align 2, keep-with-next
    121          void WFLY_RC_CHX_InputPWMMeasureIsr(uint8 channel_num)
    122          {
   \                     WFLY_RC_CHX_InputPWMMeasureIsr:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    123              static uint32 s_WFLY_RC_pluse_beggin_reg_time[WFLY_RC_CHANNEL_NUM] = {0, 0, 0, 0, 0, 0};
    124          //    static uint8 s_WFLY_RC_pluse_measure_complete_flag[WFLY_RC_CHANNEL_NUM] = {0, 0, 0, 0, 0, 0};
    125              int32 reg_time_diff = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    126          
    127              switch(channel_num)
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD009             BEQ.N    ??WFLY_RC_CHX_InputPWMMeasureIsr_0
   \   0000000C   0x2C02             CMP      R4,#+2
   \   0000000E   0xD041             BEQ.N    ??WFLY_RC_CHX_InputPWMMeasureIsr_1
   \   00000010   0xD323             BCC.N    ??WFLY_RC_CHX_InputPWMMeasureIsr_2
   \   00000012   0x2C04             CMP      R4,#+4
   \   00000014   0xD078             BEQ.N    ??WFLY_RC_CHX_InputPWMMeasureIsr_3
   \   00000016   0xD35A             BCC.N    ??WFLY_RC_CHX_InputPWMMeasureIsr_4
   \   00000018   0x2C05             CMP      R4,#+5
   \   0000001A   0xF000 0x8092      BEQ.W    ??WFLY_RC_CHX_InputPWMMeasureIsr_5
   \   0000001E   0xE0AD             B.N      ??WFLY_RC_CHX_InputPWMMeasureIsr_6
    128              {
    129                  case 0: 
    130                      if(WFLY_RC_CH0_INPUT == 1)
   \                     ??WFLY_RC_CHX_InputPWMMeasureIsr_0:
   \   00000020   0x....             LDR.N    R0,??DataTable5_7  ;; 0x43fe0268
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD104             BNE.N    ??WFLY_RC_CHX_InputPWMMeasureIsr_7
    131                      {
    132                          s_WFLY_RC_pluse_beggin_reg_time[0] = PIT->CHANNEL[WFLY_RC_PWM_WIDTH_MEASURE_TIMER_PITX].CVAL; 
   \   00000028   0x....             LDR.N    R0,??DataTable5_8
   \   0000002A   0x....             LDR.N    R1,??DataTable5_9  ;; 0x40037134
   \   0000002C   0x6809             LDR      R1,[R1, #+0]
   \   0000002E   0x6001             STR      R1,[R0, #+0]
   \   00000030   0xE012             B.N      ??WFLY_RC_CHX_InputPWMMeasureIsr_8
    133          //                s_WFLY_RC_pluse_measure_complete_flag[0] = 0;
    134                      }
    135                      else
    136                      {
    137                          reg_time_diff =s_WFLY_RC_pluse_beggin_reg_time[0] - PIT->CHANNEL[WFLY_RC_PWM_WIDTH_MEASURE_TIMER_PITX].CVAL;
   \                     ??WFLY_RC_CHX_InputPWMMeasureIsr_7:
   \   00000032   0x....             LDR.N    R0,??DataTable5_8
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x....             LDR.N    R1,??DataTable5_9  ;; 0x40037134
   \   00000038   0x6809             LDR      R1,[R1, #+0]
   \   0000003A   0x1A40             SUBS     R0,R0,R1
   \   0000003C   0x0005             MOVS     R5,R0
    138                          if(reg_time_diff > 0)
   \   0000003E   0x2D01             CMP      R5,#+1
   \   00000040   0xDB0A             BLT.N    ??WFLY_RC_CHX_InputPWMMeasureIsr_8
    139                          {
    140                              g_WFLY_RC_pluse_width_us[0] = reg_time_diff / (g_bus_clock / 1000000);
   \   00000042   0x....             LDR.N    R0,??DataTable5_10
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x....             LDR.N    R1,??DataTable5_11  ;; 0xf4240
   \   00000048   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000004C   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \   00000050   0x....             LDR.N    R1,??DataTable5_6
   \   00000052   0x6008             STR      R0,[R1, #+0]
    141          //                    s_WFLY_RC_pluse_measure_complete_flag[0] = 1;
    142                              WFLY_RC_ResetTimer();
   \   00000054   0x.... 0x....      BL       WFLY_RC_ResetTimer
    143                          }
    144                      }
    145                      break;
   \                     ??WFLY_RC_CHX_InputPWMMeasureIsr_8:
   \   00000058   0xE090             B.N      ??WFLY_RC_CHX_InputPWMMeasureIsr_9
    146          
    147                  case 1: 
    148                      if(WFLY_RC_CH1_INPUT == 1)
   \                     ??WFLY_RC_CHX_InputPWMMeasureIsr_2:
   \   0000005A   0x....             LDR.N    R0,??DataTable5_12  ;; 0x43fe026c
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x2801             CMP      R0,#+1
   \   00000060   0xD104             BNE.N    ??WFLY_RC_CHX_InputPWMMeasureIsr_10
    149                      {
    150                          s_WFLY_RC_pluse_beggin_reg_time[1] = PIT->CHANNEL[WFLY_RC_PWM_WIDTH_MEASURE_TIMER_PITX].CVAL; 
   \   00000062   0x....             LDR.N    R0,??DataTable5_8
   \   00000064   0x....             LDR.N    R1,??DataTable5_9  ;; 0x40037134
   \   00000066   0x6809             LDR      R1,[R1, #+0]
   \   00000068   0x6041             STR      R1,[R0, #+4]
   \   0000006A   0xE012             B.N      ??WFLY_RC_CHX_InputPWMMeasureIsr_11
    151          //                s_WFLY_RC_pluse_measure_complete_flag[1] = 0;
    152                      }
    153                      else
    154                      {
    155                          reg_time_diff =s_WFLY_RC_pluse_beggin_reg_time[1] - PIT->CHANNEL[WFLY_RC_PWM_WIDTH_MEASURE_TIMER_PITX].CVAL;
   \                     ??WFLY_RC_CHX_InputPWMMeasureIsr_10:
   \   0000006C   0x....             LDR.N    R0,??DataTable5_8
   \   0000006E   0x6840             LDR      R0,[R0, #+4]
   \   00000070   0x....             LDR.N    R1,??DataTable5_9  ;; 0x40037134
   \   00000072   0x6809             LDR      R1,[R1, #+0]
   \   00000074   0x1A40             SUBS     R0,R0,R1
   \   00000076   0x0005             MOVS     R5,R0
    156                          if(reg_time_diff > 0)
   \   00000078   0x2D01             CMP      R5,#+1
   \   0000007A   0xDB0A             BLT.N    ??WFLY_RC_CHX_InputPWMMeasureIsr_11
    157                          {
    158                              g_WFLY_RC_pluse_width_us[1] = reg_time_diff / (g_bus_clock / 1000000);
   \   0000007C   0x....             LDR.N    R0,??DataTable5_10
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x....             LDR.N    R1,??DataTable5_11  ;; 0xf4240
   \   00000082   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000086   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \   0000008A   0x....             LDR.N    R1,??DataTable5_6
   \   0000008C   0x6048             STR      R0,[R1, #+4]
    159          //                    s_WFLY_RC_pluse_measure_complete_flag[1] = 1;
    160                              WFLY_RC_ResetTimer();
   \   0000008E   0x.... 0x....      BL       WFLY_RC_ResetTimer
    161                          }
    162                      }
    163                      break;
   \                     ??WFLY_RC_CHX_InputPWMMeasureIsr_11:
   \   00000092   0xE073             B.N      ??WFLY_RC_CHX_InputPWMMeasureIsr_9
    164          
    165                  case 2: 
    166                      if(WFLY_RC_CH2_INPUT == 1)
   \                     ??WFLY_RC_CHX_InputPWMMeasureIsr_1:
   \   00000094   0x....             LDR.N    R0,??DataTable5_13  ;; 0x43fe0270
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0x2801             CMP      R0,#+1
   \   0000009A   0xD104             BNE.N    ??WFLY_RC_CHX_InputPWMMeasureIsr_12
    167                      {
    168                          s_WFLY_RC_pluse_beggin_reg_time[2] = PIT->CHANNEL[WFLY_RC_PWM_WIDTH_MEASURE_TIMER_PITX].CVAL; 
   \   0000009C   0x....             LDR.N    R0,??DataTable5_8
   \   0000009E   0x....             LDR.N    R1,??DataTable5_9  ;; 0x40037134
   \   000000A0   0x6809             LDR      R1,[R1, #+0]
   \   000000A2   0x6081             STR      R1,[R0, #+8]
   \   000000A4   0xE012             B.N      ??WFLY_RC_CHX_InputPWMMeasureIsr_13
    169          //                s_WFLY_RC_pluse_measure_complete_flag[2] = 0;
    170                      }
    171                      else
    172                      {
    173                          reg_time_diff =s_WFLY_RC_pluse_beggin_reg_time[2] - PIT->CHANNEL[WFLY_RC_PWM_WIDTH_MEASURE_TIMER_PITX].CVAL;
   \                     ??WFLY_RC_CHX_InputPWMMeasureIsr_12:
   \   000000A6   0x....             LDR.N    R0,??DataTable5_8
   \   000000A8   0x6880             LDR      R0,[R0, #+8]
   \   000000AA   0x....             LDR.N    R1,??DataTable5_9  ;; 0x40037134
   \   000000AC   0x6809             LDR      R1,[R1, #+0]
   \   000000AE   0x1A40             SUBS     R0,R0,R1
   \   000000B0   0x0005             MOVS     R5,R0
    174                          if(reg_time_diff > 0)
   \   000000B2   0x2D01             CMP      R5,#+1
   \   000000B4   0xDB0A             BLT.N    ??WFLY_RC_CHX_InputPWMMeasureIsr_13
    175                          {
    176                              g_WFLY_RC_pluse_width_us[2] = reg_time_diff / (g_bus_clock / 1000000);
   \   000000B6   0x....             LDR.N    R0,??DataTable5_10
   \   000000B8   0x6800             LDR      R0,[R0, #+0]
   \   000000BA   0x....             LDR.N    R1,??DataTable5_11  ;; 0xf4240
   \   000000BC   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000C0   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \   000000C4   0x....             LDR.N    R1,??DataTable5_6
   \   000000C6   0x6088             STR      R0,[R1, #+8]
    177          //                    s_WFLY_RC_pluse_measure_complete_flag[2] = 1;
    178                              WFLY_RC_ResetTimer();
   \   000000C8   0x.... 0x....      BL       WFLY_RC_ResetTimer
    179                          }
    180                      }
    181                      break;
   \                     ??WFLY_RC_CHX_InputPWMMeasureIsr_13:
   \   000000CC   0xE056             B.N      ??WFLY_RC_CHX_InputPWMMeasureIsr_9
    182          
    183                  case 3: 
    184                      if(WFLY_RC_CH3_INPUT == 1)
   \                     ??WFLY_RC_CHX_InputPWMMeasureIsr_4:
   \   000000CE   0x....             LDR.N    R0,??DataTable5_14  ;; 0x43fe0274
   \   000000D0   0x6800             LDR      R0,[R0, #+0]
   \   000000D2   0x2801             CMP      R0,#+1
   \   000000D4   0xD104             BNE.N    ??WFLY_RC_CHX_InputPWMMeasureIsr_14
    185                      {
    186                          s_WFLY_RC_pluse_beggin_reg_time[3] = PIT->CHANNEL[WFLY_RC_PWM_WIDTH_MEASURE_TIMER_PITX].CVAL; 
   \   000000D6   0x....             LDR.N    R0,??DataTable5_8
   \   000000D8   0x....             LDR.N    R1,??DataTable5_9  ;; 0x40037134
   \   000000DA   0x6809             LDR      R1,[R1, #+0]
   \   000000DC   0x60C1             STR      R1,[R0, #+12]
   \   000000DE   0xE012             B.N      ??WFLY_RC_CHX_InputPWMMeasureIsr_15
    187          //                s_WFLY_RC_pluse_measure_complete_flag[3] = 0;
    188                      }
    189                      else
    190                      {
    191                          reg_time_diff =s_WFLY_RC_pluse_beggin_reg_time[3] - PIT->CHANNEL[WFLY_RC_PWM_WIDTH_MEASURE_TIMER_PITX].CVAL;
   \                     ??WFLY_RC_CHX_InputPWMMeasureIsr_14:
   \   000000E0   0x....             LDR.N    R0,??DataTable5_8
   \   000000E2   0x68C0             LDR      R0,[R0, #+12]
   \   000000E4   0x....             LDR.N    R1,??DataTable5_9  ;; 0x40037134
   \   000000E6   0x6809             LDR      R1,[R1, #+0]
   \   000000E8   0x1A40             SUBS     R0,R0,R1
   \   000000EA   0x0005             MOVS     R5,R0
    192                          if(reg_time_diff > 0)
   \   000000EC   0x2D01             CMP      R5,#+1
   \   000000EE   0xDB0A             BLT.N    ??WFLY_RC_CHX_InputPWMMeasureIsr_15
    193                          {
    194                              g_WFLY_RC_pluse_width_us[3] = reg_time_diff / (g_bus_clock / 1000000);
   \   000000F0   0x....             LDR.N    R0,??DataTable5_10
   \   000000F2   0x6800             LDR      R0,[R0, #+0]
   \   000000F4   0x....             LDR.N    R1,??DataTable5_11  ;; 0xf4240
   \   000000F6   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000FA   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \   000000FE   0x....             LDR.N    R1,??DataTable5_6
   \   00000100   0x60C8             STR      R0,[R1, #+12]
    195          //                    s_WFLY_RC_pluse_measure_complete_flag[3] = 1;
    196                              WFLY_RC_ResetTimer();
   \   00000102   0x.... 0x....      BL       WFLY_RC_ResetTimer
    197                          }
    198                      }
    199                      break;          
   \                     ??WFLY_RC_CHX_InputPWMMeasureIsr_15:
   \   00000106   0xE039             B.N      ??WFLY_RC_CHX_InputPWMMeasureIsr_9
    200          
    201                  case 4: 
    202                      if(WFLY_RC_CH4_INPUT == 1)
   \                     ??WFLY_RC_CHX_InputPWMMeasureIsr_3:
   \   00000108   0x....             LDR.N    R0,??DataTable5_15  ;; 0x43fe0a14
   \   0000010A   0x6800             LDR      R0,[R0, #+0]
   \   0000010C   0x2801             CMP      R0,#+1
   \   0000010E   0xD104             BNE.N    ??WFLY_RC_CHX_InputPWMMeasureIsr_16
    203                      {
    204                          s_WFLY_RC_pluse_beggin_reg_time[4] = PIT->CHANNEL[WFLY_RC_PWM_WIDTH_MEASURE_TIMER_PITX].CVAL; 
   \   00000110   0x....             LDR.N    R0,??DataTable5_8
   \   00000112   0x....             LDR.N    R1,??DataTable5_9  ;; 0x40037134
   \   00000114   0x6809             LDR      R1,[R1, #+0]
   \   00000116   0x6101             STR      R1,[R0, #+16]
   \   00000118   0xE012             B.N      ??WFLY_RC_CHX_InputPWMMeasureIsr_17
    205          //                s_WFLY_RC_pluse_measure_complete_flag[4] = 0;
    206                      }
    207                      else
    208                      {
    209                          reg_time_diff =s_WFLY_RC_pluse_beggin_reg_time[4] - PIT->CHANNEL[WFLY_RC_PWM_WIDTH_MEASURE_TIMER_PITX].CVAL;
   \                     ??WFLY_RC_CHX_InputPWMMeasureIsr_16:
   \   0000011A   0x....             LDR.N    R0,??DataTable5_8
   \   0000011C   0x6900             LDR      R0,[R0, #+16]
   \   0000011E   0x....             LDR.N    R1,??DataTable5_9  ;; 0x40037134
   \   00000120   0x6809             LDR      R1,[R1, #+0]
   \   00000122   0x1A40             SUBS     R0,R0,R1
   \   00000124   0x0005             MOVS     R5,R0
    210                          if(reg_time_diff > 0)
   \   00000126   0x2D01             CMP      R5,#+1
   \   00000128   0xDB0A             BLT.N    ??WFLY_RC_CHX_InputPWMMeasureIsr_17
    211                          {
    212                              g_WFLY_RC_pluse_width_us[4] = reg_time_diff / (g_bus_clock / 1000000);
   \   0000012A   0x....             LDR.N    R0,??DataTable5_10
   \   0000012C   0x6800             LDR      R0,[R0, #+0]
   \   0000012E   0x....             LDR.N    R1,??DataTable5_11  ;; 0xf4240
   \   00000130   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000134   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \   00000138   0x....             LDR.N    R1,??DataTable5_6
   \   0000013A   0x6108             STR      R0,[R1, #+16]
    213          //                    s_WFLY_RC_pluse_measure_complete_flag[4] = 1;
    214                              WFLY_RC_ResetTimer();
   \   0000013C   0x.... 0x....      BL       WFLY_RC_ResetTimer
    215                          }
    216                      }
    217                      break;
   \                     ??WFLY_RC_CHX_InputPWMMeasureIsr_17:
   \   00000140   0xE01C             B.N      ??WFLY_RC_CHX_InputPWMMeasureIsr_9
    218          
    219                  case 5: 
    220                      if(WFLY_RC_CH5_INPUT == 1)
   \                     ??WFLY_RC_CHX_InputPWMMeasureIsr_5:
   \   00000142   0x....             LDR.N    R0,??DataTable5_16  ;; 0x43fe0a18
   \   00000144   0x6800             LDR      R0,[R0, #+0]
   \   00000146   0x2801             CMP      R0,#+1
   \   00000148   0xD104             BNE.N    ??WFLY_RC_CHX_InputPWMMeasureIsr_18
    221                      {
    222                          s_WFLY_RC_pluse_beggin_reg_time[5] = PIT->CHANNEL[WFLY_RC_PWM_WIDTH_MEASURE_TIMER_PITX].CVAL; 
   \   0000014A   0x....             LDR.N    R0,??DataTable5_8
   \   0000014C   0x....             LDR.N    R1,??DataTable5_9  ;; 0x40037134
   \   0000014E   0x6809             LDR      R1,[R1, #+0]
   \   00000150   0x6141             STR      R1,[R0, #+20]
   \   00000152   0xE012             B.N      ??WFLY_RC_CHX_InputPWMMeasureIsr_19
    223          //                s_WFLY_RC_pluse_measure_complete_flag[5] = 0;
    224                      }
    225                      else
    226                      {
    227                          reg_time_diff =s_WFLY_RC_pluse_beggin_reg_time[5] - PIT->CHANNEL[WFLY_RC_PWM_WIDTH_MEASURE_TIMER_PITX].CVAL;
   \                     ??WFLY_RC_CHX_InputPWMMeasureIsr_18:
   \   00000154   0x....             LDR.N    R0,??DataTable5_8
   \   00000156   0x6940             LDR      R0,[R0, #+20]
   \   00000158   0x....             LDR.N    R1,??DataTable5_9  ;; 0x40037134
   \   0000015A   0x6809             LDR      R1,[R1, #+0]
   \   0000015C   0x1A40             SUBS     R0,R0,R1
   \   0000015E   0x0005             MOVS     R5,R0
    228                          if(reg_time_diff > 0)
   \   00000160   0x2D01             CMP      R5,#+1
   \   00000162   0xDB0A             BLT.N    ??WFLY_RC_CHX_InputPWMMeasureIsr_19
    229                          {
    230                              g_WFLY_RC_pluse_width_us[5] = reg_time_diff / (g_bus_clock / 1000000);
   \   00000164   0x....             LDR.N    R0,??DataTable5_10
   \   00000166   0x6800             LDR      R0,[R0, #+0]
   \   00000168   0x....             LDR.N    R1,??DataTable5_11  ;; 0xf4240
   \   0000016A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000016E   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \   00000172   0x....             LDR.N    R1,??DataTable5_6
   \   00000174   0x6148             STR      R0,[R1, #+20]
    231          //                    s_WFLY_RC_pluse_measure_complete_flag[5] = 1;
    232                              WFLY_RC_ResetTimer();
   \   00000176   0x.... 0x....      BL       WFLY_RC_ResetTimer
    233                          }
    234                      }
    235                      break;  
   \                     ??WFLY_RC_CHX_InputPWMMeasureIsr_19:
   \   0000017A   0xE7FF             B.N      ??WFLY_RC_CHX_InputPWMMeasureIsr_9
    236          
    237                  default:
    238                      break;
    239              }
    240          
    241          //    if(s_WFLY_RC_pluse_measure_complete_flag[0] && s_WFLY_RC_pluse_measure_complete_flag[1] && s_WFLY_RC_pluse_measure_complete_flag[2] && s_WFLY_RC_pluse_measure_complete_flag[3])
    242          //    {
    243          //        WFLY_RC_ResetTimer();
    244          //    }
    245          }
   \                     ??WFLY_RC_CHX_InputPWMMeasureIsr_6:
   \                     ??WFLY_RC_CHX_InputPWMMeasureIsr_9:
   \   0000017C   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .bss, align 4
   \                     ??s_WFLY_RC_pluse_beggin_reg_time:
   \   00000000                      DS8 24
    246          

   \                                 In section .text, align 2, keep-with-next
    247          void WFLY_RC_ResetTimer(void)
    248          {
   \                     WFLY_RC_ResetTimer:
   \   00000000   0xB580             PUSH     {R7,LR}
    249              g_WFLY_RC_timer_out_flag = 0;
   \   00000002   0x....             LDR.N    R0,??DataTable5_5
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7001             STRB     R1,[R0, #+0]
    250              LPLD_PIT_Init(WFLY_RC_PWM_width_measure_timer_init_struct);
   \   00000008   0x....             LDR.N    R1,??DataTable5_2
   \   0000000A   0xB084             SUB      SP,SP,#+16
   \   0000000C   0x4668             MOV      R0,SP
   \   0000000E   0x2214             MOVS     R2,#+20
   \   00000010   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000014   0xBC0F             POP      {R0-R3}
   \   00000016   0x.... 0x....      BL       LPLD_PIT_Init
    251              LPLD_PIT_EnableIrq(WFLY_RC_PWM_width_measure_timer_init_struct);    
   \   0000001A   0x....             LDR.N    R1,??DataTable5_2
   \   0000001C   0xB084             SUB      SP,SP,#+16
   \   0000001E   0x4668             MOV      R0,SP
   \   00000020   0x2214             MOVS     R2,#+20
   \   00000022   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000026   0xBC0F             POP      {R0-R3}
   \   00000028   0x.... 0x....      BL       LPLD_PIT_EnableIrq
    252          }
   \   0000002C   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x400FF000         DC32     0x400ff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x400FF040         DC32     0x400ff040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     WFLY_RC_PWM_width_measure_timer_init_struct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x400490A0         DC32     0x400490a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x4004A0A0         DC32     0x4004a0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     g_WFLY_RC_timer_out_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     g_WFLY_RC_pluse_width_us

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x43FE0268         DC32     0x43fe0268

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     ??s_WFLY_RC_pluse_beggin_reg_time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x40037134         DC32     0x40037134

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     g_bus_clock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x43FE026C         DC32     0x43fe026c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0x43FE0270         DC32     0x43fe0270

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0x43FE0274         DC32     0x43fe0274

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_15:
   \   00000000   0x43FE0A14         DC32     0x43fe0a14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_16:
   \   00000000   0x43FE0A18         DC32     0x43fe0a18

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0H
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       48  InitWFLY_RC
             32 -> LPLD_GPIO_EnableIrq
             32 -> LPLD_GPIO_Init
             32 -> LPLD_PIT_EnableIrq
             32 -> LPLD_PIT_Init
             32 -> PinNum2GpioPin
             32 -> __aeabi_memclr4
             48 -> __aeabi_memcpy4
        8  PORTA_ExtIsr
              8 -> PinNum2GpioPin
              8 -> WFLY_RC_CHX_InputPWMMeasureIsr
        8  PORTB_ExtIsr
              8 -> PinNum2GpioPin
              8 -> WFLY_RC_CHX_InputPWMMeasureIsr
       16  WFLY_RC_CHX_InputPWMMeasureIsr
             16 -> WFLY_RC_ResetTimer
       24  WFLY_RC_ResetTimer
              8 -> LPLD_PIT_EnableIrq
              8 -> LPLD_PIT_Init
             24 -> __aeabi_memcpy4
        0  WFLY_RC_TimerOutIsr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  ?<Constant {(GPIO_Type *)0}>
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
     490  InitWFLY_RC
      84  PORTA_ExtIsr
      44  PORTB_ExtIsr
     382  WFLY_RC_CHX_InputPWMMeasureIsr
      20  WFLY_RC_PWM_width_measure_timer_init_struct
      46  WFLY_RC_ResetTimer
      30  WFLY_RC_TimerOutIsr
      24  g_WFLY_RC_pluse_width_us
       1  g_WFLY_RC_timer_out_flag
      24  s_WFLY_RC_pluse_beggin_reg_time

 
    69 bytes in section .bss
    20 bytes in section .rodata
 1 144 bytes in section .text
 
 1 144 bytes of CODE  memory
    20 bytes of CONST memory
    69 bytes of DATA  memory

Errors: none
Warnings: none
