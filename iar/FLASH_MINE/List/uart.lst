###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     08/Aug/2014  19:52:21 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\source\modu #
#                    le\uart.c                                                #
#    Command line =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\source\modu #
#                    le\uart.c -D LPLD_K60 -lCN E:\ShawnDocuments\IAR_WorkSpa #
#                    ce\LPLD_Quad_V3\iar\FLASH_MINE\List\ -lB                 #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\FLASH_M #
#                    INE\List\ -o E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V #
#                    3\iar\FLASH_MINE\Obj\ --no_cse --no_unroll --no_inline   #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "D:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.4\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\i #
#                    ar\..\source\app\ -I E:\ShawnDocuments\IAR_WorkSpace\LPL #
#                    D_Quad_V3\iar\..\source\app\Control\ -I                  #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\app\Others\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Q #
#                    uad_V3\iar\..\source\app\Communicate\ -I                 #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\app\Algorithm\ -I E:\ShawnDocuments\IAR_WorkSpace\LPL #
#                    D_Quad_V3\iar\..\source\app\SignalProcess\ -I            #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\module\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_ #
#                    V3\iar\..\source\module\anbt_dmp\ -I                     #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\module\eMPL\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_ #
#                    Quad_V3\iar\..\source\lib\CPU\ -I                        #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\common\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Q #
#                    uad_V3\iar\..\source\lib\LPLD\ -I                        #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\LPLD\HW\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_ #
#                    Quad_V3\iar\..\source\lib\LPLD\DEV\ -I                   #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\uCOS-II\Ports\ -I E:\ShawnDocuments\IAR_WorkSpace #
#                    \LPLD_Quad_V3\iar\..\source\lib\uCOS-II\Source\ -I       #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\FatFs\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Qu #
#                    ad_V3\iar\..\source\lib\FatFs\option\ -I                 #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\USB\common\ -I E:\ShawnDocuments\IAR_WorkSpace\LP #
#                    LD_Quad_V3\iar\..\source\lib\USB\driver\ -I              #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\USB\descriptor\ -I E:\ShawnDocuments\IAR_WorkSpac #
#                    e\LPLD_Quad_V3\iar\..\source\lib\USB\class\ -I           #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\MyLib\ -On -I "D:\Program Files\IAR               #
#                    Systems\Embedded Workbench 6.4\arm\CMSIS\Include\" -D    #
#                    ARM_MATH_CM4                                             #
#    List file    =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\FLASH_M #
#                    INE\List\uart.lst                                        #
#    Object file  =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\FLASH_M #
#                    INE\Obj\uart.o                                           #
#                                                                             #
#                                                                             #
###############################################################################

E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\source\module\uart.c
      1          /****************************************************************************** 
      2           *       uart.c ----- The uart Function          *
      3           *       (c) Copyright 2012 HUST RENESAS LAB,The Department of CSE, HUST       *
      4           *                        All Rights Reserved                                  *
      5           *Filename             :  uart.c                                           *
      6           *Programmer(s)        :  Yang Xiang                                           *
      7           *Description          :                                                       *
      8           *Modification History :                                                       *
      9           *01a 2014/3/22 18:25:24                                                       *
     10           ******************************************************************************/
     11          #include "uart.h"
     12          

   \                                 In section .bss, align 4
     13          uint32 g_u32DebugPWM[4] = {0,0,0,0};
   \                     g_u32DebugPWM:
   \   00000000                      DS8 16

   \                                 In section .bss, align 4
     14          float g_f32DebugYaw = 0;
   \                     g_f32DebugYaw:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     15          float g_f32DebugRoll = 0;
   \                     g_f32DebugRoll:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     16          float g_f32DebugPitch = 0;
   \                     g_f32DebugPitch:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     17          float g_f32DebugThrottle = 0;
   \                     g_f32DebugThrottle:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     18          PX4FLOW_Data g_sPx4flowData = {0};
   \                     g_sPx4flowData:
   \   00000000                      DS8 20

   \                                 In section .bss, align 1
     19          uint8 g_u8FlowNewData = 0;
   \                     g_u8FlowNewData:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     20          unsigned long g_ulFlowTime = 0;
   \                     g_ulFlowTime:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     21          float g_f32XPosition = 0;
   \                     g_f32XPosition:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     22          float g_f32YPosition = 0;
   \                     g_f32YPosition:
   \   00000000                      DS8 4
     23          

   \                                 In section .text, align 2, keep-with-next
     24          void InitDebugUart(void)
     25          {
   \                     InitDebugUart:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
     26              UART_InitTypeDef debug_uart_init_struct = {0};
   \   00000004   0xA801             ADD      R0,SP,#+4
   \   00000006   0x2114             MOVS     R1,#+20
   \   00000008   0x.... 0x....      BL       __aeabi_memclr4
     27              debug_uart_init_struct.UART_Uartx    = DEBUG_UART;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable7  ;; 0x400ea000
   \   00000010   0x9001             STR      R0,[SP, #+4]
     28              debug_uart_init_struct.UART_BaudRate = DEBUG_UART_BAUDRATE;
   \   00000012   0xF45F 0x30E1      MOVS     R0,#+115200
   \   00000016   0x9002             STR      R0,[SP, #+8]
     29              debug_uart_init_struct.UART_RxPin    = DEBUG_UART_RX_PIN;
   \   00000018   0x2095             MOVS     R0,#+149
   \   0000001A   0xF88D 0x000D      STRB     R0,[SP, #+13]
     30              debug_uart_init_struct.UART_TxPin    = DEBUG_UART_TX_PIN;
   \   0000001E   0x2094             MOVS     R0,#+148
   \   00000020   0xF88D 0x000C      STRB     R0,[SP, #+12]
     31              debug_uart_init_struct.UART_RxIntEnable = TRUE;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xF88D 0x000E      STRB     R0,[SP, #+14]
     32              debug_uart_init_struct.UART_RxIsr = DebugUartRxIsr;
   \   0000002A   0x.... 0x....      ADR.W    R0,DebugUartRxIsr
   \   0000002E   0x9004             STR      R0,[SP, #+16]
     33              LPLD_UART_Init(debug_uart_init_struct);
   \   00000030   0xA901             ADD      R1,SP,#+4
   \   00000032   0xB084             SUB      SP,SP,#+16
   \   00000034   0x4668             MOV      R0,SP
   \   00000036   0x2214             MOVS     R2,#+20
   \   00000038   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000003C   0xBC0F             POP      {R0-R3}
   \   0000003E   0x.... 0x....      BL       LPLD_UART_Init
     34              
     35              LPLD_UART_EnableIrq(debug_uart_init_struct);
   \   00000042   0xA901             ADD      R1,SP,#+4
   \   00000044   0xB084             SUB      SP,SP,#+16
   \   00000046   0x4668             MOV      R0,SP
   \   00000048   0x2214             MOVS     R2,#+20
   \   0000004A   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000004E   0xBC0F             POP      {R0-R3}
   \   00000050   0x.... 0x....      BL       LPLD_UART_EnableIrq
     36          }
   \   00000054   0xB007             ADD      SP,SP,#+28
   \   00000056   0xBD00             POP      {PC}             ;; return
     37          

   \                                 In section .text, align 2, keep-with-next
     38          void InitCommunicateUart(void)
     39          {
   \                     InitCommunicateUart:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
     40              UART_InitTypeDef communicate_uart_init_struct = {0};
   \   00000004   0xA801             ADD      R0,SP,#+4
   \   00000006   0x2114             MOVS     R1,#+20
   \   00000008   0x.... 0x....      BL       __aeabi_memclr4
     41              communicate_uart_init_struct.UART_Uartx     = COMMUNICATE_UART;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable7_1  ;; 0x4006c000
   \   00000010   0x9001             STR      R0,[SP, #+4]
     42              communicate_uart_init_struct.UART_BaudRate  = COMMUNICATE_UART_BAUDRATE;
   \   00000012   0xF45F 0x30E1      MOVS     R0,#+115200
   \   00000016   0x9002             STR      R0,[SP, #+8]
     43              communicate_uart_init_struct.UART_RxPin     = COMMUNICATE_UART_RX_PIN;
   \   00000018   0x205E             MOVS     R0,#+94
   \   0000001A   0xF88D 0x000D      STRB     R0,[SP, #+13]
     44              communicate_uart_init_struct.UART_TxPin     = COMMUNICATE_UART_TX_PIN;
   \   0000001E   0x205F             MOVS     R0,#+95
   \   00000020   0xF88D 0x000C      STRB     R0,[SP, #+12]
     45              //communicate_uart_init_struct.UART_RxIntEnable = TRUE;
     46              //communicate_uart_init_struct.UART_RxIsr = CommunicateUartRxIsr;
     47              LPLD_UART_Init(communicate_uart_init_struct);
   \   00000024   0xA901             ADD      R1,SP,#+4
   \   00000026   0xB084             SUB      SP,SP,#+16
   \   00000028   0x4668             MOV      R0,SP
   \   0000002A   0x2214             MOVS     R2,#+20
   \   0000002C   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000030   0xBC0F             POP      {R0-R3}
   \   00000032   0x.... 0x....      BL       LPLD_UART_Init
     48          
     49              //LPLD_UART_EnableIrq(communicate_uart_init_struct);
     50          }
   \   00000036   0xB007             ADD      SP,SP,#+28
   \   00000038   0xBD00             POP      {PC}             ;; return
     51          

   \                                 In section .text, align 2, keep-with-next
     52          void InitGPSUart(void)
     53          {
   \                     InitGPSUart:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
     54              UART_InitTypeDef GPS_uart_init_struct = {0};
   \   00000004   0xA801             ADD      R0,SP,#+4
   \   00000006   0x2114             MOVS     R1,#+20
   \   00000008   0x.... 0x....      BL       __aeabi_memclr4
     55              GPS_uart_init_struct.UART_Uartx     = GPS_UART;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable7_2  ;; 0x400eb000
   \   00000010   0x9001             STR      R0,[SP, #+4]
     56              GPS_uart_init_struct.UART_BaudRate  = GPS_UART_BAUDRATE;
   \   00000012   0xF45F 0x30E1      MOVS     R0,#+115200
   \   00000016   0x9002             STR      R0,[SP, #+8]
     57              GPS_uart_init_struct.UART_RxPin     = GPS_UART_RX_PIN;
   \   00000018   0x2064             MOVS     R0,#+100
   \   0000001A   0xF88D 0x000D      STRB     R0,[SP, #+13]
     58              GPS_uart_init_struct.UART_TxPin     = GPS_UART_TX_PIN;
   \   0000001E   0x2065             MOVS     R0,#+101
   \   00000020   0xF88D 0x000C      STRB     R0,[SP, #+12]
     59              GPS_uart_init_struct.UART_RxIntEnable = TRUE;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xF88D 0x000E      STRB     R0,[SP, #+14]
     60              GPS_uart_init_struct.UART_RxIsr = GPSUartRxIsr;
   \   0000002A   0x.... 0x....      ADR.W    R0,GPSUartRxIsr
   \   0000002E   0x9004             STR      R0,[SP, #+16]
     61              LPLD_UART_Init(GPS_uart_init_struct);
   \   00000030   0xA901             ADD      R1,SP,#+4
   \   00000032   0xB084             SUB      SP,SP,#+16
   \   00000034   0x4668             MOV      R0,SP
   \   00000036   0x2214             MOVS     R2,#+20
   \   00000038   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000003C   0xBC0F             POP      {R0-R3}
   \   0000003E   0x.... 0x....      BL       LPLD_UART_Init
     62          
     63              LPLD_UART_EnableIrq(GPS_uart_init_struct);
   \   00000042   0xA901             ADD      R1,SP,#+4
   \   00000044   0xB084             SUB      SP,SP,#+16
   \   00000046   0x4668             MOV      R0,SP
   \   00000048   0x2214             MOVS     R2,#+20
   \   0000004A   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000004E   0xBC0F             POP      {R0-R3}
   \   00000050   0x.... 0x....      BL       LPLD_UART_EnableIrq
     64          }
   \   00000054   0xB007             ADD      SP,SP,#+28
   \   00000056   0xBD00             POP      {PC}             ;; return
     65          

   \                                 In section .text, align 2, keep-with-next
     66          void CommUartSendOneByte(int8 data)
     67          {
   \                     CommUartSendOneByte:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     68              LPLD_UART_PutChar(COMMUNICATE_UART, data);
   \   00000004   0x0021             MOVS     R1,R4
   \   00000006   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable7_1  ;; 0x4006c000
   \   0000000C   0x.... 0x....      BL       LPLD_UART_PutChar
     69          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
     70          

   \                                 In section .text, align 2, keep-with-next
     71          void CommUartSendByteArr(int8 * data_arr, int32 num)
     72          {
   \                     CommUartSendByteArr:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     73              LPLD_UART_PutCharArr(COMMUNICATE_UART, data_arr, num);
   \   00000006   0x002A             MOVS     R2,R5
   \   00000008   0x0021             MOVS     R1,R4
   \   0000000A   0x....             LDR.N    R0,??DataTable7_1  ;; 0x4006c000
   \   0000000C   0x.... 0x....      BL       LPLD_UART_PutCharArr
     74          }
   \   00000010   0xBD31             POP      {R0,R4,R5,PC}    ;; return
     75          

   \                                 In section .text, align 2, keep-with-next
     76          void CommUartSendString(int8 * string)
     77          {
   \                     CommUartSendString:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     78              while(*string != '\0')
   \                     ??CommUartSendString_0:
   \   00000004   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD005             BEQ.N    ??CommUartSendString_1
     79              {
     80                  CommUartSendOneByte(*string);
   \   0000000C   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000010   0x.... 0x....      BL       CommUartSendOneByte
     81                  string++;
   \   00000014   0x1C64             ADDS     R4,R4,#+1
   \   00000016   0xE7F5             B.N      ??CommUartSendString_0
     82              }
     83          }
   \                     ??CommUartSendString_1:
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
     84          

   \                                 In section .text, align 2, keep-with-next
     85          void CommunicateUartRxIsr(void)
     86          {
   \                     CommunicateUartRxIsr:
   \   00000000   0xB510             PUSH     {R4,LR}
     87              int8 recv;
     88            
     89              recv = LPLD_UART_GetChar(COMMUNICATE_UART);
   \   00000002   0x....             LDR.N    R0,??DataTable7_1  ;; 0x4006c000
   \   00000004   0x.... 0x....      BL       LPLD_UART_GetChar
   \   00000008   0x0004             MOVS     R4,R0
     90              //LPLD_UART_PutChar(COMMUNICATE_UART, recv);  
     91              LPLD_UART_PutChar(COMMUNICATE_UART, recv); 
   \   0000000A   0x0021             MOVS     R1,R4
   \   0000000C   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   0000000E   0x....             LDR.N    R0,??DataTable7_1  ;; 0x4006c000
   \   00000010   0x.... 0x....      BL       LPLD_UART_PutChar
     92              ToggleLights(0x02);
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x.... 0x....      BL       ToggleLights
     93          }
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
     94          

   \                                 In section .text, align 4, keep-with-next
     95          void DebugUartRxIsr(void)
     96          {
   \                     DebugUartRxIsr:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB0A1             SUB      SP,SP,#+132
     97              int8 str_buf[128];
     98              int8 recv;
     99              int i = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    100            
    101              recv = LPLD_UART_GetChar(DEBUG_UART);
   \   00000006   0x....             LDR.N    R0,??DataTable7  ;; 0x400ea000
   \   00000008   0x.... 0x....      BL       LPLD_UART_GetChar
   \   0000000C   0x0004             MOVS     R4,R0
    102              //LPLD_UART_PutChar(DEBUG_UART, recv); 
    103              ToggleLights(0x01);
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       ToggleLights
    104          
    105              switch(recv)
   \   00000014   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x2820             CMP      R0,#+32
   \   0000001A   0xF000 0x8091      BEQ.W    ??DebugUartRxIsr_0
   \   0000001E   0x2861             CMP      R0,#+97
   \   00000020   0xD026             BEQ.N    ??DebugUartRxIsr_1
   \   00000022   0x2864             CMP      R0,#+100
   \   00000024   0xD05C             BEQ.N    ??DebugUartRxIsr_2
   \   00000026   0x2865             CMP      R0,#+101
   \   00000028   0xD052             BEQ.N    ??DebugUartRxIsr_3
   \   0000002A   0x2866             CMP      R0,#+102
   \   0000002C   0xD074             BEQ.N    ??DebugUartRxIsr_4
   \   0000002E   0x2868             CMP      R0,#+104
   \   00000030   0xD02C             BEQ.N    ??DebugUartRxIsr_5
   \   00000032   0x2869             CMP      R0,#+105
   \   00000034   0xD05C             BEQ.N    ??DebugUartRxIsr_6
   \   00000036   0x286A             CMP      R0,#+106
   \   00000038   0xD044             BEQ.N    ??DebugUartRxIsr_7
   \   0000003A   0x286B             CMP      R0,#+107
   \   0000003C   0xD05E             BEQ.N    ??DebugUartRxIsr_8
   \   0000003E   0x286C             CMP      R0,#+108
   \   00000040   0xD078             BEQ.N    ??DebugUartRxIsr_9
   \   00000042   0x286F             CMP      R0,#+111
   \   00000044   0xD070             BEQ.N    ??DebugUartRxIsr_10
   \   00000046   0x2871             CMP      R0,#+113
   \   00000048   0xD00A             BEQ.N    ??DebugUartRxIsr_11
   \   0000004A   0x2872             CMP      R0,#+114
   \   0000004C   0xD05C             BEQ.N    ??DebugUartRxIsr_12
   \   0000004E   0x2873             CMP      R0,#+115
   \   00000050   0xD02A             BEQ.N    ??DebugUartRxIsr_13
   \   00000052   0x2875             CMP      R0,#+117
   \   00000054   0xD030             BEQ.N    ??DebugUartRxIsr_14
   \   00000056   0x2877             CMP      R0,#+119
   \   00000058   0xD01E             BEQ.N    ??DebugUartRxIsr_15
   \   0000005A   0x2879             CMP      R0,#+121
   \   0000005C   0xD010             BEQ.N    ??DebugUartRxIsr_16
   \   0000005E   0xE07E             B.N      ??DebugUartRxIsr_17
    106              {
    107                  case 'q': g_u32DebugPWM[0] += 1;
   \                     ??DebugUartRxIsr_11:
   \   00000060   0x....             LDR.N    R0,??DataTable7_3
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x1C40             ADDS     R0,R0,#+1
   \   00000066   0x....             LDR.N    R1,??DataTable7_3
   \   00000068   0x6008             STR      R0,[R1, #+0]
    108                            i = 0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x0005             MOVS     R5,R0
    109                            break;
   \   0000006E   0xE076             B.N      ??DebugUartRxIsr_18
    110                  case 'a': g_u32DebugPWM[0] -= 1;
   \                     ??DebugUartRxIsr_1:
   \   00000070   0x....             LDR.N    R0,??DataTable7_3
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x1E40             SUBS     R0,R0,#+1
   \   00000076   0x....             LDR.N    R1,??DataTable7_3
   \   00000078   0x6008             STR      R0,[R1, #+0]
    111                            i = 0;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x0005             MOVS     R5,R0
    112                            break;
   \   0000007E   0xE06E             B.N      ??DebugUartRxIsr_18
    113                  case 'y': g_u32DebugPWM[0] = 100;
   \                     ??DebugUartRxIsr_16:
   \   00000080   0x....             LDR.N    R0,??DataTable7_3
   \   00000082   0x2164             MOVS     R1,#+100
   \   00000084   0x6001             STR      R1,[R0, #+0]
    114                            i = 0;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x0005             MOVS     R5,R0
    115                            break;
   \   0000008A   0xE068             B.N      ??DebugUartRxIsr_18
    116                  case 'h': g_u32DebugPWM[0] = 0;
   \                     ??DebugUartRxIsr_5:
   \   0000008C   0x....             LDR.N    R0,??DataTable7_3
   \   0000008E   0x2100             MOVS     R1,#+0
   \   00000090   0x6001             STR      R1,[R0, #+0]
    117                            i = 0;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x0005             MOVS     R5,R0
    118                            break;
   \   00000096   0xE062             B.N      ??DebugUartRxIsr_18
    119                  case 'w': g_u32DebugPWM[1] += 1;
   \                     ??DebugUartRxIsr_15:
   \   00000098   0x....             LDR.N    R0,??DataTable7_3
   \   0000009A   0x6840             LDR      R0,[R0, #+4]
   \   0000009C   0x1C40             ADDS     R0,R0,#+1
   \   0000009E   0x....             LDR.N    R1,??DataTable7_3
   \   000000A0   0x6048             STR      R0,[R1, #+4]
    120                            i = 1;
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0x0005             MOVS     R5,R0
    121                            break;
   \   000000A6   0xE05A             B.N      ??DebugUartRxIsr_18
    122                  case 's': g_u32DebugPWM[1] -= 1;
   \                     ??DebugUartRxIsr_13:
   \   000000A8   0x....             LDR.N    R0,??DataTable7_3
   \   000000AA   0x6840             LDR      R0,[R0, #+4]
   \   000000AC   0x1E40             SUBS     R0,R0,#+1
   \   000000AE   0x....             LDR.N    R1,??DataTable7_3
   \   000000B0   0x6048             STR      R0,[R1, #+4]
    123                            i = 1;
   \   000000B2   0x2001             MOVS     R0,#+1
   \   000000B4   0x0005             MOVS     R5,R0
    124                            break;
   \   000000B6   0xE052             B.N      ??DebugUartRxIsr_18
    125                  case 'u': g_u32DebugPWM[1] = 100;
   \                     ??DebugUartRxIsr_14:
   \   000000B8   0x....             LDR.N    R0,??DataTable7_3
   \   000000BA   0x2164             MOVS     R1,#+100
   \   000000BC   0x6041             STR      R1,[R0, #+4]
    126                            i = 1;
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x0005             MOVS     R5,R0
    127                            break;
   \   000000C2   0xE04C             B.N      ??DebugUartRxIsr_18
    128                  case 'j': g_u32DebugPWM[1] = 0;
   \                     ??DebugUartRxIsr_7:
   \   000000C4   0x....             LDR.N    R0,??DataTable7_3
   \   000000C6   0x2100             MOVS     R1,#+0
   \   000000C8   0x6041             STR      R1,[R0, #+4]
    129                            i = 1;
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0x0005             MOVS     R5,R0
    130                            break;
   \   000000CE   0xE046             B.N      ??DebugUartRxIsr_18
    131                  case 'e': g_u32DebugPWM[2] += 1;
   \                     ??DebugUartRxIsr_3:
   \   000000D0   0x....             LDR.N    R0,??DataTable7_3
   \   000000D2   0x6880             LDR      R0,[R0, #+8]
   \   000000D4   0x1C40             ADDS     R0,R0,#+1
   \   000000D6   0x....             LDR.N    R1,??DataTable7_3
   \   000000D8   0x6088             STR      R0,[R1, #+8]
    132                            i = 2;
   \   000000DA   0x2002             MOVS     R0,#+2
   \   000000DC   0x0005             MOVS     R5,R0
    133                            break;
   \   000000DE   0xE03E             B.N      ??DebugUartRxIsr_18
    134                  case 'd': g_u32DebugPWM[2] -= 1;
   \                     ??DebugUartRxIsr_2:
   \   000000E0   0x....             LDR.N    R0,??DataTable7_3
   \   000000E2   0x6880             LDR      R0,[R0, #+8]
   \   000000E4   0x1E40             SUBS     R0,R0,#+1
   \   000000E6   0x....             LDR.N    R1,??DataTable7_3
   \   000000E8   0x6088             STR      R0,[R1, #+8]
    135                            i = 2;
   \   000000EA   0x2002             MOVS     R0,#+2
   \   000000EC   0x0005             MOVS     R5,R0
    136                            break;
   \   000000EE   0xE036             B.N      ??DebugUartRxIsr_18
    137                  case 'i': g_u32DebugPWM[2] = 100;
   \                     ??DebugUartRxIsr_6:
   \   000000F0   0x....             LDR.N    R0,??DataTable7_3
   \   000000F2   0x2164             MOVS     R1,#+100
   \   000000F4   0x6081             STR      R1,[R0, #+8]
    138                            i = 2;
   \   000000F6   0x2002             MOVS     R0,#+2
   \   000000F8   0x0005             MOVS     R5,R0
    139                            break;
   \   000000FA   0xE030             B.N      ??DebugUartRxIsr_18
    140                  case 'k': g_u32DebugPWM[2] = 0;
   \                     ??DebugUartRxIsr_8:
   \   000000FC   0x....             LDR.N    R0,??DataTable7_3
   \   000000FE   0x2100             MOVS     R1,#+0
   \   00000100   0x6081             STR      R1,[R0, #+8]
    141                            i = 2;
   \   00000102   0x2002             MOVS     R0,#+2
   \   00000104   0x0005             MOVS     R5,R0
    142                            break;
   \   00000106   0xE02A             B.N      ??DebugUartRxIsr_18
    143                  case 'r': g_u32DebugPWM[3] += 1;
   \                     ??DebugUartRxIsr_12:
   \   00000108   0x....             LDR.N    R0,??DataTable7_3
   \   0000010A   0x68C0             LDR      R0,[R0, #+12]
   \   0000010C   0x1C40             ADDS     R0,R0,#+1
   \   0000010E   0x....             LDR.N    R1,??DataTable7_3
   \   00000110   0x60C8             STR      R0,[R1, #+12]
    144                            i = 3;
   \   00000112   0x2003             MOVS     R0,#+3
   \   00000114   0x0005             MOVS     R5,R0
    145                            break;
   \   00000116   0xE022             B.N      ??DebugUartRxIsr_18
    146                  case 'f': g_u32DebugPWM[3] -= 1;
   \                     ??DebugUartRxIsr_4:
   \   00000118   0x....             LDR.N    R0,??DataTable7_3
   \   0000011A   0x68C0             LDR      R0,[R0, #+12]
   \   0000011C   0x1E40             SUBS     R0,R0,#+1
   \   0000011E   0x....             LDR.N    R1,??DataTable7_3
   \   00000120   0x60C8             STR      R0,[R1, #+12]
    147                            i = 3;
   \   00000122   0x2003             MOVS     R0,#+3
   \   00000124   0x0005             MOVS     R5,R0
    148                            break;
   \   00000126   0xE01A             B.N      ??DebugUartRxIsr_18
    149                  case 'o': g_u32DebugPWM[3] = 100;
   \                     ??DebugUartRxIsr_10:
   \   00000128   0x....             LDR.N    R0,??DataTable7_3
   \   0000012A   0x2164             MOVS     R1,#+100
   \   0000012C   0x60C1             STR      R1,[R0, #+12]
    150                            i = 3;
   \   0000012E   0x2003             MOVS     R0,#+3
   \   00000130   0x0005             MOVS     R5,R0
    151                            break;
   \   00000132   0xE014             B.N      ??DebugUartRxIsr_18
    152                  case 'l': g_u32DebugPWM[3] = 0;
   \                     ??DebugUartRxIsr_9:
   \   00000134   0x....             LDR.N    R0,??DataTable7_3
   \   00000136   0x2100             MOVS     R1,#+0
   \   00000138   0x60C1             STR      R1,[R0, #+12]
    153                            i = 3;
   \   0000013A   0x2003             MOVS     R0,#+3
   \   0000013C   0x0005             MOVS     R5,R0
    154                            break;
   \   0000013E   0xE00E             B.N      ??DebugUartRxIsr_18
    155                  case ' ': g_u32DebugPWM[0] = 0;
   \                     ??DebugUartRxIsr_0:
   \   00000140   0x....             LDR.N    R0,??DataTable7_3
   \   00000142   0x2100             MOVS     R1,#+0
   \   00000144   0x6001             STR      R1,[R0, #+0]
    156                            g_u32DebugPWM[1] = 0;
   \   00000146   0x....             LDR.N    R0,??DataTable7_3
   \   00000148   0x2100             MOVS     R1,#+0
   \   0000014A   0x6041             STR      R1,[R0, #+4]
    157                            g_u32DebugPWM[2] = 0;
   \   0000014C   0x....             LDR.N    R0,??DataTable7_3
   \   0000014E   0x2100             MOVS     R1,#+0
   \   00000150   0x6081             STR      R1,[R0, #+8]
    158                            g_u32DebugPWM[3] = 0;
   \   00000152   0x....             LDR.N    R0,??DataTable7_3
   \   00000154   0x2100             MOVS     R1,#+0
   \   00000156   0x60C1             STR      R1,[R0, #+12]
    159                            i = 4;
   \   00000158   0x2004             MOVS     R0,#+4
   \   0000015A   0x0005             MOVS     R5,R0
    160                            break;
   \   0000015C   0xE7FF             B.N      ??DebugUartRxIsr_18
    161                  default:  break;
    162              }    
    163          
    164              if(i < 4)
   \                     ??DebugUartRxIsr_17:
   \                     ??DebugUartRxIsr_18:
   \   0000015E   0x2D04             CMP      R5,#+4
   \   00000160   0xDA0C             BGE.N    ??DebugUartRxIsr_19
    165              {
    166                  sprintf(str_buf, "PWM%d: %d\n\r", i, g_u32DebugPWM[i]);
   \   00000162   0x....             LDR.N    R0,??DataTable7_3
   \   00000164   0xF850 0x3025      LDR      R3,[R0, R5, LSL #+2]
   \   00000168   0x002A             MOVS     R2,R5
   \   0000016A   0x....             LDR.N    R1,??DataTable7_4
   \   0000016C   0xA800             ADD      R0,SP,#+0
   \   0000016E   0x.... 0x....      BL       sprintf
    167                  PutStringUartQueue(DEBUG_UART, str_buf);
   \   00000172   0xA900             ADD      R1,SP,#+0
   \   00000174   0x....             LDR.N    R0,??DataTable7  ;; 0x400ea000
   \   00000176   0x.... 0x....      BL       PutStringUartQueue
   \   0000017A   0xE007             B.N      ??DebugUartRxIsr_20
    168          //        printf("PWM%d: %d\n\r", i, g_u32DebugPWM[i]);
    169              }
    170              else
    171              {
    172                  sprintf(str_buf, "PWM ALL: 0\n\r");
   \                     ??DebugUartRxIsr_19:
   \   0000017C   0x....             LDR.N    R1,??DataTable7_5
   \   0000017E   0xA800             ADD      R0,SP,#+0
   \   00000180   0x.... 0x....      BL       sprintf
    173                  PutStringUartQueue(DEBUG_UART, str_buf);      
   \   00000184   0xA900             ADD      R1,SP,#+0
   \   00000186   0x....             LDR.N    R0,??DataTable7  ;; 0x400ea000
   \   00000188   0x.... 0x....      BL       PutStringUartQueue
    174          //        printf("PWM ALL: 0\n\r");
    175              }
    176          
    177          }
   \                     ??DebugUartRxIsr_20:
   \   0000018C   0xB021             ADD      SP,SP,#+132
   \   0000018E   0xBD30             POP      {R4,R5,PC}       ;; return
    178          

   \                                 In section .text, align 4, keep-with-next
    179          void GPSUartRxIsr(void)
    180          {
   \                     GPSUartRxIsr:
   \   00000000   0xE92D 0x41FF      PUSH     {R0-R8,LR}
    181              int8 recv;
    182              //int8 str_buf[128];
    183              TransferControlParaData ctrl_para_data;
    184          
    185              recv = LPLD_UART_GetChar(GPS_UART);
   \   00000004   0x....             LDR.N    R0,??DataTable7_2  ;; 0x400eb000
   \   00000006   0x.... 0x....      BL       LPLD_UART_GetChar
   \   0000000A   0x4680             MOV      R8,R0
    186              //LPLD_UART_PutChar(COMMUNICATE_UART, recv);  
    187              //LPLD_UART_PutChar(GPS_UART, recv); 
    188              ToggleLights(0x04);
   \   0000000C   0x2004             MOVS     R0,#+4
   \   0000000E   0x.... 0x....      BL       ToggleLights
    189          
    190              uint8 frame_type = RecvFrame(recv, GPS_UART);
   \   00000012   0x....             LDR.N    R1,??DataTable7_2  ;; 0x400eb000
   \   00000014   0x4640             MOV      R0,R8
   \   00000016   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000018   0x.... 0x....      BL       RecvFrame
   \   0000001C   0x0004             MOVS     R4,R0
    191          
    192              if(frame_type == 0x01)
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2C01             CMP      R4,#+1
   \   00000022   0xD131             BNE.N    ??GPSUartRxIsr_0
    193              {
    194                  if(DecodeControlParaData(&ctrl_para_data, GPS_UART) == 1)
   \   00000024   0x....             LDR.N    R1,??DataTable7_2  ;; 0x400eb000
   \   00000026   0xA802             ADD      R0,SP,#+8
   \   00000028   0x.... 0x....      BL       DecodeControlParaData
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xF040 0x807F      BNE.W    ??GPSUartRxIsr_1
    195                  {
    196                      ToggleLights(0x08);
   \   00000032   0x2008             MOVS     R0,#+8
   \   00000034   0x.... 0x....      BL       ToggleLights
    197                      g_u32LostSignalTimerCnt = 0;
   \   00000038   0x....             LDR.N    R0,??DataTable7_6
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x6001             STR      R1,[R0, #+0]
    198                      g_f32DebugYaw = (float)(ctrl_para_data.yaw) / 10;
   \   0000003E   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   00000042   0x.... 0x....      BL       __aeabi_i2f
   \   00000046   0x....             LDR.N    R1,??DataTable7_7  ;; 0x41200000
   \   00000048   0x.... 0x....      BL       __aeabi_fdiv
   \   0000004C   0x....             LDR.N    R1,??DataTable7_8
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    199                      g_f32DebugPitch = (float)(ctrl_para_data.pitch) / 10;
   \   00000050   0xF9BD 0x000A      LDRSH    R0,[SP, #+10]
   \   00000054   0x.... 0x....      BL       __aeabi_i2f
   \   00000058   0x....             LDR.N    R1,??DataTable7_7  ;; 0x41200000
   \   0000005A   0x.... 0x....      BL       __aeabi_fdiv
   \   0000005E   0x....             LDR.N    R1,??DataTable7_9
   \   00000060   0x6008             STR      R0,[R1, #+0]
    200                      g_f32DebugRoll = (float)(ctrl_para_data.roll) / 10;
   \   00000062   0xF9BD 0x000C      LDRSH    R0,[SP, #+12]
   \   00000066   0x.... 0x....      BL       __aeabi_i2f
   \   0000006A   0x....             LDR.N    R1,??DataTable7_7  ;; 0x41200000
   \   0000006C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000070   0x....             LDR.N    R1,??DataTable7_10
   \   00000072   0x6008             STR      R0,[R1, #+0]
    201                      g_f32DebugThrottle = (float)(ctrl_para_data.throttle) / 100;            
   \   00000074   0xF9BD 0x000E      LDRSH    R0,[SP, #+14]
   \   00000078   0x.... 0x....      BL       __aeabi_i2f
   \   0000007C   0x....             LDR.N    R1,??DataTable7_11  ;; 0x42c80000
   \   0000007E   0x.... 0x....      BL       __aeabi_fdiv
   \   00000082   0x....             LDR.N    R1,??DataTable7_12
   \   00000084   0x6008             STR      R0,[R1, #+0]
   \   00000086   0xE053             B.N      ??GPSUartRxIsr_1
    202                  }
    203              }
    204              else if(frame_type == 0x03)
   \                     ??GPSUartRxIsr_0:
   \   00000088   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008A   0x2C03             CMP      R4,#+3
   \   0000008C   0xD150             BNE.N    ??GPSUartRxIsr_1
    205              {
    206                  if(DecodePX4FLOWData(&g_sPx4flowData, GPS_UART) == 1)
   \   0000008E   0x....             LDR.N    R1,??DataTable7_2  ;; 0x400eb000
   \   00000090   0x....             LDR.N    R0,??DataTable7_13
   \   00000092   0x.... 0x....      BL       DecodePX4FLOWData
   \   00000096   0x2801             CMP      R0,#+1
   \   00000098   0xD14A             BNE.N    ??GPSUartRxIsr_1
    207                  {
    208                      ToggleLights(0x08);
   \   0000009A   0x2008             MOVS     R0,#+8
   \   0000009C   0x.... 0x....      BL       ToggleLights
    209                      g_u8FlowNewData = 1;
   \   000000A0   0x....             LDR.N    R0,??DataTable7_14
   \   000000A2   0x2101             MOVS     R1,#+1
   \   000000A4   0x7001             STRB     R1,[R0, #+0]
    210                      if(Flow_RefreshRawData() == 1)
   \   000000A6   0x.... 0x....      BL       Flow_RefreshRawData
   \   000000AA   0x2801             CMP      R0,#+1
   \   000000AC   0xD140             BNE.N    ??GPSUartRxIsr_1
    211                      {
    212                          static unsigned long last_flow_time_tag = 0;
    213                          unsigned long flow_time_tag = GetSystemClockMs();
   \   000000AE   0x.... 0x....      BL       GetSystemClockMs
   \   000000B2   0x0005             MOVS     R5,R0
    214                          g_ulFlowTime = flow_time_tag - last_flow_time_tag;
   \   000000B4   0x....             LDR.N    R0,??DataTable7_15
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0x1A28             SUBS     R0,R5,R0
   \   000000BA   0x....             LDR.N    R1,??DataTable7_16
   \   000000BC   0x6008             STR      R0,[R1, #+0]
    215                          last_flow_time_tag = flow_time_tag;
   \   000000BE   0x....             LDR.N    R0,??DataTable7_15
   \   000000C0   0x6005             STR      R5,[R0, #+0]
    216                          float x_speed_to_input = FlowFilterGetCurrentFlowComp()[0];
   \   000000C2   0x.... 0x....      BL       FlowFilterGetCurrentFlowComp
   \   000000C6   0x6806             LDR      R6,[R0, #+0]
    217                          float y_speed_to_input = FlowFilterGetCurrentFlowComp()[1];
   \   000000C8   0x.... 0x....      BL       FlowFilterGetCurrentFlowComp
   \   000000CC   0x6847             LDR      R7,[R0, #+4]
    218                          if((fabs(x_speed_to_input/g_sPx4flowData.ground_distance) < 0.015))
   \   000000CE   0x0030             MOVS     R0,R6
   \   000000D0   0x....             LDR.N    R1,??DataTable7_13
   \   000000D2   0x6909             LDR      R1,[R1, #+16]
   \   000000D4   0x.... 0x....      BL       __aeabi_fdiv
   \   000000D8   0x.... 0x....      BL       __aeabi_f2d
   \   000000DC   0xF031 0x4100      BICS     R1,R1,#0x80000000
   \   000000E0   0x....             LDR.N    R2,??DataTable7_17  ;; 0xeb851eb8
   \   000000E2   0x....             LDR.N    R3,??DataTable7_18  ;; 0x3f8eb851
   \   000000E4   0x.... 0x....      BL       __aeabi_cdcmple
   \   000000E8   0xD201             BCS.N    ??GPSUartRxIsr_2
    219                          {
    220                              x_speed_to_input = 0;
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0x0006             MOVS     R6,R0
    221                          }
    222                          if((fabs(y_speed_to_input/g_sPx4flowData.ground_distance) < 0.015))
   \                     ??GPSUartRxIsr_2:
   \   000000EE   0x0038             MOVS     R0,R7
   \   000000F0   0x....             LDR.N    R1,??DataTable7_13
   \   000000F2   0x6909             LDR      R1,[R1, #+16]
   \   000000F4   0x.... 0x....      BL       __aeabi_fdiv
   \   000000F8   0x.... 0x....      BL       __aeabi_f2d
   \   000000FC   0xF031 0x4100      BICS     R1,R1,#0x80000000
   \   00000100   0x....             LDR.N    R2,??DataTable7_17  ;; 0xeb851eb8
   \   00000102   0x....             LDR.N    R3,??DataTable7_18  ;; 0x3f8eb851
   \   00000104   0x.... 0x....      BL       __aeabi_cdcmple
   \   00000108   0xD201             BCS.N    ??GPSUartRxIsr_3
    223                          {
    224                              y_speed_to_input = 0;
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0x0007             MOVS     R7,R0
    225                          }                
    226                          AddSpeedToPosition(x_speed_to_input, y_speed_to_input, 0, (float)g_ulFlowTime / 1000.0f, &g_f32XPosition, &g_f32YPosition);                
   \                     ??GPSUartRxIsr_3:
   \   0000010E   0x....             LDR.N    R0,??DataTable7_19
   \   00000110   0x9001             STR      R0,[SP, #+4]
   \   00000112   0x....             LDR.N    R0,??DataTable7_20
   \   00000114   0x9000             STR      R0,[SP, #+0]
   \   00000116   0x....             LDR.N    R0,??DataTable7_16
   \   00000118   0x6800             LDR      R0,[R0, #+0]
   \   0000011A   0x.... 0x....      BL       __aeabi_ui2f
   \   0000011E   0x....             LDR.N    R1,??DataTable7_21  ;; 0x447a0000
   \   00000120   0x.... 0x....      BL       __aeabi_fdiv
   \   00000124   0x0003             MOVS     R3,R0
   \   00000126   0x2200             MOVS     R2,#+0
   \   00000128   0x0039             MOVS     R1,R7
   \   0000012A   0x0030             MOVS     R0,R6
   \   0000012C   0x.... 0x....      BL       AddSpeedToPosition
    227                      }
    228                  }
    229              }
    230          
    231              /*switch(recv)
    232              {
    233                  case 'a': g_f32DebugRoll += 0.5;
    234                            break;
    235                  case 'd': g_f32DebugRoll -= 0.5;
    236                            break;
    237                  case 'w': g_f32DebugPitch -= 0.5;
    238                            break;
    239                  case 's': g_f32DebugPitch += 0.5;
    240                            break;
    241                  case 'j': g_f32DebugYaw -= 0.5;
    242                            break;
    243                  case 'l': g_f32DebugYaw += 0.5;
    244                            break;
    245                  case 'i': g_f32DebugThrottle += 0.01;
    246                            break;
    247                  case 'k': g_f32DebugThrottle -= 0.01;
    248                            break;
    249                  case 'b': g_f32DebugYaw = 0;
    250                            g_f32DebugPitch = 0;
    251                            g_f32DebugRoll = 0;
    252                            break;
    253                  case ' ': g_f32DebugThrottle = 0;
    254                            break;
    255                  case 'y': g_f32DebugThrottle = 0.6;
    256                            break;
    257                  case 'n': g_f32DebugThrottle = 0.4;
    258                            break;
    259                  case 'o': g_f32DebugThrottle = 0.5;
    260                            break;                  
    261                  case 'g': g_f32DebugThrottle = 1;
    262                            break;
    263                  default:  break;
    264              }          
    265              sprintf(str_buf, "Yaw:%d\tPitch:%d\tRoll:%d\tThrottle:%d\t\n\r", (int)(g_f32DebugYaw * 10), (int)(g_f32DebugPitch * 10), (int)(g_f32DebugRoll * 10), (int)(g_f32DebugThrottle * 100));
    266              PutStringUartQueue(GPS_UART, str_buf);   */
    267          }
   \                     ??GPSUartRxIsr_1:
   \   00000130   0xE8BD 0x81FF      POP      {R0-R8,PC}       ;; return

   \                                 In section .bss, align 4
   \                     ??last_flow_time_tag:
   \   00000000                      DS8 4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x400EA000         DC32     0x400ea000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x4006C000         DC32     0x4006c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x400EB000         DC32     0x400eb000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     g_u32DebugPWM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x........         DC32     `?<Constant "PWM%d: %d\\n\\r">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x........         DC32     `?<Constant "PWM ALL: 0\\n\\r">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x........         DC32     g_u32LostSignalTimerCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x41200000         DC32     0x41200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x........         DC32     g_f32DebugYaw

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \   00000000   0x........         DC32     g_f32DebugPitch

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \   00000000   0x........         DC32     g_f32DebugRoll

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_11:
   \   00000000   0x42C80000         DC32     0x42c80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_12:
   \   00000000   0x........         DC32     g_f32DebugThrottle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_13:
   \   00000000   0x........         DC32     g_sPx4flowData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_14:
   \   00000000   0x........         DC32     g_u8FlowNewData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_15:
   \   00000000   0x........         DC32     ??last_flow_time_tag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_16:
   \   00000000   0x........         DC32     g_ulFlowTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_17:
   \   00000000   0xEB851EB8         DC32     0xeb851eb8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_18:
   \   00000000   0x3F8EB851         DC32     0x3f8eb851

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_19:
   \   00000000   0x........         DC32     g_f32YPosition

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_20:
   \   00000000   0x........         DC32     g_f32XPosition

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_21:
   \   00000000   0x447A0000         DC32     0x447a0000

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0H
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0H
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0H
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "PWM%d: %d\\n\\r">`:
   \   00000000   0x50 0x57          DC8 "PWM%d: %d\012\015"
   \              0x4D 0x25    
   \              0x64 0x3A    
   \              0x20 0x25    
   \              0x64 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "PWM ALL: 0\\n\\r">`:
   \   00000000   0x50 0x57          DC8 "PWM ALL: 0\012\015"
   \              0x4D 0x20    
   \              0x41 0x4C    
   \              0x4C 0x3A    
   \              0x20 0x30    
   \              0x0A 0x0D    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    268          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  CommUartSendByteArr
              16 -> LPLD_UART_PutCharArr
        8  CommUartSendOneByte
               8 -> LPLD_UART_PutChar
        8  CommUartSendString
               8 -> CommUartSendOneByte
        8  CommunicateUartRxIsr
               8 -> LPLD_UART_GetChar
               8 -> LPLD_UART_PutChar
               8 -> ToggleLights
      144  DebugUartRxIsr
             144 -> LPLD_UART_GetChar
             144 -> PutStringUartQueue
             144 -> ToggleLights
             144 -> sprintf
       40  GPSUartRxIsr
              40 -> AddSpeedToPosition
              40 -> DecodeControlParaData
              40 -> DecodePX4FLOWData
              40 -> FlowFilterGetCurrentFlowComp
              40 -> Flow_RefreshRawData
              40 -> GetSystemClockMs
              40 -> LPLD_UART_GetChar
              40 -> RecvFrame
              40 -> ToggleLights
              40 -> __aeabi_cdcmple
              40 -> __aeabi_f2d
              40 -> __aeabi_fdiv
              40 -> __aeabi_i2f
              40 -> __aeabi_ui2f
       48  InitCommunicateUart
              32 -> LPLD_UART_Init
              32 -> __aeabi_memclr4
              48 -> __aeabi_memcpy4
       48  InitDebugUart
              32 -> LPLD_UART_EnableIrq
              32 -> LPLD_UART_Init
              32 -> __aeabi_memclr4
              48 -> __aeabi_memcpy4
       48  InitGPSUart
              32 -> LPLD_UART_EnableIrq
              32 -> LPLD_UART_Init
              32 -> __aeabi_memclr4
              48 -> __aeabi_memcpy4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?<Constant "PWM ALL: 0\n\r">
      12  ?<Constant "PWM%d: %d\n\r">
      20  ?<Constant {(UART_Type *)0}>
      20  ?<Constant {(UART_Type *)0}>_1
      20  ?<Constant {(UART_Type *)0}>_2
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_14
       4  ??DataTable7_15
       4  ??DataTable7_16
       4  ??DataTable7_17
       4  ??DataTable7_18
       4  ??DataTable7_19
       4  ??DataTable7_2
       4  ??DataTable7_20
       4  ??DataTable7_21
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
      18  CommUartSendByteArr
      18  CommUartSendOneByte
      26  CommUartSendString
      28  CommunicateUartRxIsr
     400  DebugUartRxIsr
     308  GPSUartRxIsr
      58  InitCommunicateUart
      88  InitDebugUart
      88  InitGPSUart
       4  g_f32DebugPitch
       4  g_f32DebugRoll
       4  g_f32DebugThrottle
       4  g_f32DebugYaw
       4  g_f32XPosition
       4  g_f32YPosition
      20  g_sPx4flowData
      16  g_u32DebugPWM
       1  g_u8FlowNewData
       4  g_ulFlowTime
       4  last_flow_time_tag

 
    69 bytes in section .bss
    88 bytes in section .rodata
 1 120 bytes in section .text
 
 1 120 bytes of CODE  memory
    88 bytes of CONST memory
    69 bytes of DATA  memory

Errors: none
Warnings: none
