###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     13/Apr/2014  20:54:18 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\source\modu #
#                    le\anbt_dmp\anbt_dmp_mpu6050.c                           #
#    Command line =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\source\modu #
#                    le\anbt_dmp\anbt_dmp_mpu6050.c -D LPLD_K60 -lCN          #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\FLASH_M #
#                    INE\List\ -lB E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_ #
#                    V2\iar\FLASH_MINE\List\ -o E:\ShawnDocuments\IAR_WorkSpa #
#                    ce\LPLD_Quad_V2\iar\FLASH_MINE\Obj\ --no_cse             #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\sour #
#                    ce\app\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\ #
#                    iar\..\source\app\Communicate\ -I                        #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\sour #
#                    ce\app\Algorithm\ -I E:\ShawnDocuments\IAR_WorkSpace\LPL #
#                    D_Quad_V2\iar\..\source\app\SignalProcess\ -I            #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\sour #
#                    ce\module\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_ #
#                    V2\iar\..\source\module\anbt_dmp\ -I                     #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\sour #
#                    ce\module\eMPL\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_ #
#                    Quad_V2\iar\..\source\lib\CPU\ -I                        #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\sour #
#                    ce\lib\common\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Q #
#                    uad_V2\iar\..\source\lib\LPLD\ -I                        #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\sour #
#                    ce\lib\LPLD\HW\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_ #
#                    Quad_V2\iar\..\source\lib\LPLD\DEV\ -I                   #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\sour #
#                    ce\lib\uCOS-II\Ports\ -I E:\ShawnDocuments\IAR_WorkSpace #
#                    \LPLD_Quad_V2\iar\..\source\lib\uCOS-II\Source\ -I       #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\sour #
#                    ce\lib\FatFs\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Qu #
#                    ad_V2\iar\..\source\lib\FatFs\option\ -I                 #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\sour #
#                    ce\lib\USB\common\ -I E:\ShawnDocuments\IAR_WorkSpace\LP #
#                    LD_Quad_V2\iar\..\source\lib\USB\driver\ -I              #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\sour #
#                    ce\lib\USB\descriptor\ -I E:\ShawnDocuments\IAR_WorkSpac #
#                    e\LPLD_Quad_V2\iar\..\source\lib\USB\class\ -I           #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\sour #
#                    ce\lib\MyLib\ -On -I "D:\Program Files\IAR               #
#                    Systems\Embedded Workbench 6.4\arm\CMSIS\Include\" -D    #
#                    ARM_MATH_CM4                                             #
#    List file    =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\FLASH_M #
#                    INE\List\anbt_dmp_mpu6050.lst                            #
#    Object file  =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\FLASH_M #
#                    INE\Obj\anbt_dmp_mpu6050.o                               #
#                                                                             #
#                                                                             #
###############################################################################

E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\source\module\anbt_dmp\anbt_dmp_mpu6050.c
      1          //**************************************************************************************
      2          //License:
      3          //Copyright (C) 2011-2012 InvenSense Corporation, All Rights Reserved.
      4          //See included License.txt for License information.
      5          //
      6          //*  @addtogroup  DRIVERS Sensor Driver Layer
      7          //*  @brief       Hardware drivers to communicate with sensors via I2C.
      8          //*
      9          //*  @{
     10          //*      @file       inv_mpu_dmp_motion_driver.c
     11          //*      @brief      DMP image and interface functions.
     12          //*      @details    All functions are preceded by the dmp_ prefix to
     13          //*                  differentiate among MPL and general driver function calls.
     14          //**************************************************************************************
     15          //#include <stdio.h>
     16          #include <stdint.h>
     17          #include <stdlib.h>
     18          //#include <string.h>
     19          _C_LIB_DECL
     20          __EFF_NENW1NW2   __ATTRIBUTES int        memcmp(const void *, const void *,
     21                                                          unsigned int);
     22          _END_C_LIB_DECL
     23          #include <math.h>
     24          #include "anbt_dmp_mpu6050.h"

   \                                 In section .rodata, align 4
   \   __absolute struct gyro_reg_s const reg
   \                     reg:
   \   00000000   0x75 0x19          DC8 117, 25, 26, 12, 106, 35, 27, 28, 31, 32, 114, 116, 67, 59, 65, 56
   \              0x1A 0x0C    
   \              0x6A 0x23    
   \              0x1B 0x1C    
   \              0x1F 0x20    
   \              0x72 0x74    
   \              0x43 0x3B    
   \              0x41 0x38    
   \   00000010   0x39 0x3A          DC8 57, 58, 107, 108, 55, 111, 6, 36, 109, 110, 112, 0
   \              0x6B 0x6C    
   \              0x37 0x6F    
   \              0x06 0x24    
   \              0x6D 0x6E    
   \              0x70 0x00    

   \                                 In section .rodata, align 4
   \   __absolute struct hw_s const hw
   \                     hw:
   \   00000000   0x68 0x00          DC8 104, 0
   \   00000002   0x0400             DC16 1024
   \   00000004   0x76 0x00          DC8 118, 0
   \   00000006   0x0154 0xFDF7      DC16 340, -521, 256
   \              0x0100       

   \                                 In section .rodata, align 4
   \   __absolute struct test_s const test
   \                     test:
   \   00000000   0x00000083         DC32 131, 2048
   \              0x00000800   
   \   00000008   0x00 0x01          DC8 0, 1, 0, 24
   \              0x00 0x18    
   \   0000000C   0x0032             DC16 50
   \   0000000E   0x05 0x00          DC8 5, 0
   \   00000010   0x41200000         DC32 41200000H, 42D20000H, 3E0F5C29H, 3E99999AH, 3F733333H, 3E0F5C29H
   \              0x42D20000   
   \              0x3E0F5C29   
   \              0x3E99999A   
   \              0x3F733333   
   \              0x3E0F5C29   

   \                                 In section .data, align 4
   \   static __absolute struct gyro_state_s st
   \                     st:
   \   00000000   0x........         DC32 reg, hw
   \              0x........   
   \   00000008   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000028   0x........         DC32 test

   \                                 In section .data, align 4
   \   static __absolute signed char gyro_orientation[9]
   \                     gyro_orientation:
   \   00000000   0xFF 0x00          DC8 -1, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0
   \              0x00 0x00    
   \              0xFF 0x00    
   \              0x00 0x00    
   \              0x01 0x00    
   \              0x00 0x00    

   \                                 In section .bss, align 4
   \   __absolute long anbt_mpu6050_quat_data[4]
   \                     anbt_mpu6050_quat_data:
   \   00000000                      DS8 16

   \                                 In section .bss, align 4
   \   __absolute short gyro[3]
   \                     gyro:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
   \   __absolute short accel[3]
   \                     accel:
   \   00000000                      DS8 8

   \                                 In section .bss, align 2
   \   __absolute short sensors
   \                     sensors:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
   \   __absolute unsigned char more
   \                     more:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute unsigned long sensor_timestamp
   \                     sensor_timestamp:
   \   00000000                      DS8 4
     25          #include "anbt_dmp_driver.h"
     26          #include "anbt_dmp_fun.h"
     27          #include "anbt_dmp.h"
     28          //

   \                                 In section .text, align 2, keep-with-next
     29          int mpu_set_gyro_fsr(unsigned short fsr)
     30          {
   \                     mpu_set_gyro_fsr:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
     31              unsigned char data;
     32          
     33              if (!(st.chip_cfg.sensors))
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000000A   0x7A80             LDRB     R0,[R0, #+10]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD102             BNE.N    ??mpu_set_gyro_fsr_0
     34                  return -1;
   \   00000010   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000014   0xE044             B.N      ??mpu_set_gyro_fsr_1
     35          
     36              switch (fsr) {
   \                     ??mpu_set_gyro_fsr_0:
   \   00000016   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x28FA             CMP      R0,#+250
   \   0000001C   0xD009             BEQ.N    ??mpu_set_gyro_fsr_2
   \   0000001E   0xF5B0 0x7FFA      CMP      R0,#+500
   \   00000022   0xD00A             BEQ.N    ??mpu_set_gyro_fsr_3
   \   00000024   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   00000028   0xD00B             BEQ.N    ??mpu_set_gyro_fsr_4
   \   0000002A   0xF5B0 0x6FFA      CMP      R0,#+2000
   \   0000002E   0xD00C             BEQ.N    ??mpu_set_gyro_fsr_5
   \   00000030   0xE00F             B.N      ??mpu_set_gyro_fsr_6
     37              case 250:
     38                  data = INV_FSR_250DPS << 3;
   \                     ??mpu_set_gyro_fsr_2:
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF88D 0x0000      STRB     R0,[SP, #+0]
     39                  break;
   \   00000038   0xE00E             B.N      ??mpu_set_gyro_fsr_7
     40              case 500:
     41                  data = INV_FSR_500DPS << 3;
   \                     ??mpu_set_gyro_fsr_3:
   \   0000003A   0x2008             MOVS     R0,#+8
   \   0000003C   0xF88D 0x0000      STRB     R0,[SP, #+0]
     42                  break;
   \   00000040   0xE00A             B.N      ??mpu_set_gyro_fsr_7
     43              case 1000:
     44                  data = INV_FSR_1000DPS << 3;
   \                     ??mpu_set_gyro_fsr_4:
   \   00000042   0x2010             MOVS     R0,#+16
   \   00000044   0xF88D 0x0000      STRB     R0,[SP, #+0]
     45                  break;
   \   00000048   0xE006             B.N      ??mpu_set_gyro_fsr_7
     46              case 2000:
     47                  data = INV_FSR_2000DPS << 3;
   \                     ??mpu_set_gyro_fsr_5:
   \   0000004A   0x2018             MOVS     R0,#+24
   \   0000004C   0xF88D 0x0000      STRB     R0,[SP, #+0]
     48                  break;
   \   00000050   0xE002             B.N      ??mpu_set_gyro_fsr_7
     49              default:
     50                  return -1;
   \                     ??mpu_set_gyro_fsr_6:
   \   00000052   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000056   0xE023             B.N      ??mpu_set_gyro_fsr_1
     51              }
     52          
     53              if (st.chip_cfg.gyro_fsr == (data >> 3))
   \                     ??mpu_set_gyro_fsr_7:
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000005C   0x7A00             LDRB     R0,[R0, #+8]
   \   0000005E   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000062   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000064   0x08C9             LSRS     R1,R1,#+3
   \   00000066   0x4288             CMP      R0,R1
   \   00000068   0xD101             BNE.N    ??mpu_set_gyro_fsr_8
     54                  return 0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xE018             B.N      ??mpu_set_gyro_fsr_1
     55              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
   \                     ??mpu_set_gyro_fsr_8:
   \   0000006E   0xAB00             ADD      R3,SP,#+0
   \   00000070   0x2201             MOVS     R2,#+1
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x7981             LDRB     R1,[R0, #+6]
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000007E   0x6840             LDR      R0,[R0, #+4]
   \   00000080   0x7800             LDRB     R0,[R0, #+0]
   \   00000082   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD002             BEQ.N    ??mpu_set_gyro_fsr_9
     56                  return -1;
   \   0000008A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000008E   0xE007             B.N      ??mpu_set_gyro_fsr_1
     57              st.chip_cfg.gyro_fsr = data >> 3;
   \                     ??mpu_set_gyro_fsr_9:
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000094   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000098   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000009A   0x08C9             LSRS     R1,R1,#+3
   \   0000009C   0x7201             STRB     R1,[R0, #+8]
     58              return 0;
   \   0000009E   0x2000             MOVS     R0,#+0
   \                     ??mpu_set_gyro_fsr_1:
   \   000000A0   0xBD16             POP      {R1,R2,R4,PC}    ;; return
     59          }

   \                                 In section .text, align 2, keep-with-next
     60          int mpu_set_accel_fsr(unsigned char fsr)
     61          {
   \                     mpu_set_accel_fsr:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
     62              unsigned char data;
     63          
     64              if (!(st.chip_cfg.sensors))
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000000A   0x7A80             LDRB     R0,[R0, #+10]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD102             BNE.N    ??mpu_set_accel_fsr_0
     65                  return -1;
   \   00000010   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000014   0xE041             B.N      ??mpu_set_accel_fsr_1
     66          
     67              switch (fsr) {
   \                     ??mpu_set_accel_fsr_0:
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x2802             CMP      R0,#+2
   \   0000001C   0xD006             BEQ.N    ??mpu_set_accel_fsr_2
   \   0000001E   0x2804             CMP      R0,#+4
   \   00000020   0xD008             BEQ.N    ??mpu_set_accel_fsr_3
   \   00000022   0x2808             CMP      R0,#+8
   \   00000024   0xD00A             BEQ.N    ??mpu_set_accel_fsr_4
   \   00000026   0x2810             CMP      R0,#+16
   \   00000028   0xD00C             BEQ.N    ??mpu_set_accel_fsr_5
   \   0000002A   0xE00F             B.N      ??mpu_set_accel_fsr_6
     68              case 2:
     69                  data = INV_FSR_2G << 3;
   \                     ??mpu_set_accel_fsr_2:
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF88D 0x0000      STRB     R0,[SP, #+0]
     70                  break;
   \   00000032   0xE00E             B.N      ??mpu_set_accel_fsr_7
     71              case 4:
     72                  data = INV_FSR_4G << 3;
   \                     ??mpu_set_accel_fsr_3:
   \   00000034   0x2008             MOVS     R0,#+8
   \   00000036   0xF88D 0x0000      STRB     R0,[SP, #+0]
     73                  break;
   \   0000003A   0xE00A             B.N      ??mpu_set_accel_fsr_7
     74              case 8:
     75                  data = INV_FSR_8G << 3;
   \                     ??mpu_set_accel_fsr_4:
   \   0000003C   0x2010             MOVS     R0,#+16
   \   0000003E   0xF88D 0x0000      STRB     R0,[SP, #+0]
     76                  break;
   \   00000042   0xE006             B.N      ??mpu_set_accel_fsr_7
     77              case 16:
     78                  data = INV_FSR_16G << 3;
   \                     ??mpu_set_accel_fsr_5:
   \   00000044   0x2018             MOVS     R0,#+24
   \   00000046   0xF88D 0x0000      STRB     R0,[SP, #+0]
     79                  break;
   \   0000004A   0xE002             B.N      ??mpu_set_accel_fsr_7
     80              default:
     81                  return -1;
   \                     ??mpu_set_accel_fsr_6:
   \   0000004C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000050   0xE023             B.N      ??mpu_set_accel_fsr_1
     82              }
     83              if (st.chip_cfg.accel_fsr == (data >> 3))
   \                     ??mpu_set_accel_fsr_7:
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000056   0x7A40             LDRB     R0,[R0, #+9]
   \   00000058   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000005C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000005E   0x08C9             LSRS     R1,R1,#+3
   \   00000060   0x4288             CMP      R0,R1
   \   00000062   0xD101             BNE.N    ??mpu_set_accel_fsr_8
     84                  return 0;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xE018             B.N      ??mpu_set_accel_fsr_1
     85              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->accel_cfg, 1, &data))
   \                     ??mpu_set_accel_fsr_8:
   \   00000068   0xAB00             ADD      R3,SP,#+0
   \   0000006A   0x2201             MOVS     R2,#+1
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x79C1             LDRB     R1,[R0, #+7]
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000078   0x6840             LDR      R0,[R0, #+4]
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
   \   0000007C   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD002             BEQ.N    ??mpu_set_accel_fsr_9
     86                  return -1;
   \   00000084   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000088   0xE007             B.N      ??mpu_set_accel_fsr_1
     87              st.chip_cfg.accel_fsr = data >> 3;
   \                     ??mpu_set_accel_fsr_9:
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000008E   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000092   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000094   0x08C9             LSRS     R1,R1,#+3
   \   00000096   0x7241             STRB     R1,[R0, #+9]
     88              return 0;
   \   00000098   0x2000             MOVS     R0,#+0
   \                     ??mpu_set_accel_fsr_1:
   \   0000009A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
     89          }

   \                                 In section .text, align 2, keep-with-next
     90          int mpu_set_lpf(unsigned short lpf)
     91          {
   \                     mpu_set_lpf:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
     92              unsigned char data;
     93          
     94              if (!(st.chip_cfg.sensors))
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000000A   0x7A80             LDRB     R0,[R0, #+10]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD102             BNE.N    ??mpu_set_lpf_0
     95                  return -1;
   \   00000010   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000014   0xE045             B.N      ??mpu_set_lpf_1
     96          
     97              if (lpf >= 188)
   \                     ??mpu_set_lpf_0:
   \   00000016   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000018   0x2CBC             CMP      R4,#+188
   \   0000001A   0xD303             BCC.N    ??mpu_set_lpf_2
     98                  data = INV_FILTER_188HZ;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000022   0xE01E             B.N      ??mpu_set_lpf_3
     99              else if (lpf >= 98)
   \                     ??mpu_set_lpf_2:
   \   00000024   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000026   0x2C62             CMP      R4,#+98
   \   00000028   0xD303             BCC.N    ??mpu_set_lpf_4
    100                  data = INV_FILTER_98HZ;
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000030   0xE017             B.N      ??mpu_set_lpf_3
    101              else if (lpf >= 42)
   \                     ??mpu_set_lpf_4:
   \   00000032   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000034   0x2C2A             CMP      R4,#+42
   \   00000036   0xD303             BCC.N    ??mpu_set_lpf_5
    102                  data = INV_FILTER_42HZ;
   \   00000038   0x2003             MOVS     R0,#+3
   \   0000003A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000003E   0xE010             B.N      ??mpu_set_lpf_3
    103              else if (lpf >= 20)
   \                     ??mpu_set_lpf_5:
   \   00000040   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000042   0x2C14             CMP      R4,#+20
   \   00000044   0xD303             BCC.N    ??mpu_set_lpf_6
    104                  data = INV_FILTER_20HZ;
   \   00000046   0x2004             MOVS     R0,#+4
   \   00000048   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000004C   0xE009             B.N      ??mpu_set_lpf_3
    105              else if (lpf >= 10)
   \                     ??mpu_set_lpf_6:
   \   0000004E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000050   0x2C0A             CMP      R4,#+10
   \   00000052   0xD303             BCC.N    ??mpu_set_lpf_7
    106                  data = INV_FILTER_10HZ;
   \   00000054   0x2005             MOVS     R0,#+5
   \   00000056   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000005A   0xE002             B.N      ??mpu_set_lpf_3
    107              else
    108                  data = INV_FILTER_5HZ;
   \                     ??mpu_set_lpf_7:
   \   0000005C   0x2006             MOVS     R0,#+6
   \   0000005E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    109          
    110              if (st.chip_cfg.lpf == data)
   \                     ??mpu_set_lpf_3:
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000066   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000068   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xD101             BNE.N    ??mpu_set_lpf_8
    111                  return 0;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xE016             B.N      ??mpu_set_lpf_1
    112              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->lpf, 1, &data))
   \                     ??mpu_set_lpf_8:
   \   00000074   0xAB00             ADD      R3,SP,#+0
   \   00000076   0x2201             MOVS     R2,#+1
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x7881             LDRB     R1,[R0, #+2]
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000084   0x6840             LDR      R0,[R0, #+4]
   \   00000086   0x7800             LDRB     R0,[R0, #+0]
   \   00000088   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD002             BEQ.N    ??mpu_set_lpf_9
    113                  return -1;
   \   00000090   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000094   0xE005             B.N      ??mpu_set_lpf_1
    114              st.chip_cfg.lpf = data;
   \                     ??mpu_set_lpf_9:
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000009A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000009E   0x72C1             STRB     R1,[R0, #+11]
    115              return 0;
   \   000000A0   0x2000             MOVS     R0,#+0
   \                     ??mpu_set_lpf_1:
   \   000000A2   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    116          }
    117          //

   \                                 In section .text, align 2, keep-with-next
    118          int mpu_set_int_latched(unsigned char enable)
    119          {
   \                     mpu_set_int_latched:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    120              unsigned char tmp;
    121              if (st.chip_cfg.latched_int == enable)
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000000A   0xF890 0x0023      LDRB     R0,[R0, #+35]
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x42A0             CMP      R0,R4
   \   00000012   0xD101             BNE.N    ??mpu_set_int_latched_0
    122                  return 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE036             B.N      ??mpu_set_int_latched_1
    123          
    124              if (enable)
   \                     ??mpu_set_int_latched_0:
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD003             BEQ.N    ??mpu_set_int_latched_2
    125                  tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
   \   0000001E   0x2030             MOVS     R0,#+48
   \   00000020   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000024   0xE002             B.N      ??mpu_set_int_latched_3
    126              else
    127                  tmp = 0;
   \                     ??mpu_set_int_latched_2:
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF88D 0x0000      STRB     R0,[SP, #+0]
    128              if (st.chip_cfg.bypass_mode)
   \                     ??mpu_set_int_latched_3:
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000030   0x7C80             LDRB     R0,[R0, #+18]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD005             BEQ.N    ??mpu_set_int_latched_4
    129                  tmp |= BIT_BYPASS_EN;
   \   00000036   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000003E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    130              if (st.chip_cfg.active_low_int)
   \                     ??mpu_set_int_latched_4:
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000046   0xF890 0x0022      LDRB     R0,[R0, #+34]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD005             BEQ.N    ??mpu_set_int_latched_5
    131                  tmp |= BIT_ACTL;
   \   0000004E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000052   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000056   0xF88D 0x0000      STRB     R0,[SP, #+0]
    132              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
   \                     ??mpu_set_int_latched_5:
   \   0000005A   0xAB00             ADD      R3,SP,#+0
   \   0000005C   0x2201             MOVS     R2,#+1
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x7D01             LDRB     R1,[R0, #+20]
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000006A   0x6840             LDR      R0,[R0, #+4]
   \   0000006C   0x7800             LDRB     R0,[R0, #+0]
   \   0000006E   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD002             BEQ.N    ??mpu_set_int_latched_6
    133                  return -1;
   \   00000076   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000007A   0xE004             B.N      ??mpu_set_int_latched_1
    134              st.chip_cfg.latched_int = enable;
   \                     ??mpu_set_int_latched_6:
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000080   0xF880 0x4023      STRB     R4,[R0, #+35]
    135              return 0;
   \   00000084   0x2000             MOVS     R0,#+0
   \                     ??mpu_set_int_latched_1:
   \   00000086   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    136          }

   \                                 In section .text, align 2, keep-with-next
    137          static int set_int_enable(unsigned char enable)
    138          {
   \                     set_int_enable:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    139              unsigned char tmp;
    140          
    141              if (st.chip_cfg.dmp_on) {
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000000A   0xF890 0x0024      LDRB     R0,[R0, #+36]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD020             BEQ.N    ??set_int_enable_0
    142                  if (enable)
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD003             BEQ.N    ??set_int_enable_1
    143                      tmp = BIT_DMP_INT_EN;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000001E   0xE002             B.N      ??set_int_enable_2
    144                  else
    145                      tmp = 0x00;
   \                     ??set_int_enable_1:
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF88D 0x0000      STRB     R0,[SP, #+0]
    146                  if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->int_enable, 1, &tmp))
   \                     ??set_int_enable_2:
   \   00000026   0xAB00             ADD      R3,SP,#+0
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x7BC1             LDRB     R1,[R0, #+15]
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000036   0x6840             LDR      R0,[R0, #+4]
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD002             BEQ.N    ??set_int_enable_3
    147                      return -1;
   \   00000042   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000046   0xE038             B.N      ??set_int_enable_4
    148                  st.chip_cfg.int_enable = tmp;
   \                     ??set_int_enable_3:
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000004C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000050   0x7441             STRB     R1,[R0, #+17]
   \   00000052   0xE031             B.N      ??set_int_enable_5
    149              } else {
    150                  if (!st.chip_cfg.sensors)
   \                     ??set_int_enable_0:
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000058   0x7A80             LDRB     R0,[R0, #+10]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD102             BNE.N    ??set_int_enable_6
    151                      return -1;
   \   0000005E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000062   0xE02A             B.N      ??set_int_enable_4
    152                  if (enable && st.chip_cfg.int_enable)
   \                     ??set_int_enable_6:
   \   00000064   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000066   0x2C00             CMP      R4,#+0
   \   00000068   0xD006             BEQ.N    ??set_int_enable_7
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000006E   0x7C40             LDRB     R0,[R0, #+17]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD001             BEQ.N    ??set_int_enable_7
    153                      return 0;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xE020             B.N      ??set_int_enable_4
    154                  if (enable)
   \                     ??set_int_enable_7:
   \   00000078   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007A   0x2C00             CMP      R4,#+0
   \   0000007C   0xD003             BEQ.N    ??set_int_enable_8
    155                      tmp = BIT_DATA_RDY_EN;
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000084   0xE002             B.N      ??set_int_enable_9
    156                  else
    157                      tmp = 0x00;
   \                     ??set_int_enable_8:
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xF88D 0x0000      STRB     R0,[SP, #+0]
    158                  if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->int_enable, 1, &tmp))
   \                     ??set_int_enable_9:
   \   0000008C   0xAB00             ADD      R3,SP,#+0
   \   0000008E   0x2201             MOVS     R2,#+1
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x7BC1             LDRB     R1,[R0, #+15]
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000009C   0x6840             LDR      R0,[R0, #+4]
   \   0000009E   0x7800             LDRB     R0,[R0, #+0]
   \   000000A0   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD002             BEQ.N    ??set_int_enable_10
    159                      return -1;
   \   000000A8   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000AC   0xE005             B.N      ??set_int_enable_4
    160                  st.chip_cfg.int_enable = tmp;
   \                     ??set_int_enable_10:
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000B2   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000000B6   0x7441             STRB     R1,[R0, #+17]
    161              }
    162              return 0;
   \                     ??set_int_enable_5:
   \   000000B8   0x2000             MOVS     R0,#+0
   \                     ??set_int_enable_4:
   \   000000BA   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    163          }
    164          //

   \                                 In section .text, align 2, keep-with-next
    165          int mpu_reset_fifo(void)
    166          {
   \                     mpu_reset_fifo:
   \   00000000   0xB580             PUSH     {R7,LR}
    167              unsigned char data;
    168          
    169              if (!(st.chip_cfg.sensors))
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000006   0x7A80             LDRB     R0,[R0, #+10]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD102             BNE.N    ??mpu_reset_fifo_0
    170                  return -1;
   \   0000000C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000010   0xE10B             B.N      ??mpu_reset_fifo_1
    171          
    172              data = 0;
   \                     ??mpu_reset_fifo_0:
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF88D 0x0000      STRB     R0,[SP, #+0]
    173              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->int_enable, 1, &data))
   \   00000018   0xAB00             ADD      R3,SP,#+0
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x7BC1             LDRB     R1,[R0, #+15]
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD002             BEQ.N    ??mpu_reset_fifo_2
    174                  return -1;
   \   00000034   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000038   0xE0F7             B.N      ??mpu_reset_fifo_1
    175              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->fifo_en, 1, &data))
   \                     ??mpu_reset_fifo_2:
   \   0000003A   0xAB00             ADD      R3,SP,#+0
   \   0000003C   0x2201             MOVS     R2,#+1
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x7941             LDRB     R1,[R0, #+5]
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000004A   0x6840             LDR      R0,[R0, #+4]
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD002             BEQ.N    ??mpu_reset_fifo_3
    176                  return -1;
   \   00000056   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000005A   0xE0E6             B.N      ??mpu_reset_fifo_1
    177              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \                     ??mpu_reset_fifo_3:
   \   0000005C   0xAB00             ADD      R3,SP,#+0
   \   0000005E   0x2201             MOVS     R2,#+1
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0x7901             LDRB     R1,[R0, #+4]
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000006C   0x6840             LDR      R0,[R0, #+4]
   \   0000006E   0x7800             LDRB     R0,[R0, #+0]
   \   00000070   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD002             BEQ.N    ??mpu_reset_fifo_4
    178                  return -1;
   \   00000078   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000007C   0xE0D5             B.N      ??mpu_reset_fifo_1
    179          
    180              if (st.chip_cfg.dmp_on) {
   \                     ??mpu_reset_fifo_4:
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000082   0xF890 0x0024      LDRB     R0,[R0, #+36]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD066             BEQ.N    ??mpu_reset_fifo_5
    181                  data = BIT_FIFO_RST | BIT_DMP_RST;
   \   0000008A   0x200C             MOVS     R0,#+12
   \   0000008C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    182                  if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \   00000090   0xAB00             ADD      R3,SP,#+0
   \   00000092   0x2201             MOVS     R2,#+1
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0x7901             LDRB     R1,[R0, #+4]
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000A0   0x6840             LDR      R0,[R0, #+4]
   \   000000A2   0x7800             LDRB     R0,[R0, #+0]
   \   000000A4   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD002             BEQ.N    ??mpu_reset_fifo_6
    183                      return -1;
   \   000000AC   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000B0   0xE0BB             B.N      ??mpu_reset_fifo_1
    184                  AnBT_DMP_Delay_ms(50);
   \                     ??mpu_reset_fifo_6:
   \   000000B2   0x2032             MOVS     R0,#+50
   \   000000B4   0x.... 0x....      BL       AnBT_DMP_Delay_ms
    185                  data = BIT_DMP_EN | BIT_FIFO_EN;
   \   000000B8   0x20C0             MOVS     R0,#+192
   \   000000BA   0xF88D 0x0000      STRB     R0,[SP, #+0]
    186                  if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000C2   0x7A80             LDRB     R0,[R0, #+10]
   \   000000C4   0x07C0             LSLS     R0,R0,#+31
   \   000000C6   0xD505             BPL.N    ??mpu_reset_fifo_7
    187                      data |= BIT_AUX_IF_EN;
   \   000000C8   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000CC   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000D0   0xF88D 0x0000      STRB     R0,[SP, #+0]
    188                  if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \                     ??mpu_reset_fifo_7:
   \   000000D4   0xAB00             ADD      R3,SP,#+0
   \   000000D6   0x2201             MOVS     R2,#+1
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000DC   0x6800             LDR      R0,[R0, #+0]
   \   000000DE   0x7901             LDRB     R1,[R0, #+4]
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000E4   0x6840             LDR      R0,[R0, #+4]
   \   000000E6   0x7800             LDRB     R0,[R0, #+0]
   \   000000E8   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD002             BEQ.N    ??mpu_reset_fifo_8
    189                      return -1;
   \   000000F0   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000F4   0xE099             B.N      ??mpu_reset_fifo_1
    190                  if (st.chip_cfg.int_enable)
   \                     ??mpu_reset_fifo_8:
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000FA   0x7C40             LDRB     R0,[R0, #+17]
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xD003             BEQ.N    ??mpu_reset_fifo_9
    191                      data = BIT_DMP_INT_EN;
   \   00000100   0x2002             MOVS     R0,#+2
   \   00000102   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000106   0xE002             B.N      ??mpu_reset_fifo_10
    192                  else
    193                      data = 0;
   \                     ??mpu_reset_fifo_9:
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    194                  if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->int_enable, 1, &data))
   \                     ??mpu_reset_fifo_10:
   \   0000010E   0xAB00             ADD      R3,SP,#+0
   \   00000110   0x2201             MOVS     R2,#+1
   \   00000112   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000116   0x6800             LDR      R0,[R0, #+0]
   \   00000118   0x7BC1             LDRB     R1,[R0, #+15]
   \   0000011A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000011E   0x6840             LDR      R0,[R0, #+4]
   \   00000120   0x7800             LDRB     R0,[R0, #+0]
   \   00000122   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000126   0x2800             CMP      R0,#+0
   \   00000128   0xD002             BEQ.N    ??mpu_reset_fifo_11
    195                      return -1;
   \   0000012A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000012E   0xE07C             B.N      ??mpu_reset_fifo_1
    196                  data = 0;
   \                     ??mpu_reset_fifo_11:
   \   00000130   0x2000             MOVS     R0,#+0
   \   00000132   0xF88D 0x0000      STRB     R0,[SP, #+0]
    197                  if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->fifo_en, 1, &data))
   \   00000136   0xAB00             ADD      R3,SP,#+0
   \   00000138   0x2201             MOVS     R2,#+1
   \   0000013A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000013E   0x6800             LDR      R0,[R0, #+0]
   \   00000140   0x7941             LDRB     R1,[R0, #+5]
   \   00000142   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000146   0x6840             LDR      R0,[R0, #+4]
   \   00000148   0x7800             LDRB     R0,[R0, #+0]
   \   0000014A   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   0000014E   0x2800             CMP      R0,#+0
   \   00000150   0xD06A             BEQ.N    ??mpu_reset_fifo_12
    198                      return -1;
   \   00000152   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000156   0xE068             B.N      ??mpu_reset_fifo_1
    199              } else {
    200                  data = BIT_FIFO_RST;
   \                     ??mpu_reset_fifo_5:
   \   00000158   0x2004             MOVS     R0,#+4
   \   0000015A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    201                  if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \   0000015E   0xAB00             ADD      R3,SP,#+0
   \   00000160   0x2201             MOVS     R2,#+1
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000166   0x6800             LDR      R0,[R0, #+0]
   \   00000168   0x7901             LDRB     R1,[R0, #+4]
   \   0000016A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000016E   0x6840             LDR      R0,[R0, #+4]
   \   00000170   0x7800             LDRB     R0,[R0, #+0]
   \   00000172   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000176   0x2800             CMP      R0,#+0
   \   00000178   0xD002             BEQ.N    ??mpu_reset_fifo_13
    202                      return -1;
   \   0000017A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000017E   0xE054             B.N      ??mpu_reset_fifo_1
    203                  if (st.chip_cfg.bypass_mode || !(st.chip_cfg.sensors & INV_XYZ_COMPASS))
   \                     ??mpu_reset_fifo_13:
   \   00000180   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000184   0x7C80             LDRB     R0,[R0, #+18]
   \   00000186   0x2800             CMP      R0,#+0
   \   00000188   0xD104             BNE.N    ??mpu_reset_fifo_14
   \   0000018A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000018E   0x7A80             LDRB     R0,[R0, #+10]
   \   00000190   0x07C0             LSLS     R0,R0,#+31
   \   00000192   0xD403             BMI.N    ??mpu_reset_fifo_15
    204                      data = BIT_FIFO_EN;
   \                     ??mpu_reset_fifo_14:
   \   00000194   0x2040             MOVS     R0,#+64
   \   00000196   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000019A   0xE002             B.N      ??mpu_reset_fifo_16
    205                  else
    206                      data = BIT_FIFO_EN | BIT_AUX_IF_EN;
   \                     ??mpu_reset_fifo_15:
   \   0000019C   0x2060             MOVS     R0,#+96
   \   0000019E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    207                  if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \                     ??mpu_reset_fifo_16:
   \   000001A2   0xAB00             ADD      R3,SP,#+0
   \   000001A4   0x2201             MOVS     R2,#+1
   \   000001A6   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000001AA   0x6800             LDR      R0,[R0, #+0]
   \   000001AC   0x7901             LDRB     R1,[R0, #+4]
   \   000001AE   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000001B2   0x6840             LDR      R0,[R0, #+4]
   \   000001B4   0x7800             LDRB     R0,[R0, #+0]
   \   000001B6   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   000001BA   0x2800             CMP      R0,#+0
   \   000001BC   0xD002             BEQ.N    ??mpu_reset_fifo_17
    208                      return -1;
   \   000001BE   0xF05F 0x30FF      MOVS     R0,#-1
   \   000001C2   0xE032             B.N      ??mpu_reset_fifo_1
    209                  AnBT_DMP_Delay_ms(50);
   \                     ??mpu_reset_fifo_17:
   \   000001C4   0x2032             MOVS     R0,#+50
   \   000001C6   0x.... 0x....      BL       AnBT_DMP_Delay_ms
    210                  if (st.chip_cfg.int_enable)
   \   000001CA   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000001CE   0x7C40             LDRB     R0,[R0, #+17]
   \   000001D0   0x2800             CMP      R0,#+0
   \   000001D2   0xD003             BEQ.N    ??mpu_reset_fifo_18
    211                      data = BIT_DATA_RDY_EN;
   \   000001D4   0x2001             MOVS     R0,#+1
   \   000001D6   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   000001DA   0xE002             B.N      ??mpu_reset_fifo_19
    212                  else
    213                      data = 0;
   \                     ??mpu_reset_fifo_18:
   \   000001DC   0x2000             MOVS     R0,#+0
   \   000001DE   0xF88D 0x0000      STRB     R0,[SP, #+0]
    214                  if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->int_enable, 1, &data))
   \                     ??mpu_reset_fifo_19:
   \   000001E2   0xAB00             ADD      R3,SP,#+0
   \   000001E4   0x2201             MOVS     R2,#+1
   \   000001E6   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000001EA   0x6800             LDR      R0,[R0, #+0]
   \   000001EC   0x7BC1             LDRB     R1,[R0, #+15]
   \   000001EE   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000001F2   0x6840             LDR      R0,[R0, #+4]
   \   000001F4   0x7800             LDRB     R0,[R0, #+0]
   \   000001F6   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   000001FA   0x2800             CMP      R0,#+0
   \   000001FC   0xD002             BEQ.N    ??mpu_reset_fifo_20
    215                      return -1;
   \   000001FE   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000202   0xE012             B.N      ??mpu_reset_fifo_1
    216                  if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->fifo_en, 1, &st.chip_cfg.fifo_enable))
   \                     ??mpu_reset_fifo_20:
   \   00000204   0x.... 0x....      LDR.W    R3,??DataTable20
   \   00000208   0x2201             MOVS     R2,#+1
   \   0000020A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000020E   0x6800             LDR      R0,[R0, #+0]
   \   00000210   0x7941             LDRB     R1,[R0, #+5]
   \   00000212   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000216   0x6840             LDR      R0,[R0, #+4]
   \   00000218   0x7800             LDRB     R0,[R0, #+0]
   \   0000021A   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   0000021E   0x2800             CMP      R0,#+0
   \   00000220   0xD002             BEQ.N    ??mpu_reset_fifo_12
    217                      return -1;
   \   00000222   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000226   0xE000             B.N      ??mpu_reset_fifo_1
    218              }
    219              return 0;
   \                     ??mpu_reset_fifo_12:
   \   00000228   0x2000             MOVS     R0,#+0
   \                     ??mpu_reset_fifo_1:
   \   0000022A   0xBD02             POP      {R1,PC}          ;; return
    220          }

   \                                 In section .text, align 2, keep-with-next
    221          int mpu_configure_fifo(unsigned char sensors)
    222          {
   \                     mpu_configure_fifo:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
    223              unsigned char prev;
    224              int result = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    225          
    226              sensors &= ~INV_XYZ_COMPASS;
   \   00000006   0xF016 0x06FE      ANDS     R6,R6,#0xFE
    227              if (st.chip_cfg.dmp_on)
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000000E   0xF890 0x0024      LDRB     R0,[R0, #+36]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD001             BEQ.N    ??mpu_configure_fifo_0
    228                  return 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE03B             B.N      ??mpu_configure_fifo_1
    229              else {
    230                  if (!(st.chip_cfg.sensors))
   \                     ??mpu_configure_fifo_0:
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000001E   0x7A80             LDRB     R0,[R0, #+10]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD102             BNE.N    ??mpu_configure_fifo_2
    231                      return -1;
   \   00000024   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000028   0xE033             B.N      ??mpu_configure_fifo_1
    232                  prev = st.chip_cfg.fifo_enable;
   \                     ??mpu_configure_fifo_2:
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000002E   0x7C00             LDRB     R0,[R0, #+16]
   \   00000030   0x0004             MOVS     R4,R0
    233                  st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000036   0x7A80             LDRB     R0,[R0, #+10]
   \   00000038   0x4030             ANDS     R0,R0,R6
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000003E   0x7408             STRB     R0,[R1, #+16]
    234                  if (st.chip_cfg.fifo_enable != sensors)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000044   0x7C00             LDRB     R0,[R0, #+16]
   \   00000046   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000048   0x42B0             CMP      R0,R6
   \   0000004A   0xD003             BEQ.N    ??mpu_configure_fifo_3
    235                      result = -1;
   \   0000004C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000050   0x0005             MOVS     R5,R0
   \   00000052   0xE001             B.N      ??mpu_configure_fifo_4
    236                  else
    237                      result = 0;
   \                     ??mpu_configure_fifo_3:
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x0005             MOVS     R5,R0
    238                  if (sensors || st.chip_cfg.lp_accel_mode)
   \                     ??mpu_configure_fifo_4:
   \   00000058   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005A   0x2E00             CMP      R6,#+0
   \   0000005C   0xD104             BNE.N    ??mpu_configure_fifo_5
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000062   0x7D00             LDRB     R0,[R0, #+20]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD003             BEQ.N    ??mpu_configure_fifo_6
    239                      set_int_enable(1);
   \                     ??mpu_configure_fifo_5:
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0x.... 0x....      BL       set_int_enable
   \   0000006E   0xE002             B.N      ??mpu_configure_fifo_7
    240                  else
    241                      set_int_enable(0);
   \                     ??mpu_configure_fifo_6:
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x.... 0x....      BL       set_int_enable
    242                  if (sensors) {
   \                     ??mpu_configure_fifo_7:
   \   00000076   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000078   0x2E00             CMP      R6,#+0
   \   0000007A   0xD009             BEQ.N    ??mpu_configure_fifo_8
    243                      if (mpu_reset_fifo()) {
   \   0000007C   0x.... 0x....      BL       mpu_reset_fifo
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD005             BEQ.N    ??mpu_configure_fifo_8
    244                          st.chip_cfg.fifo_enable = prev;
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000088   0x7404             STRB     R4,[R0, #+16]
    245                          return -1;
   \   0000008A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000008E   0xE000             B.N      ??mpu_configure_fifo_1
    246                      }
    247                  }
    248              }
    249          
    250              return result;
   \                     ??mpu_configure_fifo_8:
   \   00000090   0x0028             MOVS     R0,R5
   \                     ??mpu_configure_fifo_1:
   \   00000092   0xBD70             POP      {R4-R6,PC}       ;; return
    251          }
    252          //

   \                                 In section .text, align 2, keep-with-next
    253          int mpu_lp_accel_mode(unsigned char rate)
    254          {
   \                     mpu_lp_accel_mode:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    255              unsigned char tmp[2];
    256          
    257              if (rate > 40)
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C29             CMP      R4,#+41
   \   0000000A   0xD302             BCC.N    ??mpu_lp_accel_mode_0
    258                  return -1;
   \   0000000C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000010   0xE074             B.N      ??mpu_lp_accel_mode_1
    259          
    260              if (!rate) {
   \                     ??mpu_lp_accel_mode_0:
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD11F             BNE.N    ??mpu_lp_accel_mode_2
    261                  mpu_set_int_latched(0);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      BL       mpu_set_int_latched
    262                  tmp[0] = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF88D 0x0000      STRB     R0,[SP, #+0]
    263                  tmp[1] = BIT_STBY_XYZG;
   \   00000024   0x2007             MOVS     R0,#+7
   \   00000026   0xF88D 0x0001      STRB     R0,[SP, #+1]
    264                  if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
   \   0000002A   0xAB00             ADD      R3,SP,#+0
   \   0000002C   0x2202             MOVS     R2,#+2
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x7C81             LDRB     R1,[R0, #+18]
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000003A   0x6840             LDR      R0,[R0, #+4]
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD002             BEQ.N    ??mpu_lp_accel_mode_3
    265                      return -1;
   \   00000046   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000004A   0xE057             B.N      ??mpu_lp_accel_mode_1
    266                  st.chip_cfg.lp_accel_mode = 0;
   \                     ??mpu_lp_accel_mode_3:
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x7501             STRB     R1,[R0, #+20]
    267                  return 0;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xE051             B.N      ??mpu_lp_accel_mode_1
    268              }
    269              mpu_set_int_latched(1);
   \                     ??mpu_lp_accel_mode_2:
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x.... 0x....      BL       mpu_set_int_latched
    270          
    271              tmp[0] = BIT_LPA_CYCLE;
   \   0000005E   0x2020             MOVS     R0,#+32
   \   00000060   0xF88D 0x0000      STRB     R0,[SP, #+0]
    272              if (rate == 1) {
   \   00000064   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000066   0x2C01             CMP      R4,#+1
   \   00000068   0xD106             BNE.N    ??mpu_lp_accel_mode_4
    273                  tmp[1] = INV_LPA_1_25HZ;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    274                  mpu_set_lpf(5);
   \   00000070   0x2005             MOVS     R0,#+5
   \   00000072   0x.... 0x....      BL       mpu_set_lpf
   \   00000076   0xE019             B.N      ??mpu_lp_accel_mode_5
    275              } else if (rate <= 5) {
   \                     ??mpu_lp_accel_mode_4:
   \   00000078   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007A   0x2C06             CMP      R4,#+6
   \   0000007C   0xD206             BCS.N    ??mpu_lp_accel_mode_6
    276                  tmp[1] = INV_LPA_5HZ;
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xF88D 0x0001      STRB     R0,[SP, #+1]
    277                  mpu_set_lpf(5);
   \   00000084   0x2005             MOVS     R0,#+5
   \   00000086   0x.... 0x....      BL       mpu_set_lpf
   \   0000008A   0xE00F             B.N      ??mpu_lp_accel_mode_5
    278              } else if (rate <= 20) {
   \                     ??mpu_lp_accel_mode_6:
   \   0000008C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008E   0x2C15             CMP      R4,#+21
   \   00000090   0xD206             BCS.N    ??mpu_lp_accel_mode_7
    279                  tmp[1] = INV_LPA_20HZ;
   \   00000092   0x2002             MOVS     R0,#+2
   \   00000094   0xF88D 0x0001      STRB     R0,[SP, #+1]
    280                  mpu_set_lpf(10);
   \   00000098   0x200A             MOVS     R0,#+10
   \   0000009A   0x.... 0x....      BL       mpu_set_lpf
   \   0000009E   0xE005             B.N      ??mpu_lp_accel_mode_5
    281              } else {
    282                  tmp[1] = INV_LPA_40HZ;
   \                     ??mpu_lp_accel_mode_7:
   \   000000A0   0x2003             MOVS     R0,#+3
   \   000000A2   0xF88D 0x0001      STRB     R0,[SP, #+1]
    283                  mpu_set_lpf(20);
   \   000000A6   0x2014             MOVS     R0,#+20
   \   000000A8   0x.... 0x....      BL       mpu_set_lpf
    284              }
    285              tmp[1] = (tmp[1] << 6) | BIT_STBY_XYZG;
   \                     ??mpu_lp_accel_mode_5:
   \   000000AC   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000000B0   0x0180             LSLS     R0,R0,#+6
   \   000000B2   0xF050 0x0007      ORRS     R0,R0,#0x7
   \   000000B6   0xF88D 0x0001      STRB     R0,[SP, #+1]
    286              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
   \   000000BA   0xAB00             ADD      R3,SP,#+0
   \   000000BC   0x2202             MOVS     R2,#+2
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000C2   0x6800             LDR      R0,[R0, #+0]
   \   000000C4   0x7C81             LDRB     R1,[R0, #+18]
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000CA   0x6840             LDR      R0,[R0, #+4]
   \   000000CC   0x7800             LDRB     R0,[R0, #+0]
   \   000000CE   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD002             BEQ.N    ??mpu_lp_accel_mode_8
    287                  return -1;
   \   000000D6   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000DA   0xE00F             B.N      ??mpu_lp_accel_mode_1
    288          
    289              st.chip_cfg.sensors = INV_XYZ_ACCEL;
   \                     ??mpu_lp_accel_mode_8:
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000E0   0x2108             MOVS     R1,#+8
   \   000000E2   0x7281             STRB     R1,[R0, #+10]
    290              st.chip_cfg.clk_src = 0;
   \   000000E4   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000E8   0x2100             MOVS     R1,#+0
   \   000000EA   0x7301             STRB     R1,[R0, #+12]
    291              st.chip_cfg.lp_accel_mode = 1;
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000F0   0x2101             MOVS     R1,#+1
   \   000000F2   0x7501             STRB     R1,[R0, #+20]
    292              mpu_configure_fifo(0);
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0x.... 0x....      BL       mpu_configure_fifo
    293          
    294              return 0;
   \   000000FA   0x2000             MOVS     R0,#+0
   \                     ??mpu_lp_accel_mode_1:
   \   000000FC   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    295          }

   \                                 In section .text, align 2, keep-with-next
    296          int mpu_set_sample_rate(unsigned short rate)
    297          {
   \                     mpu_set_sample_rate:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    298              unsigned char data;
    299          
    300              if (!(st.chip_cfg.sensors))
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000000A   0x7A80             LDRB     R0,[R0, #+10]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD102             BNE.N    ??mpu_set_sample_rate_0
    301                  return -1;
   \   00000010   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000014   0xE055             B.N      ??mpu_set_sample_rate_1
    302          
    303              if (st.chip_cfg.dmp_on)
   \                     ??mpu_set_sample_rate_0:
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000001A   0xF890 0x0024      LDRB     R0,[R0, #+36]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD002             BEQ.N    ??mpu_set_sample_rate_2
    304                  return -1;
   \   00000022   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000026   0xE04C             B.N      ??mpu_set_sample_rate_1
    305              else {
    306                  if (st.chip_cfg.lp_accel_mode) {
   \                     ??mpu_set_sample_rate_2:
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000002C   0x7D00             LDRB     R0,[R0, #+20]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD00E             BEQ.N    ??mpu_set_sample_rate_3
    307                      if (rate && (rate <= 40)) {
   \   00000032   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD008             BEQ.N    ??mpu_set_sample_rate_4
   \   00000038   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000003A   0x2C29             CMP      R4,#+41
   \   0000003C   0xD205             BCS.N    ??mpu_set_sample_rate_4
    308                          /* Just stay in low-power accel mode. */
    309                          mpu_lp_accel_mode(rate);
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0x.... 0x....      BL       mpu_lp_accel_mode
    310                          return 0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xE03B             B.N      ??mpu_set_sample_rate_1
    311                      }
    312                      /* Requested rate exceeds the allowed frequencies in LP accel mode,
    313                       * switch back to full-power mode.
    314                       */
    315                      mpu_lp_accel_mode(0);
   \                     ??mpu_set_sample_rate_4:
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x.... 0x....      BL       mpu_lp_accel_mode
    316                  }
    317                  if (rate < 4)
   \                     ??mpu_set_sample_rate_3:
   \   00000050   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000052   0x2C04             CMP      R4,#+4
   \   00000054   0xD202             BCS.N    ??mpu_set_sample_rate_5
    318                      rate = 4;
   \   00000056   0x2004             MOVS     R0,#+4
   \   00000058   0x0004             MOVS     R4,R0
   \   0000005A   0xE007             B.N      ??mpu_set_sample_rate_6
    319                  else if (rate > 1000)
   \                     ??mpu_set_sample_rate_5:
   \   0000005C   0xF240 0x30E9      MOVW     R0,#+1001
   \   00000060   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000062   0x4284             CMP      R4,R0
   \   00000064   0xD302             BCC.N    ??mpu_set_sample_rate_6
    320                      rate = 1000;
   \   00000066   0xF44F 0x707A      MOV      R0,#+1000
   \   0000006A   0x0004             MOVS     R4,R0
    321          
    322                  data = 1000 / rate - 1;
   \                     ??mpu_set_sample_rate_6:
   \   0000006C   0xF44F 0x707A      MOV      R0,#+1000
   \   00000070   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000072   0xFB90 0xF0F4      SDIV     R0,R0,R4
   \   00000076   0x1E40             SUBS     R0,R0,#+1
   \   00000078   0xF88D 0x0000      STRB     R0,[SP, #+0]
    323                  if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->rate_div, 1, &data))
   \   0000007C   0xAB00             ADD      R3,SP,#+0
   \   0000007E   0x2201             MOVS     R2,#+1
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x7841             LDRB     R1,[R0, #+1]
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000008C   0x6840             LDR      R0,[R0, #+4]
   \   0000008E   0x7800             LDRB     R0,[R0, #+0]
   \   00000090   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD002             BEQ.N    ??mpu_set_sample_rate_7
    324                      return -1;
   \   00000098   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000009C   0xE011             B.N      ??mpu_set_sample_rate_1
    325          
    326                  st.chip_cfg.sample_rate = 1000 / (1 + data);
   \                     ??mpu_set_sample_rate_7:
   \   0000009E   0xF44F 0x707A      MOV      R0,#+1000
   \   000000A2   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000000A6   0x1C49             ADDS     R1,R1,#+1
   \   000000A8   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable16
   \   000000B0   0x81C8             STRH     R0,[R1, #+14]
    327          
    328          
    329                  /* Automatically set LPF to 1/2 sampling rate. */
    330                  mpu_set_lpf(st.chip_cfg.sample_rate >> 1);
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000B6   0x89C0             LDRH     R0,[R0, #+14]
   \   000000B8   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000BA   0x0840             LSRS     R0,R0,#+1
   \   000000BC   0x.... 0x....      BL       mpu_set_lpf
    331                  return 0;
   \   000000C0   0x2000             MOVS     R0,#+0
   \                     ??mpu_set_sample_rate_1:
   \   000000C2   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    332              }
    333          }

   \                                 In section .text, align 2, keep-with-next
    334          int mpu_set_bypass(unsigned char bypass_on)
    335          {
   \                     mpu_set_bypass:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    336              unsigned char tmp;
    337          
    338              if (st.chip_cfg.bypass_mode == bypass_on)
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000000A   0x7C80             LDRB     R0,[R0, #+18]
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x42A0             CMP      R0,R4
   \   00000010   0xD101             BNE.N    ??mpu_set_bypass_0
    339                  return 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE0B6             B.N      ??mpu_set_bypass_1
    340          
    341              if (bypass_on) {
   \                     ??mpu_set_bypass_0:
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD056             BEQ.N    ??mpu_set_bypass_2
    342                  if (AnBT_DMP_I2C_Read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \   0000001C   0xAB00             ADD      R3,SP,#+0
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x7901             LDRB     R1,[R0, #+4]
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000002C   0x6840             LDR      R0,[R0, #+4]
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x.... 0x....      BL       AnBT_DMP_I2C_Read
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD002             BEQ.N    ??mpu_set_bypass_3
    343                      return -1;
   \   00000038   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000003C   0xE0A2             B.N      ??mpu_set_bypass_1
    344                  tmp &= ~BIT_AUX_IF_EN;
   \                     ??mpu_set_bypass_3:
   \   0000003E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000042   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   00000046   0xF88D 0x0000      STRB     R0,[SP, #+0]
    345                  if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \   0000004A   0xAB00             ADD      R3,SP,#+0
   \   0000004C   0x2201             MOVS     R2,#+1
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x7901             LDRB     R1,[R0, #+4]
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000005A   0x6840             LDR      R0,[R0, #+4]
   \   0000005C   0x7800             LDRB     R0,[R0, #+0]
   \   0000005E   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD002             BEQ.N    ??mpu_set_bypass_4
    346                      return -1;
   \   00000066   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000006A   0xE08B             B.N      ??mpu_set_bypass_1
    347                  AnBT_DMP_Delay_ms(3);
   \                     ??mpu_set_bypass_4:
   \   0000006C   0x2003             MOVS     R0,#+3
   \   0000006E   0x.... 0x....      BL       AnBT_DMP_Delay_ms
    348                  tmp = BIT_BYPASS_EN;
   \   00000072   0x2002             MOVS     R0,#+2
   \   00000074   0xF88D 0x0000      STRB     R0,[SP, #+0]
    349                  if (st.chip_cfg.active_low_int)
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000007C   0xF890 0x0022      LDRB     R0,[R0, #+34]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD005             BEQ.N    ??mpu_set_bypass_5
    350                      tmp |= BIT_ACTL;
   \   00000084   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000088   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000008C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    351                  if (st.chip_cfg.latched_int)
   \                     ??mpu_set_bypass_5:
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000094   0xF890 0x0023      LDRB     R0,[R0, #+35]
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD005             BEQ.N    ??mpu_set_bypass_6
    352                      tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
   \   0000009C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000A0   0xF050 0x0030      ORRS     R0,R0,#0x30
   \   000000A4   0xF88D 0x0000      STRB     R0,[SP, #+0]
    353                  if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
   \                     ??mpu_set_bypass_6:
   \   000000A8   0xAB00             ADD      R3,SP,#+0
   \   000000AA   0x2201             MOVS     R2,#+1
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0x7D01             LDRB     R1,[R0, #+20]
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000B8   0x6840             LDR      R0,[R0, #+4]
   \   000000BA   0x7800             LDRB     R0,[R0, #+0]
   \   000000BC   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD05C             BEQ.N    ??mpu_set_bypass_7
    354                      return -1;
   \   000000C4   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000C8   0xE05C             B.N      ??mpu_set_bypass_1
    355              } else {
    356                  /* Enable I2C master mode if compass is being used. */
    357                  if (AnBT_DMP_I2C_Read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \                     ??mpu_set_bypass_2:
   \   000000CA   0xAB00             ADD      R3,SP,#+0
   \   000000CC   0x2201             MOVS     R2,#+1
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000D2   0x6800             LDR      R0,[R0, #+0]
   \   000000D4   0x7901             LDRB     R1,[R0, #+4]
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000DA   0x6840             LDR      R0,[R0, #+4]
   \   000000DC   0x7800             LDRB     R0,[R0, #+0]
   \   000000DE   0x.... 0x....      BL       AnBT_DMP_I2C_Read
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD002             BEQ.N    ??mpu_set_bypass_8
    358                      return -1;
   \   000000E6   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000EA   0xE04B             B.N      ??mpu_set_bypass_1
    359                  if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
   \                     ??mpu_set_bypass_8:
   \   000000EC   0x....             LDR.N    R0,??DataTable16
   \   000000EE   0x7A80             LDRB     R0,[R0, #+10]
   \   000000F0   0x07C0             LSLS     R0,R0,#+31
   \   000000F2   0xD506             BPL.N    ??mpu_set_bypass_9
    360                      tmp |= BIT_AUX_IF_EN;
   \   000000F4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000F8   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000FC   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000100   0xE005             B.N      ??mpu_set_bypass_10
    361                  else
    362                      tmp &= ~BIT_AUX_IF_EN;
   \                     ??mpu_set_bypass_9:
   \   00000102   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000106   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   0000010A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    363                  if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \                     ??mpu_set_bypass_10:
   \   0000010E   0xAB00             ADD      R3,SP,#+0
   \   00000110   0x2201             MOVS     R2,#+1
   \   00000112   0x....             LDR.N    R0,??DataTable16
   \   00000114   0x6800             LDR      R0,[R0, #+0]
   \   00000116   0x7901             LDRB     R1,[R0, #+4]
   \   00000118   0x....             LDR.N    R0,??DataTable16
   \   0000011A   0x6840             LDR      R0,[R0, #+4]
   \   0000011C   0x7800             LDRB     R0,[R0, #+0]
   \   0000011E   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000122   0x2800             CMP      R0,#+0
   \   00000124   0xD002             BEQ.N    ??mpu_set_bypass_11
    364                      return -1;
   \   00000126   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000012A   0xE02B             B.N      ??mpu_set_bypass_1
    365                  AnBT_DMP_Delay_ms(3);
   \                     ??mpu_set_bypass_11:
   \   0000012C   0x2003             MOVS     R0,#+3
   \   0000012E   0x.... 0x....      BL       AnBT_DMP_Delay_ms
    366                  if (st.chip_cfg.active_low_int)
   \   00000132   0x....             LDR.N    R0,??DataTable16
   \   00000134   0xF890 0x0022      LDRB     R0,[R0, #+34]
   \   00000138   0x2800             CMP      R0,#+0
   \   0000013A   0xD003             BEQ.N    ??mpu_set_bypass_12
    367                      tmp = BIT_ACTL;
   \   0000013C   0x2080             MOVS     R0,#+128
   \   0000013E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000142   0xE002             B.N      ??mpu_set_bypass_13
    368                  else
    369                      tmp = 0;
   \                     ??mpu_set_bypass_12:
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0xF88D 0x0000      STRB     R0,[SP, #+0]
    370                  if (st.chip_cfg.latched_int)
   \                     ??mpu_set_bypass_13:
   \   0000014A   0x....             LDR.N    R0,??DataTable16
   \   0000014C   0xF890 0x0023      LDRB     R0,[R0, #+35]
   \   00000150   0x2800             CMP      R0,#+0
   \   00000152   0xD005             BEQ.N    ??mpu_set_bypass_14
    371                      tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
   \   00000154   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000158   0xF050 0x0030      ORRS     R0,R0,#0x30
   \   0000015C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    372                  if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
   \                     ??mpu_set_bypass_14:
   \   00000160   0xAB00             ADD      R3,SP,#+0
   \   00000162   0x2201             MOVS     R2,#+1
   \   00000164   0x....             LDR.N    R0,??DataTable16
   \   00000166   0x6800             LDR      R0,[R0, #+0]
   \   00000168   0x7D01             LDRB     R1,[R0, #+20]
   \   0000016A   0x....             LDR.N    R0,??DataTable16
   \   0000016C   0x6840             LDR      R0,[R0, #+4]
   \   0000016E   0x7800             LDRB     R0,[R0, #+0]
   \   00000170   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000174   0x2800             CMP      R0,#+0
   \   00000176   0xD002             BEQ.N    ??mpu_set_bypass_7
    373                      return -1;
   \   00000178   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000017C   0xE002             B.N      ??mpu_set_bypass_1
    374              }
    375              st.chip_cfg.bypass_mode = bypass_on;
   \                     ??mpu_set_bypass_7:
   \   0000017E   0x....             LDR.N    R0,??DataTable16
   \   00000180   0x7484             STRB     R4,[R0, #+18]
    376              return 0;
   \   00000182   0x2000             MOVS     R0,#+0
   \                     ??mpu_set_bypass_1:
   \   00000184   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    377          }

   \                                 In section .text, align 2, keep-with-next
    378          int mpu_set_sensors(unsigned char sensors)
    379          {
   \                     mpu_set_sensors:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    380              unsigned char data;
    381          
    382              if (sensors & INV_XYZ_GYRO)
   \   00000006   0x2070             MOVS     R0,#+112
   \   00000008   0x4204             TST      R4,R0
   \   0000000A   0xD003             BEQ.N    ??mpu_set_sensors_0
    383                  data = INV_CLK_PLL;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000012   0xE009             B.N      ??mpu_set_sensors_1
    384              else if (sensors)
   \                     ??mpu_set_sensors_0:
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD003             BEQ.N    ??mpu_set_sensors_2
    385                  data = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000020   0xE002             B.N      ??mpu_set_sensors_1
    386              else
    387                  data = BIT_SLEEP;
   \                     ??mpu_set_sensors_2:
   \   00000022   0x2040             MOVS     R0,#+64
   \   00000024   0xF88D 0x0000      STRB     R0,[SP, #+0]
    388              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
   \                     ??mpu_set_sensors_1:
   \   00000028   0xAB00             ADD      R3,SP,#+0
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0x....             LDR.N    R0,??DataTable16
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x7C81             LDRB     R1,[R0, #+18]
   \   00000032   0x....             LDR.N    R0,??DataTable16
   \   00000034   0x6840             LDR      R0,[R0, #+4]
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD005             BEQ.N    ??mpu_set_sensors_3
    389                  st.chip_cfg.sensors = 0;
   \   00000040   0x....             LDR.N    R0,??DataTable16
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x7281             STRB     R1,[R0, #+10]
    390                  return -1;
   \   00000046   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000004A   0xE04C             B.N      ??mpu_set_sensors_4
    391              }
    392              st.chip_cfg.clk_src = data & ~BIT_SLEEP;
   \                     ??mpu_set_sensors_3:
   \   0000004C   0x....             LDR.N    R0,??DataTable16
   \   0000004E   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000052   0xF011 0x01BF      ANDS     R1,R1,#0xBF
   \   00000056   0x7301             STRB     R1,[R0, #+12]
    393          
    394              data = 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    395              if (!(sensors & INV_X_GYRO))
   \   0000005E   0x0660             LSLS     R0,R4,#+25
   \   00000060   0xD405             BMI.N    ??mpu_set_sensors_5
    396                  data |= BIT_STBY_XG;
   \   00000062   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000066   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000006A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    397              if (!(sensors & INV_Y_GYRO))
   \                     ??mpu_set_sensors_5:
   \   0000006E   0x06A0             LSLS     R0,R4,#+26
   \   00000070   0xD405             BMI.N    ??mpu_set_sensors_6
    398                  data |= BIT_STBY_YG;
   \   00000072   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000076   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000007A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    399              if (!(sensors & INV_Z_GYRO))
   \                     ??mpu_set_sensors_6:
   \   0000007E   0x06E0             LSLS     R0,R4,#+27
   \   00000080   0xD405             BMI.N    ??mpu_set_sensors_7
    400                  data |= BIT_STBY_ZG;
   \   00000082   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000086   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000008A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    401              if (!(sensors & INV_XYZ_ACCEL))
   \                     ??mpu_set_sensors_7:
   \   0000008E   0x0720             LSLS     R0,R4,#+28
   \   00000090   0xD405             BMI.N    ??mpu_set_sensors_8
    402                  data |= BIT_STBY_XYZA;
   \   00000092   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000096   0xF050 0x0038      ORRS     R0,R0,#0x38
   \   0000009A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    403              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
   \                     ??mpu_set_sensors_8:
   \   0000009E   0xAB00             ADD      R3,SP,#+0
   \   000000A0   0x2201             MOVS     R2,#+1
   \   000000A2   0x....             LDR.N    R0,??DataTable16
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0x7CC1             LDRB     R1,[R0, #+19]
   \   000000A8   0x....             LDR.N    R0,??DataTable16
   \   000000AA   0x6840             LDR      R0,[R0, #+4]
   \   000000AC   0x7800             LDRB     R0,[R0, #+0]
   \   000000AE   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD005             BEQ.N    ??mpu_set_sensors_9
    404                  st.chip_cfg.sensors = 0;
   \   000000B6   0x....             LDR.N    R0,??DataTable16
   \   000000B8   0x2100             MOVS     R1,#+0
   \   000000BA   0x7281             STRB     R1,[R0, #+10]
    405                  return -1;
   \   000000BC   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000C0   0xE011             B.N      ??mpu_set_sensors_4
    406              }
    407          
    408              if (sensors && (sensors != INV_XYZ_ACCEL))
   \                     ??mpu_set_sensors_9:
   \   000000C2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C4   0x2C00             CMP      R4,#+0
   \   000000C6   0xD005             BEQ.N    ??mpu_set_sensors_10
   \   000000C8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CA   0x2C08             CMP      R4,#+8
   \   000000CC   0xD002             BEQ.N    ??mpu_set_sensors_10
    409                  /* Latched interrupts only used in LP accel mode. */
    410                  mpu_set_int_latched(0);
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x.... 0x....      BL       mpu_set_int_latched
    411          
    412          
    413              st.chip_cfg.sensors = sensors;
   \                     ??mpu_set_sensors_10:
   \   000000D4   0x....             LDR.N    R0,??DataTable16
   \   000000D6   0x7284             STRB     R4,[R0, #+10]
    414              st.chip_cfg.lp_accel_mode = 0;
   \   000000D8   0x....             LDR.N    R0,??DataTable16
   \   000000DA   0x2100             MOVS     R1,#+0
   \   000000DC   0x7501             STRB     R1,[R0, #+20]
    415              AnBT_DMP_Delay_ms(50);
   \   000000DE   0x2032             MOVS     R0,#+50
   \   000000E0   0x.... 0x....      BL       AnBT_DMP_Delay_ms
    416              return 0;
   \   000000E4   0x2000             MOVS     R0,#+0
   \                     ??mpu_set_sensors_4:
   \   000000E6   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    417          }
    418          //

   \                                 In section .text, align 2, keep-with-next
    419          int mpu_set_dmp_state(unsigned char enable)
    420          {
   \                     mpu_set_dmp_state:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    421              unsigned char tmp;
    422              if (st.chip_cfg.dmp_on == enable)
   \   00000006   0x....             LDR.N    R0,??DataTable16
   \   00000008   0xF890 0x0024      LDRB     R0,[R0, #+36]
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x42A0             CMP      R0,R4
   \   00000010   0xD101             BNE.N    ??mpu_set_dmp_state_0
    423                  return 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE03F             B.N      ??mpu_set_dmp_state_1
    424          
    425              if (enable) {
   \                     ??mpu_set_dmp_state_0:
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD026             BEQ.N    ??mpu_set_dmp_state_2
    426                  if (!st.chip_cfg.dmp_loaded)
   \   0000001C   0x....             LDR.N    R0,??DataTable16
   \   0000001E   0xF890 0x0025      LDRB     R0,[R0, #+37]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD102             BNE.N    ??mpu_set_dmp_state_3
    427                      return -1;
   \   00000026   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000002A   0xE034             B.N      ??mpu_set_dmp_state_1
    428                  /* Disable data ready interrupt. */
    429                  set_int_enable(0);
   \                     ??mpu_set_dmp_state_3:
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x.... 0x....      BL       set_int_enable
    430                  /* Disable bypass mode. */
    431                  mpu_set_bypass(0);
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      BL       mpu_set_bypass
    432                  /* Keep constant sample rate, FIFO rate controlled by DMP. */
    433                  mpu_set_sample_rate(st.chip_cfg.dmp_sample_rate);
   \   00000038   0x....             LDR.N    R0,??DataTable16
   \   0000003A   0x8CC0             LDRH     R0,[R0, #+38]
   \   0000003C   0x.... 0x....      BL       mpu_set_sample_rate
    434                  /* Remove FIFO elements. */
    435                  tmp = 0;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF88D 0x0000      STRB     R0,[SP, #+0]
    436                  AnBT_DMP_I2C_Write(st.hw->addr, 0x23, 1, &tmp);
   \   00000046   0xAB00             ADD      R3,SP,#+0
   \   00000048   0x2201             MOVS     R2,#+1
   \   0000004A   0x2123             MOVS     R1,#+35
   \   0000004C   0x....             LDR.N    R0,??DataTable16
   \   0000004E   0x6840             LDR      R0,[R0, #+4]
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0x.... 0x....      BL       AnBT_DMP_I2C_Write
    437                  st.chip_cfg.dmp_on = 1;
   \   00000056   0x....             LDR.N    R0,??DataTable16
   \   00000058   0x2101             MOVS     R1,#+1
   \   0000005A   0xF880 0x1024      STRB     R1,[R0, #+36]
    438                  /* Enable DMP interrupt. */
    439                  set_int_enable(1);
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0x.... 0x....      BL       set_int_enable
    440                  mpu_reset_fifo();
   \   00000064   0x.... 0x....      BL       mpu_reset_fifo
   \   00000068   0xE014             B.N      ??mpu_set_dmp_state_4
    441              } else {
    442                  /* Disable DMP interrupt. */
    443                  set_int_enable(0);
   \                     ??mpu_set_dmp_state_2:
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x.... 0x....      BL       set_int_enable
    444                  /* Restore FIFO settings. */
    445                  tmp = st.chip_cfg.fifo_enable;
   \   00000070   0x....             LDR.N    R0,??DataTable16
   \   00000072   0x7C00             LDRB     R0,[R0, #+16]
   \   00000074   0xF88D 0x0000      STRB     R0,[SP, #+0]
    446                  AnBT_DMP_I2C_Write(st.hw->addr, 0x23, 1, &tmp);
   \   00000078   0xAB00             ADD      R3,SP,#+0
   \   0000007A   0x2201             MOVS     R2,#+1
   \   0000007C   0x2123             MOVS     R1,#+35
   \   0000007E   0x....             LDR.N    R0,??DataTable16
   \   00000080   0x6840             LDR      R0,[R0, #+4]
   \   00000082   0x7800             LDRB     R0,[R0, #+0]
   \   00000084   0x.... 0x....      BL       AnBT_DMP_I2C_Write
    447                  st.chip_cfg.dmp_on = 0;
   \   00000088   0x....             LDR.N    R0,??DataTable16
   \   0000008A   0x2100             MOVS     R1,#+0
   \   0000008C   0xF880 0x1024      STRB     R1,[R0, #+36]
    448                  mpu_reset_fifo();
   \   00000090   0x.... 0x....      BL       mpu_reset_fifo
    449              }
    450              return 0;
   \                     ??mpu_set_dmp_state_4:
   \   00000094   0x2000             MOVS     R0,#+0
   \                     ??mpu_set_dmp_state_1:
   \   00000096   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    451          }
    452          //

   \                                 In section .text, align 2, keep-with-next
    453          int mpu_get_gyro_fsr(unsigned short *fsr)
    454          {
   \                     mpu_get_gyro_fsr:
   \   00000000   0x0001             MOVS     R1,R0
    455              switch (st.chip_cfg.gyro_fsr) {
   \   00000002   0x....             LDR.N    R0,??DataTable16
   \   00000004   0x7A00             LDRB     R0,[R0, #+8]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD005             BEQ.N    ??mpu_get_gyro_fsr_0
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD00A             BEQ.N    ??mpu_get_gyro_fsr_1
   \   0000000E   0xD305             BCC.N    ??mpu_get_gyro_fsr_2
   \   00000010   0x2803             CMP      R0,#+3
   \   00000012   0xD00B             BEQ.N    ??mpu_get_gyro_fsr_3
   \   00000014   0xE00E             B.N      ??mpu_get_gyro_fsr_4
    456              case INV_FSR_250DPS:
    457                  fsr[0] = 250;
   \                     ??mpu_get_gyro_fsr_0:
   \   00000016   0x20FA             MOVS     R0,#+250
   \   00000018   0x8008             STRH     R0,[R1, #+0]
    458                  break;
   \   0000001A   0xE00D             B.N      ??mpu_get_gyro_fsr_5
    459              case INV_FSR_500DPS:
    460                  fsr[0] = 500;
   \                     ??mpu_get_gyro_fsr_2:
   \   0000001C   0xF44F 0x70FA      MOV      R0,#+500
   \   00000020   0x8008             STRH     R0,[R1, #+0]
    461                  break;
   \   00000022   0xE009             B.N      ??mpu_get_gyro_fsr_5
    462              case INV_FSR_1000DPS:
    463                  fsr[0] = 1000;
   \                     ??mpu_get_gyro_fsr_1:
   \   00000024   0xF44F 0x707A      MOV      R0,#+1000
   \   00000028   0x8008             STRH     R0,[R1, #+0]
    464                  break;
   \   0000002A   0xE005             B.N      ??mpu_get_gyro_fsr_5
    465              case INV_FSR_2000DPS:
    466                  fsr[0] = 2000;
   \                     ??mpu_get_gyro_fsr_3:
   \   0000002C   0xF44F 0x60FA      MOV      R0,#+2000
   \   00000030   0x8008             STRH     R0,[R1, #+0]
    467                  break;
   \   00000032   0xE001             B.N      ??mpu_get_gyro_fsr_5
    468              default:
    469                  fsr[0] = 0;
   \                     ??mpu_get_gyro_fsr_4:
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x8008             STRH     R0,[R1, #+0]
    470                  break;
    471              }
    472              return 0;
   \                     ??mpu_get_gyro_fsr_5:
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x4770             BX       LR               ;; return
    473          }

   \                                 In section .text, align 2, keep-with-next
    474          int mpu_get_accel_fsr(unsigned char *fsr)
    475          {
   \                     mpu_get_accel_fsr:
   \   00000000   0x0001             MOVS     R1,R0
    476              switch (st.chip_cfg.accel_fsr) {
   \   00000002   0x....             LDR.N    R0,??DataTable16
   \   00000004   0x7A40             LDRB     R0,[R0, #+9]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD005             BEQ.N    ??mpu_get_accel_fsr_0
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD009             BEQ.N    ??mpu_get_accel_fsr_1
   \   0000000E   0xD305             BCC.N    ??mpu_get_accel_fsr_2
   \   00000010   0x2803             CMP      R0,#+3
   \   00000012   0xD009             BEQ.N    ??mpu_get_accel_fsr_3
   \   00000014   0xE00B             B.N      ??mpu_get_accel_fsr_4
    477              case INV_FSR_2G:
    478                  fsr[0] = 2;
   \                     ??mpu_get_accel_fsr_0:
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    479                  break;
   \   0000001A   0xE00B             B.N      ??mpu_get_accel_fsr_5
    480              case INV_FSR_4G:
    481                  fsr[0] = 4;
   \                     ??mpu_get_accel_fsr_2:
   \   0000001C   0x2004             MOVS     R0,#+4
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
    482                  break;
   \   00000020   0xE008             B.N      ??mpu_get_accel_fsr_5
    483              case INV_FSR_8G:
    484                  fsr[0] = 8;
   \                     ??mpu_get_accel_fsr_1:
   \   00000022   0x2008             MOVS     R0,#+8
   \   00000024   0x7008             STRB     R0,[R1, #+0]
    485                  break;
   \   00000026   0xE005             B.N      ??mpu_get_accel_fsr_5
    486              case INV_FSR_16G:
    487                  fsr[0] = 16;
   \                     ??mpu_get_accel_fsr_3:
   \   00000028   0x2010             MOVS     R0,#+16
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
    488                  break;
   \   0000002C   0xE002             B.N      ??mpu_get_accel_fsr_5
    489              default:
    490                  return -1;
   \                     ??mpu_get_accel_fsr_4:
   \   0000002E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000032   0xE007             B.N      ??mpu_get_accel_fsr_6
    491              }
    492              if (st.chip_cfg.accel_half)
   \                     ??mpu_get_accel_fsr_5:
   \   00000034   0x....             LDR.N    R0,??DataTable16
   \   00000036   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD002             BEQ.N    ??mpu_get_accel_fsr_7
    493                  fsr[0] <<= 1;
   \   0000003C   0x7808             LDRB     R0,[R1, #+0]
   \   0000003E   0x0040             LSLS     R0,R0,#+1
   \   00000040   0x7008             STRB     R0,[R1, #+0]
    494              return 0;
   \                     ??mpu_get_accel_fsr_7:
   \   00000042   0x2000             MOVS     R0,#+0
   \                     ??mpu_get_accel_fsr_6:
   \   00000044   0x4770             BX       LR               ;; return
    495          }

   \                                 In section .text, align 2, keep-with-next
    496          int mpu_get_lpf(unsigned short *lpf)
    497          {
   \                     mpu_get_lpf:
   \   00000000   0x0001             MOVS     R1,R0
    498              switch (st.chip_cfg.lpf) {
   \   00000002   0x....             LDR.N    R0,??DataTable16
   \   00000004   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD009             BEQ.N    ??mpu_get_lpf_0
   \   0000000A   0xD31A             BCC.N    ??mpu_get_lpf_1
   \   0000000C   0x2803             CMP      R0,#+3
   \   0000000E   0xD00C             BEQ.N    ??mpu_get_lpf_2
   \   00000010   0xD308             BCC.N    ??mpu_get_lpf_3
   \   00000012   0x2805             CMP      R0,#+5
   \   00000014   0xD00F             BEQ.N    ??mpu_get_lpf_4
   \   00000016   0xD30B             BCC.N    ??mpu_get_lpf_5
   \   00000018   0x2806             CMP      R0,#+6
   \   0000001A   0xD00F             BEQ.N    ??mpu_get_lpf_6
   \   0000001C   0xE011             B.N      ??mpu_get_lpf_1
    499              case INV_FILTER_188HZ:
    500                  lpf[0] = 188;
   \                     ??mpu_get_lpf_0:
   \   0000001E   0x20BC             MOVS     R0,#+188
   \   00000020   0x8008             STRH     R0,[R1, #+0]
    501                  break;
   \   00000022   0xE010             B.N      ??mpu_get_lpf_7
    502              case INV_FILTER_98HZ:
    503                  lpf[0] = 98;
   \                     ??mpu_get_lpf_3:
   \   00000024   0x2062             MOVS     R0,#+98
   \   00000026   0x8008             STRH     R0,[R1, #+0]
    504                  break;
   \   00000028   0xE00D             B.N      ??mpu_get_lpf_7
    505              case INV_FILTER_42HZ:
    506                  lpf[0] = 42;
   \                     ??mpu_get_lpf_2:
   \   0000002A   0x202A             MOVS     R0,#+42
   \   0000002C   0x8008             STRH     R0,[R1, #+0]
    507                  break;
   \   0000002E   0xE00A             B.N      ??mpu_get_lpf_7
    508              case INV_FILTER_20HZ:
    509                  lpf[0] = 20;
   \                     ??mpu_get_lpf_5:
   \   00000030   0x2014             MOVS     R0,#+20
   \   00000032   0x8008             STRH     R0,[R1, #+0]
    510                  break;
   \   00000034   0xE007             B.N      ??mpu_get_lpf_7
    511              case INV_FILTER_10HZ:
    512                  lpf[0] = 10;
   \                     ??mpu_get_lpf_4:
   \   00000036   0x200A             MOVS     R0,#+10
   \   00000038   0x8008             STRH     R0,[R1, #+0]
    513                  break;
   \   0000003A   0xE004             B.N      ??mpu_get_lpf_7
    514              case INV_FILTER_5HZ:
    515                  lpf[0] = 5;
   \                     ??mpu_get_lpf_6:
   \   0000003C   0x2005             MOVS     R0,#+5
   \   0000003E   0x8008             STRH     R0,[R1, #+0]
    516                  break;
   \   00000040   0xE001             B.N      ??mpu_get_lpf_7
    517              case INV_FILTER_256HZ_NOLPF2:
    518              case INV_FILTER_2100HZ_NOLPF:
    519              default:
    520                  lpf[0] = 0;
   \                     ??mpu_get_lpf_1:
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x8008             STRH     R0,[R1, #+0]
    521                  break;
    522              }
    523              return 0;
   \                     ??mpu_get_lpf_7:
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x4770             BX       LR               ;; return
    524          }

   \                                 In section .text, align 2, keep-with-next
    525          int mpu_get_sample_rate(unsigned short *rate)
    526          {
   \                     mpu_get_sample_rate:
   \   00000000   0x0001             MOVS     R1,R0
    527              if (st.chip_cfg.dmp_on)
   \   00000002   0x....             LDR.N    R0,??DataTable16
   \   00000004   0xF890 0x0024      LDRB     R0,[R0, #+36]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??mpu_get_sample_rate_0
    528                  return -1;
   \   0000000C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000010   0xE003             B.N      ??mpu_get_sample_rate_1
    529              else
    530                  rate[0] = st.chip_cfg.sample_rate;
   \                     ??mpu_get_sample_rate_0:
   \   00000012   0x....             LDR.N    R0,??DataTable16
   \   00000014   0x89C0             LDRH     R0,[R0, #+14]
   \   00000016   0x8008             STRH     R0,[R1, #+0]
    531              return 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \                     ??mpu_get_sample_rate_1:
   \   0000001A   0x4770             BX       LR               ;; return
    532          }

   \                                 In section .text, align 2, keep-with-next
    533          int mpu_get_fifo_config(unsigned char *sensors)
    534          {
   \                     mpu_get_fifo_config:
   \   00000000   0x0001             MOVS     R1,R0
    535              sensors[0] = st.chip_cfg.fifo_enable;
   \   00000002   0x....             LDR.N    R0,??DataTable16
   \   00000004   0x7C00             LDRB     R0,[R0, #+16]
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    536              return 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4770             BX       LR               ;; return
    537          }

   \                                 In section .text, align 2, keep-with-next
    538          static int get_st_biases(long *gyro, long *accel, unsigned char hw_test)
    539          {
   \                     get_st_biases:
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x0005             MOVS     R5,R0
   \   00000008   0x000E             MOVS     R6,R1
   \   0000000A   0x4690             MOV      R8,R2
    540              unsigned char data[MAX_PACKET_LENGTH];
    541              unsigned char packet_count, ii;
    542              unsigned short fifo_count;
    543          
    544              data[0] = 0x01;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    545              data[1] = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF88D 0x0001      STRB     R0,[SP, #+1]
    546              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
   \   00000018   0xAB00             ADD      R3,SP,#+0
   \   0000001A   0x2202             MOVS     R2,#+2
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x7C81             LDRB     R1,[R0, #+18]
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD002             BEQ.N    ??get_st_biases_0
    547                  return -1;
   \   00000034   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000038   0xE23F             B.N      ??get_st_biases_1
    548              AnBT_DMP_Delay_ms(200);
   \                     ??get_st_biases_0:
   \   0000003A   0x20C8             MOVS     R0,#+200
   \   0000003C   0x.... 0x....      BL       AnBT_DMP_Delay_ms
    549              data[0] = 0;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF88D 0x0000      STRB     R0,[SP, #+0]
    550              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->int_enable, 1, data))
   \   00000046   0xAB00             ADD      R3,SP,#+0
   \   00000048   0x2201             MOVS     R2,#+1
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable27
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x7BC1             LDRB     R1,[R0, #+15]
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000056   0x6840             LDR      R0,[R0, #+4]
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD002             BEQ.N    ??get_st_biases_2
    551                  return -1;
   \   00000062   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000066   0xE228             B.N      ??get_st_biases_1
    552              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->fifo_en, 1, data))
   \                     ??get_st_biases_2:
   \   00000068   0xAB00             ADD      R3,SP,#+0
   \   0000006A   0x2201             MOVS     R2,#+1
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x7941             LDRB     R1,[R0, #+5]
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000078   0x6840             LDR      R0,[R0, #+4]
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
   \   0000007C   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD002             BEQ.N    ??get_st_biases_3
    553                  return -1;
   \   00000084   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000088   0xE217             B.N      ??get_st_biases_1
    554              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
   \                     ??get_st_biases_3:
   \   0000008A   0xAB00             ADD      R3,SP,#+0
   \   0000008C   0x2201             MOVS     R2,#+1
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000092   0x6800             LDR      R0,[R0, #+0]
   \   00000094   0x7C81             LDRB     R1,[R0, #+18]
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable27
   \   0000009A   0x6840             LDR      R0,[R0, #+4]
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD002             BEQ.N    ??get_st_biases_4
    555                  return -1;
   \   000000A6   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000AA   0xE206             B.N      ??get_st_biases_1
    556              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->i2c_mst, 1, data))
   \                     ??get_st_biases_4:
   \   000000AC   0xAB00             ADD      R3,SP,#+0
   \   000000AE   0x2201             MOVS     R2,#+1
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0x7DC1             LDRB     R1,[R0, #+23]
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000000BC   0x6840             LDR      R0,[R0, #+4]
   \   000000BE   0x7800             LDRB     R0,[R0, #+0]
   \   000000C0   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD002             BEQ.N    ??get_st_biases_5
    557                  return -1;
   \   000000C8   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000CC   0xE1F5             B.N      ??get_st_biases_1
    558              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->user_ctrl, 1, data))
   \                     ??get_st_biases_5:
   \   000000CE   0xAB00             ADD      R3,SP,#+0
   \   000000D0   0x2201             MOVS     R2,#+1
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \   000000D8   0x7901             LDRB     R1,[R0, #+4]
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000000DE   0x6840             LDR      R0,[R0, #+4]
   \   000000E0   0x7800             LDRB     R0,[R0, #+0]
   \   000000E2   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD002             BEQ.N    ??get_st_biases_6
    559                  return -1;
   \   000000EA   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000EE   0xE1E4             B.N      ??get_st_biases_1
    560              data[0] = BIT_FIFO_RST | BIT_DMP_RST;
   \                     ??get_st_biases_6:
   \   000000F0   0x200C             MOVS     R0,#+12
   \   000000F2   0xF88D 0x0000      STRB     R0,[SP, #+0]
    561              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->user_ctrl, 1, data))
   \   000000F6   0xAB00             ADD      R3,SP,#+0
   \   000000F8   0x2201             MOVS     R2,#+1
   \   000000FA   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000000FE   0x6800             LDR      R0,[R0, #+0]
   \   00000100   0x7901             LDRB     R1,[R0, #+4]
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000106   0x6840             LDR      R0,[R0, #+4]
   \   00000108   0x7800             LDRB     R0,[R0, #+0]
   \   0000010A   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD002             BEQ.N    ??get_st_biases_7
    562                  return -1;
   \   00000112   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000116   0xE1D0             B.N      ??get_st_biases_1
    563              AnBT_DMP_Delay_ms(15);
   \                     ??get_st_biases_7:
   \   00000118   0x200F             MOVS     R0,#+15
   \   0000011A   0x.... 0x....      BL       AnBT_DMP_Delay_ms
    564              data[0] = st.test->reg_lpf;
   \   0000011E   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000122   0x6A80             LDR      R0,[R0, #+40]
   \   00000124   0x7A40             LDRB     R0,[R0, #+9]
   \   00000126   0xF88D 0x0000      STRB     R0,[SP, #+0]
    565              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->lpf, 1, data))
   \   0000012A   0xAB00             ADD      R3,SP,#+0
   \   0000012C   0x2201             MOVS     R2,#+1
   \   0000012E   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000132   0x6800             LDR      R0,[R0, #+0]
   \   00000134   0x7881             LDRB     R1,[R0, #+2]
   \   00000136   0x.... 0x....      LDR.W    R0,??DataTable27
   \   0000013A   0x6840             LDR      R0,[R0, #+4]
   \   0000013C   0x7800             LDRB     R0,[R0, #+0]
   \   0000013E   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000142   0x2800             CMP      R0,#+0
   \   00000144   0xD002             BEQ.N    ??get_st_biases_8
    566                  return -1;
   \   00000146   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000014A   0xE1B6             B.N      ??get_st_biases_1
    567              data[0] = st.test->reg_rate_div;
   \                     ??get_st_biases_8:
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000150   0x6A80             LDR      R0,[R0, #+40]
   \   00000152   0x7A00             LDRB     R0,[R0, #+8]
   \   00000154   0xF88D 0x0000      STRB     R0,[SP, #+0]
    568              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->rate_div, 1, data))
   \   00000158   0xAB00             ADD      R3,SP,#+0
   \   0000015A   0x2201             MOVS     R2,#+1
   \   0000015C   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000160   0x6800             LDR      R0,[R0, #+0]
   \   00000162   0x7841             LDRB     R1,[R0, #+1]
   \   00000164   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000168   0x6840             LDR      R0,[R0, #+4]
   \   0000016A   0x7800             LDRB     R0,[R0, #+0]
   \   0000016C   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000170   0x2800             CMP      R0,#+0
   \   00000172   0xD002             BEQ.N    ??get_st_biases_9
    569                  return -1;
   \   00000174   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000178   0xE19F             B.N      ??get_st_biases_1
    570              if (hw_test)
   \                     ??get_st_biases_9:
   \   0000017A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000017E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000182   0xD008             BEQ.N    ??get_st_biases_10
    571                  data[0] = st.test->reg_gyro_fsr | 0xE0;
   \   00000184   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000188   0x6A80             LDR      R0,[R0, #+40]
   \   0000018A   0x7A80             LDRB     R0,[R0, #+10]
   \   0000018C   0xF050 0x00E0      ORRS     R0,R0,#0xE0
   \   00000190   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000194   0xE005             B.N      ??get_st_biases_11
    572              else
    573                  data[0] = st.test->reg_gyro_fsr;
   \                     ??get_st_biases_10:
   \   00000196   0x.... 0x....      LDR.W    R0,??DataTable27
   \   0000019A   0x6A80             LDR      R0,[R0, #+40]
   \   0000019C   0x7A80             LDRB     R0,[R0, #+10]
   \   0000019E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    574              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->gyro_cfg, 1, data))
   \                     ??get_st_biases_11:
   \   000001A2   0xAB00             ADD      R3,SP,#+0
   \   000001A4   0x2201             MOVS     R2,#+1
   \   000001A6   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000001AA   0x6800             LDR      R0,[R0, #+0]
   \   000001AC   0x7981             LDRB     R1,[R0, #+6]
   \   000001AE   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000001B2   0x6840             LDR      R0,[R0, #+4]
   \   000001B4   0x7800             LDRB     R0,[R0, #+0]
   \   000001B6   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   000001BA   0x2800             CMP      R0,#+0
   \   000001BC   0xD002             BEQ.N    ??get_st_biases_12
    575                  return -1;
   \   000001BE   0xF05F 0x30FF      MOVS     R0,#-1
   \   000001C2   0xE17A             B.N      ??get_st_biases_1
    576          
    577              if (hw_test)
   \                     ??get_st_biases_12:
   \   000001C4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001C8   0xF1B8 0x0F00      CMP      R8,#+0
   \   000001CC   0xD008             BEQ.N    ??get_st_biases_13
    578                  data[0] = st.test->reg_accel_fsr | 0xE0;
   \   000001CE   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000001D2   0x6A80             LDR      R0,[R0, #+40]
   \   000001D4   0x7AC0             LDRB     R0,[R0, #+11]
   \   000001D6   0xF050 0x00E0      ORRS     R0,R0,#0xE0
   \   000001DA   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   000001DE   0xE004             B.N      ??get_st_biases_14
    579              else
    580                  data[0] = test.reg_accel_fsr;
   \                     ??get_st_biases_13:
   \   000001E0   0x.... 0x....      LDR.W    R0,??DataTable28
   \   000001E4   0x7AC0             LDRB     R0,[R0, #+11]
   \   000001E6   0xF88D 0x0000      STRB     R0,[SP, #+0]
    581              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->accel_cfg, 1, data))
   \                     ??get_st_biases_14:
   \   000001EA   0xAB00             ADD      R3,SP,#+0
   \   000001EC   0x2201             MOVS     R2,#+1
   \   000001EE   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000001F2   0x6800             LDR      R0,[R0, #+0]
   \   000001F4   0x79C1             LDRB     R1,[R0, #+7]
   \   000001F6   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000001FA   0x6840             LDR      R0,[R0, #+4]
   \   000001FC   0x7800             LDRB     R0,[R0, #+0]
   \   000001FE   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000202   0x2800             CMP      R0,#+0
   \   00000204   0xD002             BEQ.N    ??get_st_biases_15
    582                  return -1;
   \   00000206   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000020A   0xE156             B.N      ??get_st_biases_1
    583              if (hw_test)
   \                     ??get_st_biases_15:
   \   0000020C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000210   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000214   0xD002             BEQ.N    ??get_st_biases_16
    584                  AnBT_DMP_Delay_ms(200);
   \   00000216   0x20C8             MOVS     R0,#+200
   \   00000218   0x.... 0x....      BL       AnBT_DMP_Delay_ms
    585          
    586              /* Fill FIFO for test.wait_ms milliseconds. */
    587              data[0] = BIT_FIFO_EN;
   \                     ??get_st_biases_16:
   \   0000021C   0x2040             MOVS     R0,#+64
   \   0000021E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    588              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->user_ctrl, 1, data))
   \   00000222   0xAB00             ADD      R3,SP,#+0
   \   00000224   0x2201             MOVS     R2,#+1
   \   00000226   0x.... 0x....      LDR.W    R0,??DataTable27
   \   0000022A   0x6800             LDR      R0,[R0, #+0]
   \   0000022C   0x7901             LDRB     R1,[R0, #+4]
   \   0000022E   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000232   0x6840             LDR      R0,[R0, #+4]
   \   00000234   0x7800             LDRB     R0,[R0, #+0]
   \   00000236   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   0000023A   0x2800             CMP      R0,#+0
   \   0000023C   0xD002             BEQ.N    ??get_st_biases_17
    589                  return -1;
   \   0000023E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000242   0xE13A             B.N      ??get_st_biases_1
    590          
    591              data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
   \                     ??get_st_biases_17:
   \   00000244   0x2078             MOVS     R0,#+120
   \   00000246   0xF88D 0x0000      STRB     R0,[SP, #+0]
    592              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->fifo_en, 1, data))
   \   0000024A   0xAB00             ADD      R3,SP,#+0
   \   0000024C   0x2201             MOVS     R2,#+1
   \   0000024E   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000252   0x6800             LDR      R0,[R0, #+0]
   \   00000254   0x7941             LDRB     R1,[R0, #+5]
   \   00000256   0x.... 0x....      LDR.W    R0,??DataTable27
   \   0000025A   0x6840             LDR      R0,[R0, #+4]
   \   0000025C   0x7800             LDRB     R0,[R0, #+0]
   \   0000025E   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000262   0x2800             CMP      R0,#+0
   \   00000264   0xD002             BEQ.N    ??get_st_biases_18
    593                  return -1;
   \   00000266   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000026A   0xE126             B.N      ??get_st_biases_1
    594              AnBT_DMP_Delay_ms(test.wait_ms);
   \                     ??get_st_biases_18:
   \   0000026C   0x.... 0x....      LDR.W    R0,??DataTable28
   \   00000270   0x8980             LDRH     R0,[R0, #+12]
   \   00000272   0x.... 0x....      BL       AnBT_DMP_Delay_ms
    595              data[0] = 0;
   \   00000276   0x2000             MOVS     R0,#+0
   \   00000278   0xF88D 0x0000      STRB     R0,[SP, #+0]
    596              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->fifo_en, 1, data))
   \   0000027C   0xAB00             ADD      R3,SP,#+0
   \   0000027E   0x2201             MOVS     R2,#+1
   \   00000280   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000284   0x6800             LDR      R0,[R0, #+0]
   \   00000286   0x7941             LDRB     R1,[R0, #+5]
   \   00000288   0x.... 0x....      LDR.W    R0,??DataTable27
   \   0000028C   0x6840             LDR      R0,[R0, #+4]
   \   0000028E   0x7800             LDRB     R0,[R0, #+0]
   \   00000290   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000294   0x2800             CMP      R0,#+0
   \   00000296   0xD002             BEQ.N    ??get_st_biases_19
    597                  return -1;
   \   00000298   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000029C   0xE10D             B.N      ??get_st_biases_1
    598          
    599              if (AnBT_DMP_I2C_Read(st.hw->addr, st.reg->fifo_count_h, 2, data))
   \                     ??get_st_biases_19:
   \   0000029E   0xAB00             ADD      R3,SP,#+0
   \   000002A0   0x2202             MOVS     R2,#+2
   \   000002A2   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000002A6   0x6800             LDR      R0,[R0, #+0]
   \   000002A8   0x7A81             LDRB     R1,[R0, #+10]
   \   000002AA   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000002AE   0x6840             LDR      R0,[R0, #+4]
   \   000002B0   0x7800             LDRB     R0,[R0, #+0]
   \   000002B2   0x.... 0x....      BL       AnBT_DMP_I2C_Read
   \   000002B6   0x2800             CMP      R0,#+0
   \   000002B8   0xD002             BEQ.N    ??get_st_biases_20
    600                  return -1;
   \   000002BA   0xF05F 0x30FF      MOVS     R0,#-1
   \   000002BE   0xE0FC             B.N      ??get_st_biases_1
    601          
    602              fifo_count = (data[0] << 8) | data[1];
   \                     ??get_st_biases_20:
   \   000002C0   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000002C4   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   000002C8   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000002CC   0x4681             MOV      R9,R0
    603              packet_count = fifo_count / MAX_PACKET_LENGTH;
   \   000002CE   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000002D2   0x200C             MOVS     R0,#+12
   \   000002D4   0xFB99 0xF0F0      SDIV     R0,R9,R0
   \   000002D8   0x0004             MOVS     R4,R0
    604              gyro[0] = gyro[1] = gyro[2] = 0;
   \   000002DA   0x2000             MOVS     R0,#+0
   \   000002DC   0x60A8             STR      R0,[R5, #+8]
   \   000002DE   0x6068             STR      R0,[R5, #+4]
   \   000002E0   0x6028             STR      R0,[R5, #+0]
    605              accel[0] = accel[1] = accel[2] = 0;
   \   000002E2   0x2000             MOVS     R0,#+0
   \   000002E4   0x60B0             STR      R0,[R6, #+8]
   \   000002E6   0x6070             STR      R0,[R6, #+4]
   \   000002E8   0x6030             STR      R0,[R6, #+0]
    606          
    607              for (ii = 0; ii < packet_count; ii++) {
   \   000002EA   0x2000             MOVS     R0,#+0
   \   000002EC   0x0007             MOVS     R7,R0
   \                     ??get_st_biases_21:
   \   000002EE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000002F0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002F2   0x42A7             CMP      R7,R4
   \   000002F4   0xD266             BCS.N    ??get_st_biases_22
    608                  short accel_cur[3], gyro_cur[3];
    609                  if (AnBT_DMP_I2C_Read(st.hw->addr, st.reg->fifo_r_w, MAX_PACKET_LENGTH, data))
   \   000002F6   0xAB00             ADD      R3,SP,#+0
   \   000002F8   0x220C             MOVS     R2,#+12
   \   000002FA   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000002FE   0x6800             LDR      R0,[R0, #+0]
   \   00000300   0x7AC1             LDRB     R1,[R0, #+11]
   \   00000302   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000306   0x6840             LDR      R0,[R0, #+4]
   \   00000308   0x7800             LDRB     R0,[R0, #+0]
   \   0000030A   0x.... 0x....      BL       AnBT_DMP_I2C_Read
   \   0000030E   0x2800             CMP      R0,#+0
   \   00000310   0xD002             BEQ.N    ??get_st_biases_23
    610                      return -1;
   \   00000312   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000316   0xE0D0             B.N      ??get_st_biases_1
    611                  accel_cur[0] = ((short)data[0] << 8) | data[1];
   \                     ??get_st_biases_23:
   \   00000318   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000031C   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   00000320   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000324   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    612                  accel_cur[1] = ((short)data[2] << 8) | data[3];
   \   00000328   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000032C   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000330   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000334   0xF8AD 0x0016      STRH     R0,[SP, #+22]
    613                  accel_cur[2] = ((short)data[4] << 8) | data[5];
   \   00000338   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000033C   0xF89D 0x1005      LDRB     R1,[SP, #+5]
   \   00000340   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000344   0xF8AD 0x0018      STRH     R0,[SP, #+24]
    614                  accel[0] += (long)accel_cur[0];
   \   00000348   0x6830             LDR      R0,[R6, #+0]
   \   0000034A   0xF9BD 0x1014      LDRSH    R1,[SP, #+20]
   \   0000034E   0xFA00 0xF081      SXTAH    R0,R0,R1
   \   00000352   0x6030             STR      R0,[R6, #+0]
    615                  accel[1] += (long)accel_cur[1];
   \   00000354   0x6870             LDR      R0,[R6, #+4]
   \   00000356   0xF9BD 0x1016      LDRSH    R1,[SP, #+22]
   \   0000035A   0xFA00 0xF081      SXTAH    R0,R0,R1
   \   0000035E   0x6070             STR      R0,[R6, #+4]
    616                  accel[2] += (long)accel_cur[2];
   \   00000360   0x68B0             LDR      R0,[R6, #+8]
   \   00000362   0xF9BD 0x1018      LDRSH    R1,[SP, #+24]
   \   00000366   0xFA00 0xF081      SXTAH    R0,R0,R1
   \   0000036A   0x60B0             STR      R0,[R6, #+8]
    617                  gyro_cur[0] = (((short)data[6] << 8) | data[7]);
   \   0000036C   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   00000370   0xF89D 0x1007      LDRB     R1,[SP, #+7]
   \   00000374   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000378   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    618                  gyro_cur[1] = (((short)data[8] << 8) | data[9]);
   \   0000037C   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000380   0xF89D 0x1009      LDRB     R1,[SP, #+9]
   \   00000384   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000388   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    619                  gyro_cur[2] = (((short)data[10] << 8) | data[11]);
   \   0000038C   0xF89D 0x000A      LDRB     R0,[SP, #+10]
   \   00000390   0xF89D 0x100B      LDRB     R1,[SP, #+11]
   \   00000394   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000398   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    620                  gyro[0] += (long)gyro_cur[0];
   \   0000039C   0x6828             LDR      R0,[R5, #+0]
   \   0000039E   0xF9BD 0x100C      LDRSH    R1,[SP, #+12]
   \   000003A2   0xFA00 0xF081      SXTAH    R0,R0,R1
   \   000003A6   0x6028             STR      R0,[R5, #+0]
    621                  gyro[1] += (long)gyro_cur[1];
   \   000003A8   0x6868             LDR      R0,[R5, #+4]
   \   000003AA   0xF9BD 0x100E      LDRSH    R1,[SP, #+14]
   \   000003AE   0xFA00 0xF081      SXTAH    R0,R0,R1
   \   000003B2   0x6068             STR      R0,[R5, #+4]
    622                  gyro[2] += (long)gyro_cur[2];
   \   000003B4   0x68A8             LDR      R0,[R5, #+8]
   \   000003B6   0xF9BD 0x1010      LDRSH    R1,[SP, #+16]
   \   000003BA   0xFA00 0xF081      SXTAH    R0,R0,R1
   \   000003BE   0x60A8             STR      R0,[R5, #+8]
    623              }
   \   000003C0   0x1C7F             ADDS     R7,R7,#+1
   \   000003C2   0xE794             B.N      ??get_st_biases_21
    624          
    625              gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / packet_count);
   \                     ??get_st_biases_22:
   \   000003C4   0x6828             LDR      R0,[R5, #+0]
   \   000003C6   0x17C1             ASRS     R1,R0,#+31
   \   000003C8   0x0409             LSLS     R1,R1,#+16
   \   000003CA   0xEA41 0x4110      ORR      R1,R1,R0, LSR #+16
   \   000003CE   0x0400             LSLS     R0,R0,#+16
   \   000003D0   0x.... 0x....      LDR.W    R2,??DataTable28
   \   000003D4   0x6812             LDR      R2,[R2, #+0]
   \   000003D6   0x2300             MOVS     R3,#+0
   \   000003D8   0x.... 0x....      BL       __aeabi_ldivmod
   \   000003DC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003DE   0x0022             MOVS     R2,R4
   \   000003E0   0x2300             MOVS     R3,#+0
   \   000003E2   0x.... 0x....      BL       __aeabi_ldivmod
   \   000003E6   0x6028             STR      R0,[R5, #+0]
    626              gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
   \   000003E8   0x6868             LDR      R0,[R5, #+4]
   \   000003EA   0x17C1             ASRS     R1,R0,#+31
   \   000003EC   0x0409             LSLS     R1,R1,#+16
   \   000003EE   0xEA41 0x4110      ORR      R1,R1,R0, LSR #+16
   \   000003F2   0x0400             LSLS     R0,R0,#+16
   \   000003F4   0x.... 0x....      LDR.W    R2,??DataTable28
   \   000003F8   0x6812             LDR      R2,[R2, #+0]
   \   000003FA   0x2300             MOVS     R3,#+0
   \   000003FC   0x.... 0x....      BL       __aeabi_ldivmod
   \   00000400   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000402   0x0022             MOVS     R2,R4
   \   00000404   0x2300             MOVS     R3,#+0
   \   00000406   0x.... 0x....      BL       __aeabi_ldivmod
   \   0000040A   0x6068             STR      R0,[R5, #+4]
    627              gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
   \   0000040C   0x68A8             LDR      R0,[R5, #+8]
   \   0000040E   0x17C1             ASRS     R1,R0,#+31
   \   00000410   0x0409             LSLS     R1,R1,#+16
   \   00000412   0xEA41 0x4110      ORR      R1,R1,R0, LSR #+16
   \   00000416   0x0400             LSLS     R0,R0,#+16
   \   00000418   0x.... 0x....      LDR.W    R2,??DataTable28
   \   0000041C   0x6812             LDR      R2,[R2, #+0]
   \   0000041E   0x2300             MOVS     R3,#+0
   \   00000420   0x.... 0x....      BL       __aeabi_ldivmod
   \   00000424   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000426   0x0022             MOVS     R2,R4
   \   00000428   0x2300             MOVS     R3,#+0
   \   0000042A   0x.... 0x....      BL       __aeabi_ldivmod
   \   0000042E   0x60A8             STR      R0,[R5, #+8]
    628              accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
    629                  packet_count);
   \   00000430   0x6830             LDR      R0,[R6, #+0]
   \   00000432   0x17C1             ASRS     R1,R0,#+31
   \   00000434   0x0409             LSLS     R1,R1,#+16
   \   00000436   0xEA41 0x4110      ORR      R1,R1,R0, LSR #+16
   \   0000043A   0x0400             LSLS     R0,R0,#+16
   \   0000043C   0x.... 0x....      LDR.W    R2,??DataTable28
   \   00000440   0x6852             LDR      R2,[R2, #+4]
   \   00000442   0x2300             MOVS     R3,#+0
   \   00000444   0x.... 0x....      BL       __aeabi_ldivmod
   \   00000448   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000044A   0x0022             MOVS     R2,R4
   \   0000044C   0x2300             MOVS     R3,#+0
   \   0000044E   0x.... 0x....      BL       __aeabi_ldivmod
   \   00000452   0x6030             STR      R0,[R6, #+0]
    630              accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens /
    631                  packet_count);
   \   00000454   0x6870             LDR      R0,[R6, #+4]
   \   00000456   0x17C1             ASRS     R1,R0,#+31
   \   00000458   0x0409             LSLS     R1,R1,#+16
   \   0000045A   0xEA41 0x4110      ORR      R1,R1,R0, LSR #+16
   \   0000045E   0x0400             LSLS     R0,R0,#+16
   \   00000460   0x.... 0x....      LDR.W    R2,??DataTable28
   \   00000464   0x6852             LDR      R2,[R2, #+4]
   \   00000466   0x2300             MOVS     R3,#+0
   \   00000468   0x.... 0x....      BL       __aeabi_ldivmod
   \   0000046C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000046E   0x0022             MOVS     R2,R4
   \   00000470   0x2300             MOVS     R3,#+0
   \   00000472   0x.... 0x....      BL       __aeabi_ldivmod
   \   00000476   0x6070             STR      R0,[R6, #+4]
    632              accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens /
    633                  packet_count);
   \   00000478   0x68B0             LDR      R0,[R6, #+8]
   \   0000047A   0x17C1             ASRS     R1,R0,#+31
   \   0000047C   0x0409             LSLS     R1,R1,#+16
   \   0000047E   0xEA41 0x4110      ORR      R1,R1,R0, LSR #+16
   \   00000482   0x0400             LSLS     R0,R0,#+16
   \   00000484   0x.... 0x....      LDR.W    R2,??DataTable28
   \   00000488   0x6852             LDR      R2,[R2, #+4]
   \   0000048A   0x2300             MOVS     R3,#+0
   \   0000048C   0x.... 0x....      BL       __aeabi_ldivmod
   \   00000490   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000492   0x0022             MOVS     R2,R4
   \   00000494   0x2300             MOVS     R3,#+0
   \   00000496   0x.... 0x....      BL       __aeabi_ldivmod
   \   0000049A   0x60B0             STR      R0,[R6, #+8]
    634              /* Don't remove gravity! */
    635              if (accel[2] > 0L)
   \   0000049C   0x68B0             LDR      R0,[R6, #+8]
   \   0000049E   0x2801             CMP      R0,#+1
   \   000004A0   0xDB06             BLT.N    ??get_st_biases_24
    636                  accel[2] -= 65536L;
   \   000004A2   0x68B0             LDR      R0,[R6, #+8]
   \   000004A4   0xF100 0x407F      ADD      R0,R0,#-16777216
   \   000004A8   0xF510 0x007F      ADDS     R0,R0,#+16711680
   \   000004AC   0x60B0             STR      R0,[R6, #+8]
   \   000004AE   0xE003             B.N      ??get_st_biases_25
    637              else
    638                  accel[2] += 65536L;
   \                     ??get_st_biases_24:
   \   000004B0   0x68B0             LDR      R0,[R6, #+8]
   \   000004B2   0xF510 0x3080      ADDS     R0,R0,#+65536
   \   000004B6   0x60B0             STR      R0,[R6, #+8]
    639          
    640              return 0;
   \                     ??get_st_biases_25:
   \   000004B8   0x2000             MOVS     R0,#+0
   \                     ??get_st_biases_1:
   \   000004BA   0xB007             ADD      SP,SP,#+28
   \   000004BC   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    641          }

   \                                 In section .text, align 2, keep-with-next
    642          static int get_accel_prod_shift(float *st_shift)
    643          {
   \                     get_accel_prod_shift:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
    644              unsigned char tmp[4], shift_code[3], ii;
    645          
    646              if (AnBT_DMP_I2C_Read(st.hw->addr, 0x0D, 4, tmp))
   \   00000006   0xAB00             ADD      R3,SP,#+0
   \   00000008   0x2204             MOVS     R2,#+4
   \   0000000A   0x210D             MOVS     R1,#+13
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000010   0x6840             LDR      R0,[R0, #+4]
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x.... 0x....      BL       AnBT_DMP_I2C_Read
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD001             BEQ.N    ??get_accel_prod_shift_0
    647                  return 0x07;
   \   0000001C   0x2007             MOVS     R0,#+7
   \   0000001E   0xE052             B.N      ??get_accel_prod_shift_1
    648          
    649              shift_code[0] = ((tmp[0] & 0xE0) >> 3) | ((tmp[3] & 0x30) >> 4);
   \                     ??get_accel_prod_shift_0:
   \   00000020   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x08C0             LSRS     R0,R0,#+3
   \   00000028   0xF010 0x001C      ANDS     R0,R0,#0x1C
   \   0000002C   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000030   0xF3C1 0x1101      UBFX     R1,R1,#+4,#+2
   \   00000034   0x4308             ORRS     R0,R1,R0
   \   00000036   0xF88D 0x0004      STRB     R0,[SP, #+4]
    650              shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
   \   0000003A   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0x08C0             LSRS     R0,R0,#+3
   \   00000042   0xF010 0x001C      ANDS     R0,R0,#0x1C
   \   00000046   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   0000004A   0xF3C1 0x0181      UBFX     R1,R1,#+2,#+2
   \   0000004E   0x4308             ORRS     R0,R1,R0
   \   00000050   0xF88D 0x0005      STRB     R0,[SP, #+5]
    651              shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
   \   00000054   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x08C0             LSRS     R0,R0,#+3
   \   0000005C   0xF010 0x001C      ANDS     R0,R0,#0x1C
   \   00000060   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000064   0xF011 0x0103      ANDS     R1,R1,#0x3
   \   00000068   0x4308             ORRS     R0,R1,R0
   \   0000006A   0xF88D 0x0006      STRB     R0,[SP, #+6]
    652              for (ii = 0; ii < 3; ii++) {
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x0005             MOVS     R5,R0
   \                     ??get_accel_prod_shift_2:
   \   00000072   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000074   0x2D03             CMP      R5,#+3
   \   00000076   0xD225             BCS.N    ??get_accel_prod_shift_3
    653                  if (!shift_code[ii]) {
   \   00000078   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007A   0xA801             ADD      R0,SP,#+4
   \   0000007C   0x5C28             LDRB     R0,[R5, R0]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD104             BNE.N    ??get_accel_prod_shift_4
    654                      st_shift[ii] = 0.f;
   \   00000082   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xF844 0x0025      STR      R0,[R4, R5, LSL #+2]
    655                      continue;
   \   0000008A   0xE019             B.N      ??get_accel_prod_shift_5
    656                  }
    657                  /* Equivalent to..
    658                   * st_shift[ii] = 0.34f * powf(0.92f/0.34f, (shift_code[ii]-1) / 30.f)
    659                   */
    660                  st_shift[ii] = 0.34f;
   \                     ??get_accel_prod_shift_4:
   \   0000008C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x3eae147b
   \   00000092   0xF844 0x0025      STR      R0,[R4, R5, LSL #+2]
    661                  while (--shift_code[ii])
   \                     ??get_accel_prod_shift_6:
   \   00000096   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000098   0xA801             ADD      R0,SP,#+4
   \   0000009A   0x5C28             LDRB     R0,[R5, R0]
   \   0000009C   0x1E40             SUBS     R0,R0,#+1
   \   0000009E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A0   0xA901             ADD      R1,SP,#+4
   \   000000A2   0x5468             STRB     R0,[R5, R1]
   \   000000A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD00A             BEQ.N    ??get_accel_prod_shift_5
    662                      st_shift[ii] *= 1.034f;
   \   000000AA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000AC   0xF854 0x0025      LDR      R0,[R4, R5, LSL #+2]
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable30_1  ;; 0x3f845a1d
   \   000000B4   0x.... 0x....      BL       __aeabi_fmul
   \   000000B8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BA   0xF844 0x0025      STR      R0,[R4, R5, LSL #+2]
   \   000000BE   0xE7EA             B.N      ??get_accel_prod_shift_6
    663              }
   \                     ??get_accel_prod_shift_5:
   \   000000C0   0x1C6D             ADDS     R5,R5,#+1
   \   000000C2   0xE7D6             B.N      ??get_accel_prod_shift_2
    664              return 0;
   \                     ??get_accel_prod_shift_3:
   \   000000C4   0x2000             MOVS     R0,#+0
   \                     ??get_accel_prod_shift_1:
   \   000000C6   0xBD3E             POP      {R1-R5,PC}       ;; return
    665          }

   \                                 In section .text, align 2, keep-with-next
    666          int mpu_get_gyro_sens(float *sens)
    667          {
   \                     mpu_get_gyro_sens:
   \   00000000   0x0001             MOVS     R1,R0
    668              switch (st.chip_cfg.gyro_fsr) {
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000006   0x7A00             LDRB     R0,[R0, #+8]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD005             BEQ.N    ??mpu_get_gyro_sens_0
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD00B             BEQ.N    ??mpu_get_gyro_sens_1
   \   00000010   0xD306             BCC.N    ??mpu_get_gyro_sens_2
   \   00000012   0x2803             CMP      R0,#+3
   \   00000014   0xD00C             BEQ.N    ??mpu_get_gyro_sens_3
   \   00000016   0xE00F             B.N      ??mpu_get_gyro_sens_4
    669              case INV_FSR_250DPS:
    670                  sens[0] = 131.f;
   \                     ??mpu_get_gyro_sens_0:
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable30_2  ;; 0x43030000
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    671                  break;
   \   0000001E   0xE00E             B.N      ??mpu_get_gyro_sens_5
    672              case INV_FSR_500DPS:
    673                  sens[0] = 65.5f;
   \                     ??mpu_get_gyro_sens_2:
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable30_3  ;; 0x42830000
   \   00000024   0x6008             STR      R0,[R1, #+0]
    674                  break;
   \   00000026   0xE00A             B.N      ??mpu_get_gyro_sens_5
    675              case INV_FSR_1000DPS:
    676                  sens[0] = 32.8f;
   \                     ??mpu_get_gyro_sens_1:
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable30_4  ;; 0x42033333
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    677                  break;
   \   0000002E   0xE006             B.N      ??mpu_get_gyro_sens_5
    678              case INV_FSR_2000DPS:
    679                  sens[0] = 16.4f;
   \                     ??mpu_get_gyro_sens_3:
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable30_5  ;; 0x41833333
   \   00000034   0x6008             STR      R0,[R1, #+0]
    680                  break;
   \   00000036   0xE002             B.N      ??mpu_get_gyro_sens_5
    681              default:
    682                  return -1;
   \                     ??mpu_get_gyro_sens_4:
   \   00000038   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000003C   0xE000             B.N      ??mpu_get_gyro_sens_6
    683              }
    684              return 0;
   \                     ??mpu_get_gyro_sens_5:
   \   0000003E   0x2000             MOVS     R0,#+0
   \                     ??mpu_get_gyro_sens_6:
   \   00000040   0x4770             BX       LR               ;; return
    685          }

   \                                 In section .text, align 2, keep-with-next
    686          int mpu_get_accel_sens(unsigned short *sens)
    687          {
   \                     mpu_get_accel_sens:
   \   00000000   0x0001             MOVS     R1,R0
    688              switch (st.chip_cfg.accel_fsr) {
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000006   0x7A40             LDRB     R0,[R0, #+9]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD005             BEQ.N    ??mpu_get_accel_sens_0
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD00B             BEQ.N    ??mpu_get_accel_sens_1
   \   00000010   0xD306             BCC.N    ??mpu_get_accel_sens_2
   \   00000012   0x2803             CMP      R0,#+3
   \   00000014   0xD00C             BEQ.N    ??mpu_get_accel_sens_3
   \   00000016   0xE00F             B.N      ??mpu_get_accel_sens_4
    689              case INV_FSR_2G:
    690                  sens[0] = 16384;
   \                     ??mpu_get_accel_sens_0:
   \   00000018   0xF44F 0x4080      MOV      R0,#+16384
   \   0000001C   0x8008             STRH     R0,[R1, #+0]
    691                  break;
   \   0000001E   0xE00E             B.N      ??mpu_get_accel_sens_5
    692              case INV_FSR_4G:
    693                  sens[0] = 8092;
   \                     ??mpu_get_accel_sens_2:
   \   00000020   0xF641 0x709C      MOVW     R0,#+8092
   \   00000024   0x8008             STRH     R0,[R1, #+0]
    694                  break;
   \   00000026   0xE00A             B.N      ??mpu_get_accel_sens_5
    695              case INV_FSR_8G:
    696                  sens[0] = 4096;
   \                     ??mpu_get_accel_sens_1:
   \   00000028   0xF44F 0x5080      MOV      R0,#+4096
   \   0000002C   0x8008             STRH     R0,[R1, #+0]
    697                  break;
   \   0000002E   0xE006             B.N      ??mpu_get_accel_sens_5
    698              case INV_FSR_16G:
    699                  sens[0] = 2048;
   \                     ??mpu_get_accel_sens_3:
   \   00000030   0xF44F 0x6000      MOV      R0,#+2048
   \   00000034   0x8008             STRH     R0,[R1, #+0]
    700                  break;
   \   00000036   0xE002             B.N      ??mpu_get_accel_sens_5
    701              default:
    702                  return -1;
   \                     ??mpu_get_accel_sens_4:
   \   00000038   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000003C   0xE009             B.N      ??mpu_get_accel_sens_6
    703              }
    704              if (st.chip_cfg.accel_half)
   \                     ??mpu_get_accel_sens_5:
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000042   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD003             BEQ.N    ??mpu_get_accel_sens_7
    705                  sens[0] >>= 1;
   \   00000048   0x8808             LDRH     R0,[R1, #+0]
   \   0000004A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004C   0x0840             LSRS     R0,R0,#+1
   \   0000004E   0x8008             STRH     R0,[R1, #+0]
    706              return 0;
   \                     ??mpu_get_accel_sens_7:
   \   00000050   0x2000             MOVS     R0,#+0
   \                     ??mpu_get_accel_sens_6:
   \   00000052   0x4770             BX       LR               ;; return
    707          }
    708          //

   \                                 In section .text, align 2, keep-with-next
    709          static int accel_self_test(long *bias_regular, long *bias_st)
    710          {
   \                     accel_self_test:
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x4683             MOV      R11,R0
   \   00000006   0x468A             MOV      R10,R1
    711              int jj, result = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    712              float st_shift[3], st_shift_cust, st_shift_var;
    713          
    714              get_accel_prod_shift(st_shift);
   \   0000000A   0xA800             ADD      R0,SP,#+0
   \   0000000C   0x.... 0x....      BL       get_accel_prod_shift
    715              for(jj = 0; jj < 3; jj++) {
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x0006             MOVS     R6,R0
   \                     ??accel_self_test_0:
   \   00000014   0x2E03             CMP      R6,#+3
   \   00000016   0xDA47             BGE.N    ??accel_self_test_1
    716                  st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
   \   00000018   0xF85B 0x0026      LDR      R0,[R11, R6, LSL #+2]
   \   0000001C   0xF85A 0x1026      LDR      R1,[R10, R6, LSL #+2]
   \   00000020   0x1A40             SUBS     R0,R0,R1
   \   00000022   0x.... 0x....      BL       labs
   \   00000026   0x.... 0x....      BL       __aeabi_i2f
   \   0000002A   0xF05F 0x418F      MOVS     R1,#+1199570944
   \   0000002E   0x.... 0x....      BL       __aeabi_fdiv
   \   00000032   0x4680             MOV      R8,R0
    717                  if (st_shift[jj]) {
   \   00000034   0xA800             ADD      R0,SP,#+0
   \   00000036   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000040   0xD01F             BEQ.N    ??accel_self_test_2
    718                      st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
   \   00000042   0x4640             MOV      R0,R8
   \   00000044   0xA900             ADD      R1,SP,#+0
   \   00000046   0xF851 0x1026      LDR      R1,[R1, R6, LSL #+2]
   \   0000004A   0x.... 0x....      BL       __aeabi_fdiv
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable30_6  ;; 0xbf800000
   \   00000052   0x.... 0x....      BL       __aeabi_fadd
   \   00000056   0x4681             MOV      R9,R0
    719                      if (fabs(st_shift_var) > test.max_accel_var)
   \   00000058   0x4648             MOV      R0,R9
   \   0000005A   0x.... 0x....      BL       __aeabi_f2d
   \   0000005E   0x0004             MOVS     R4,R0
   \   00000060   0x000D             MOVS     R5,R1
   \   00000062   0xF035 0x4500      BICS     R5,R5,#0x80000000
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable28
   \   0000006A   0x6A40             LDR      R0,[R0, #+36]
   \   0000006C   0x.... 0x....      BL       __aeabi_f2d
   \   00000070   0x0022             MOVS     R2,R4
   \   00000072   0x002B             MOVS     R3,R5
   \   00000074   0x.... 0x....      BL       __aeabi_cdcmple
   \   00000078   0xD214             BCS.N    ??accel_self_test_3
    720                          result |= 1 << jj;
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x40B0             LSLS     R0,R0,R6
   \   0000007E   0x4307             ORRS     R7,R0,R7
   \   00000080   0xE010             B.N      ??accel_self_test_3
    721                  } else if ((st_shift_cust < test.min_g) ||
    722                      (st_shift_cust > test.max_g))
   \                     ??accel_self_test_2:
   \   00000082   0x4640             MOV      R0,R8
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable28
   \   00000088   0x69C9             LDR      R1,[R1, #+28]
   \   0000008A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000008E   0xD306             BCC.N    ??accel_self_test_4
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable28
   \   00000094   0x6A00             LDR      R0,[R0, #+32]
   \   00000096   0x4641             MOV      R1,R8
   \   00000098   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000009C   0xD202             BCS.N    ??accel_self_test_3
    723                      result |= 1 << jj;
   \                     ??accel_self_test_4:
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0x40B0             LSLS     R0,R0,R6
   \   000000A2   0x4307             ORRS     R7,R0,R7
    724              }
   \                     ??accel_self_test_3:
   \   000000A4   0x1C76             ADDS     R6,R6,#+1
   \   000000A6   0xE7B5             B.N      ??accel_self_test_0
    725          
    726              return result;
   \                     ??accel_self_test_1:
   \   000000A8   0x0038             MOVS     R0,R7
   \   000000AA   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    727          }

   \                                 In section .text, align 2, keep-with-next
    728          static int gyro_self_test(long *bias_regular, long *bias_st)
    729          {
   \                     gyro_self_test:
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x468B             MOV      R11,R1
    730              int jj, result = 0;
   \   00000008   0x2500             MOVS     R5,#+0
    731              unsigned char tmp[3];
    732              float st_shift, st_shift_cust, st_shift_var;
    733          
    734              if (AnBT_DMP_I2C_Read(st.hw->addr, 0x0D, 3, tmp))
   \   0000000A   0xAB00             ADD      R3,SP,#+0
   \   0000000C   0x2203             MOVS     R2,#+3
   \   0000000E   0x210D             MOVS     R1,#+13
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000014   0x6840             LDR      R0,[R0, #+4]
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x.... 0x....      BL       AnBT_DMP_I2C_Read
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ.N    ??gyro_self_test_0
    735                  return 0x07;
   \   00000020   0x2007             MOVS     R0,#+7
   \   00000022   0xE074             B.N      ??gyro_self_test_1
    736          
    737              tmp[0] &= 0x1F;
   \                     ??gyro_self_test_0:
   \   00000024   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000028   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   0000002C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    738              tmp[1] &= 0x1F;
   \   00000030   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000034   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000038   0xF88D 0x0001      STRB     R0,[SP, #+1]
    739              tmp[2] &= 0x1F;
   \   0000003C   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000040   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000044   0xF88D 0x0002      STRB     R0,[SP, #+2]
    740          
    741              for (jj = 0; jj < 3; jj++) {
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x0004             MOVS     R4,R0
   \                     ??gyro_self_test_2:
   \   0000004C   0x2C03             CMP      R4,#+3
   \   0000004E   0xDA5D             BGE.N    ??gyro_self_test_3
    742                  st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
   \   00000050   0x9802             LDR      R0,[SP, #+8]
   \   00000052   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000056   0xF85B 0x1024      LDR      R1,[R11, R4, LSL #+2]
   \   0000005A   0x1A40             SUBS     R0,R0,R1
   \   0000005C   0x.... 0x....      BL       labs
   \   00000060   0x.... 0x....      BL       __aeabi_i2f
   \   00000064   0xF05F 0x418F      MOVS     R1,#+1199570944
   \   00000068   0x.... 0x....      BL       __aeabi_fdiv
   \   0000006C   0x0007             MOVS     R7,R0
    743                  if (tmp[jj]) {
   \   0000006E   0xA800             ADD      R0,SP,#+0
   \   00000070   0x5C20             LDRB     R0,[R4, R0]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD037             BEQ.N    ??gyro_self_test_4
    744                      st_shift = 3275.f / test.gyro_sens;
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable28
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000080   0x0001             MOVS     R1,R0
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable30_7  ;; 0x454cb000
   \   00000086   0x.... 0x....      BL       __aeabi_fdiv
   \   0000008A   0x0006             MOVS     R6,R0
    745                      while (--tmp[jj])
   \                     ??gyro_self_test_5:
   \   0000008C   0xA800             ADD      R0,SP,#+0
   \   0000008E   0x5C20             LDRB     R0,[R4, R0]
   \   00000090   0x1E40             SUBS     R0,R0,#+1
   \   00000092   0xA900             ADD      R1,SP,#+0
   \   00000094   0x5460             STRB     R0,[R4, R1]
   \   00000096   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD006             BEQ.N    ??gyro_self_test_6
    746                          st_shift *= 1.046f;
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable30_8  ;; 0x3f85e354
   \   000000A0   0x0031             MOVS     R1,R6
   \   000000A2   0x.... 0x....      BL       __aeabi_fmul
   \   000000A6   0x0006             MOVS     R6,R0
   \   000000A8   0xE7F0             B.N      ??gyro_self_test_5
    747                      st_shift_var = st_shift_cust / st_shift - 1.f;
   \                     ??gyro_self_test_6:
   \   000000AA   0x0038             MOVS     R0,R7
   \   000000AC   0x0031             MOVS     R1,R6
   \   000000AE   0x.... 0x....      BL       __aeabi_fdiv
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable30_6  ;; 0xbf800000
   \   000000B6   0x.... 0x....      BL       __aeabi_fadd
   \   000000BA   0x4682             MOV      R10,R0
    748                      if (fabs(st_shift_var) > test.max_gyro_var)
   \   000000BC   0x4650             MOV      R0,R10
   \   000000BE   0x.... 0x....      BL       __aeabi_f2d
   \   000000C2   0x4680             MOV      R8,R0
   \   000000C4   0x4689             MOV      R9,R1
   \   000000C6   0xF039 0x4900      BICS     R9,R9,#0x80000000
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable28
   \   000000CE   0x6980             LDR      R0,[R0, #+24]
   \   000000D0   0x.... 0x....      BL       __aeabi_f2d
   \   000000D4   0x4642             MOV      R2,R8
   \   000000D6   0x464B             MOV      R3,R9
   \   000000D8   0x.... 0x....      BL       __aeabi_cdcmple
   \   000000DC   0xD214             BCS.N    ??gyro_self_test_7
    749                          result |= 1 << jj;
   \   000000DE   0x2001             MOVS     R0,#+1
   \   000000E0   0x40A0             LSLS     R0,R0,R4
   \   000000E2   0x4305             ORRS     R5,R0,R5
   \   000000E4   0xE010             B.N      ??gyro_self_test_7
    750                  } else if ((st_shift_cust < test.min_dps) ||
    751                      (st_shift_cust > test.max_dps))
   \                     ??gyro_self_test_4:
   \   000000E6   0x0038             MOVS     R0,R7
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable28
   \   000000EC   0x6909             LDR      R1,[R1, #+16]
   \   000000EE   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000F2   0xD306             BCC.N    ??gyro_self_test_8
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable28
   \   000000F8   0x6940             LDR      R0,[R0, #+20]
   \   000000FA   0x0039             MOVS     R1,R7
   \   000000FC   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000100   0xD202             BCS.N    ??gyro_self_test_7
    752                      result |= 1 << jj;
   \                     ??gyro_self_test_8:
   \   00000102   0x2001             MOVS     R0,#+1
   \   00000104   0x40A0             LSLS     R0,R0,R4
   \   00000106   0x4305             ORRS     R5,R0,R5
    753              }
   \                     ??gyro_self_test_7:
   \   00000108   0x1C64             ADDS     R4,R4,#+1
   \   0000010A   0xE79F             B.N      ??gyro_self_test_2
    754              return result;
   \                     ??gyro_self_test_3:
   \   0000010C   0x0028             MOVS     R0,R5
   \                     ??gyro_self_test_1:
   \   0000010E   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    755          }

   \                                 In section .text, align 2, keep-with-next
    756          int mpu_run_self_test(long *gyro, long *accel)
    757          {
   \                     mpu_run_self_test:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    758              const unsigned char tries = 2;
   \   0000000A   0x2602             MOVS     R6,#+2
    759              long gyro_st[3], accel_st[3];
    760              unsigned char accel_result, gyro_result;
    761              int ii;
    762              int result;
    763              unsigned char accel_fsr, fifo_sensors, sensors_on;
    764              unsigned short gyro_fsr, sample_rate, lpf;
    765              unsigned char dmp_was_on;
    766          
    767              if (st.chip_cfg.dmp_on) {
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000010   0xF890 0x0024      LDRB     R0,[R0, #+36]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD005             BEQ.N    ??mpu_run_self_test_0
    768                  mpu_set_dmp_state(0);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      BL       mpu_set_dmp_state
    769                  dmp_was_on = 1;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x4682             MOV      R10,R0
   \   00000022   0xE001             B.N      ??mpu_run_self_test_1
    770              } else
    771                  dmp_was_on = 0;
   \                     ??mpu_run_self_test_0:
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x4682             MOV      R10,R0
    772          
    773              /* Get initial settings. */
    774              mpu_get_gyro_fsr(&gyro_fsr);
   \                     ??mpu_run_self_test_1:
   \   00000028   0xF10D 0x0006      ADD      R0,SP,#+6
   \   0000002C   0x.... 0x....      BL       mpu_get_gyro_fsr
    775              mpu_get_accel_fsr(&accel_fsr);
   \   00000030   0xF10D 0x0001      ADD      R0,SP,#+1
   \   00000034   0x.... 0x....      BL       mpu_get_accel_fsr
    776              mpu_get_lpf(&lpf);
   \   00000038   0xF10D 0x0002      ADD      R0,SP,#+2
   \   0000003C   0x.... 0x....      BL       mpu_get_lpf
    777              mpu_get_sample_rate(&sample_rate);
   \   00000040   0xA801             ADD      R0,SP,#+4
   \   00000042   0x.... 0x....      BL       mpu_get_sample_rate
    778              sensors_on = st.chip_cfg.sensors;
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable27
   \   0000004A   0x7A80             LDRB     R0,[R0, #+10]
   \   0000004C   0x4681             MOV      R9,R0
    779              mpu_get_fifo_config(&fifo_sensors);
   \   0000004E   0xA800             ADD      R0,SP,#+0
   \   00000050   0x.... 0x....      BL       mpu_get_fifo_config
    780          
    781              /* For older chips, the self-test will be different. */
    782              for (ii = 0; ii < tries; ii++)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x4683             MOV      R11,R0
   \                     ??mpu_run_self_test_2:
   \   00000058   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005A   0x45B3             CMP      R11,R6
   \   0000005C   0xDA09             BGE.N    ??mpu_run_self_test_3
    783                  if (!get_st_biases(gyro, accel, 0))
   \   0000005E   0x2200             MOVS     R2,#+0
   \   00000060   0x0029             MOVS     R1,R5
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0x.... 0x....      BL       get_st_biases
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD002             BEQ.N    ??mpu_run_self_test_3
    784                      break;
   \                     ??mpu_run_self_test_4:
   \   0000006C   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   00000070   0xE7F2             B.N      ??mpu_run_self_test_2
    785              if (ii == tries) {
   \                     ??mpu_run_self_test_3:
   \   00000072   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000074   0x45B3             CMP      R11,R6
   \   00000076   0xD102             BNE.N    ??mpu_run_self_test_5
    786                  /* If we reach this point, we most likely encountered an I2C error.
    787                   * We'll just report an error for all three sensors.
    788                   */
    789                  result = 0;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x4680             MOV      R8,R0
    790                  goto restore;
   \   0000007C   0xE02C             B.N      ??mpu_run_self_test_6
    791              }
    792              for (ii = 0; ii < tries; ii++)
   \                     ??mpu_run_self_test_5:
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x4683             MOV      R11,R0
   \                     ??mpu_run_self_test_7:
   \   00000082   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000084   0x45B3             CMP      R11,R6
   \   00000086   0xDA09             BGE.N    ??mpu_run_self_test_8
    793                  if (!get_st_biases(gyro_st, accel_st, 1))
   \   00000088   0x2201             MOVS     R2,#+1
   \   0000008A   0xA903             ADD      R1,SP,#+12
   \   0000008C   0xA806             ADD      R0,SP,#+24
   \   0000008E   0x.... 0x....      BL       get_st_biases
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD002             BEQ.N    ??mpu_run_self_test_8
    794                      break;
   \                     ??mpu_run_self_test_9:
   \   00000096   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   0000009A   0xE7F2             B.N      ??mpu_run_self_test_7
    795              if (ii == tries) {
   \                     ??mpu_run_self_test_8:
   \   0000009C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009E   0x45B3             CMP      R11,R6
   \   000000A0   0xD102             BNE.N    ??mpu_run_self_test_10
    796                  /* Again, probably an I2C error. */
    797                  result = 0;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x4680             MOV      R8,R0
    798                  goto restore;
   \   000000A6   0xE017             B.N      ??mpu_run_self_test_6
    799              }
    800              accel_result = accel_self_test(accel, accel_st);
   \                     ??mpu_run_self_test_10:
   \   000000A8   0xA903             ADD      R1,SP,#+12
   \   000000AA   0x0028             MOVS     R0,R5
   \   000000AC   0x.... 0x....      BL       accel_self_test
   \   000000B0   0xF88D 0x0008      STRB     R0,[SP, #+8]
    801              gyro_result = gyro_self_test(gyro, gyro_st);
   \   000000B4   0xA906             ADD      R1,SP,#+24
   \   000000B6   0x0020             MOVS     R0,R4
   \   000000B8   0x.... 0x....      BL       gyro_self_test
   \   000000BC   0x0007             MOVS     R7,R0
    802          
    803              result = 0;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x4680             MOV      R8,R0
    804              if (!gyro_result)
   \   000000C2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000C4   0x2F00             CMP      R7,#+0
   \   000000C6   0xD101             BNE.N    ??mpu_run_self_test_11
    805                  result |= 0x01;
   \   000000C8   0xF058 0x0801      ORRS     R8,R8,#0x1
    806              if (!accel_result)
   \                     ??mpu_run_self_test_11:
   \   000000CC   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD101             BNE.N    ??mpu_run_self_test_6
    807                  result |= 0x02;
   \   000000D4   0xF058 0x0802      ORRS     R8,R8,#0x2
    808          
    809          restore:
    810          
    811              /* Set to invalid values to ensure no I2C writes are skipped. */
    812              st.chip_cfg.gyro_fsr = 0xFF;
   \                     ??mpu_run_self_test_6:
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000000DC   0x21FF             MOVS     R1,#+255
   \   000000DE   0x7201             STRB     R1,[R0, #+8]
    813              st.chip_cfg.accel_fsr = 0xFF;
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000000E4   0x21FF             MOVS     R1,#+255
   \   000000E6   0x7241             STRB     R1,[R0, #+9]
    814              st.chip_cfg.lpf = 0xFF;
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000000EC   0x21FF             MOVS     R1,#+255
   \   000000EE   0x72C1             STRB     R1,[R0, #+11]
    815              st.chip_cfg.sample_rate = 0xFFFF;
   \   000000F0   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000000F4   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000000F8   0x81C1             STRH     R1,[R0, #+14]
    816              st.chip_cfg.sensors = 0xFF;
   \   000000FA   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000000FE   0x21FF             MOVS     R1,#+255
   \   00000100   0x7281             STRB     R1,[R0, #+10]
    817              st.chip_cfg.fifo_enable = 0xFF;
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000106   0x21FF             MOVS     R1,#+255
   \   00000108   0x7401             STRB     R1,[R0, #+16]
    818              st.chip_cfg.clk_src = INV_CLK_PLL;
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable27
   \   0000010E   0x2101             MOVS     R1,#+1
   \   00000110   0x7301             STRB     R1,[R0, #+12]
    819              mpu_set_gyro_fsr(gyro_fsr);
   \   00000112   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \   00000116   0x.... 0x....      BL       mpu_set_gyro_fsr
    820              mpu_set_accel_fsr(accel_fsr);
   \   0000011A   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000011E   0x.... 0x....      BL       mpu_set_accel_fsr
    821              mpu_set_lpf(lpf);
   \   00000122   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000126   0x.... 0x....      BL       mpu_set_lpf
    822              mpu_set_sample_rate(sample_rate);
   \   0000012A   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   0000012E   0x.... 0x....      BL       mpu_set_sample_rate
    823              mpu_set_sensors(sensors_on);
   \   00000132   0x4648             MOV      R0,R9
   \   00000134   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000136   0x.... 0x....      BL       mpu_set_sensors
    824              mpu_configure_fifo(fifo_sensors);
   \   0000013A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000013E   0x.... 0x....      BL       mpu_configure_fifo
    825          
    826              if (dmp_was_on) mpu_set_dmp_state(1);
   \   00000142   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000146   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000014A   0xD002             BEQ.N    ??mpu_run_self_test_12
   \   0000014C   0x2001             MOVS     R0,#+1
   \   0000014E   0x.... 0x....      BL       mpu_set_dmp_state
    827                  
    828              return result;
   \                     ??mpu_run_self_test_12:
   \   00000152   0x4640             MOV      R0,R8
   \   00000154   0xB009             ADD      SP,SP,#+36
   \   00000156   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    829          }

   \                                 In section .text, align 2, keep-with-next
    830          static void run_self_test(void)
    831          {
   \                     run_self_test:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
    832              int result;
    833          //  char test_packet[4] = {0};
    834              long gyro[3], accel[3];
    835          	//
    836              result = mpu_run_self_test(gyro, accel);
   \   00000004   0xA902             ADD      R1,SP,#+8
   \   00000006   0xA805             ADD      R0,SP,#+20
   \   00000008   0x.... 0x....      BL       mpu_run_self_test
   \   0000000C   0x0004             MOVS     R4,R0
    837          //  if (result == 0x7) 
    838          		if (result == 0x3) 
   \   0000000E   0x2C03             CMP      R4,#+3
   \   00000010   0xD135             BNE.N    ??run_self_test_0
    839          		{
    840                  /* Test passed. We can trust the gyro data here, so let's push it down
    841                   * to the DMP.
    842                   */
    843                  float sens;
    844                  unsigned short accel_sens;
    845                  mpu_get_gyro_sens(&sens);
   \   00000012   0xA801             ADD      R0,SP,#+4
   \   00000014   0x.... 0x....      BL       mpu_get_gyro_sens
    846                  gyro[0] = (long)(gyro[0] * sens);
   \   00000018   0x9805             LDR      R0,[SP, #+20]
   \   0000001A   0x.... 0x....      BL       __aeabi_i2f
   \   0000001E   0x9901             LDR      R1,[SP, #+4]
   \   00000020   0x.... 0x....      BL       __aeabi_fmul
   \   00000024   0x.... 0x....      BL       __aeabi_f2iz
   \   00000028   0x9005             STR      R0,[SP, #+20]
    847                  gyro[1] = (long)(gyro[1] * sens);
   \   0000002A   0x9806             LDR      R0,[SP, #+24]
   \   0000002C   0x.... 0x....      BL       __aeabi_i2f
   \   00000030   0x9901             LDR      R1,[SP, #+4]
   \   00000032   0x.... 0x....      BL       __aeabi_fmul
   \   00000036   0x.... 0x....      BL       __aeabi_f2iz
   \   0000003A   0x9006             STR      R0,[SP, #+24]
    848                  gyro[2] = (long)(gyro[2] * sens);
   \   0000003C   0x9807             LDR      R0,[SP, #+28]
   \   0000003E   0x.... 0x....      BL       __aeabi_i2f
   \   00000042   0x9901             LDR      R1,[SP, #+4]
   \   00000044   0x.... 0x....      BL       __aeabi_fmul
   \   00000048   0x.... 0x....      BL       __aeabi_f2iz
   \   0000004C   0x9007             STR      R0,[SP, #+28]
    849                  dmp_set_gyro_bias(gyro);
   \   0000004E   0xA805             ADD      R0,SP,#+20
   \   00000050   0x.... 0x....      BL       dmp_set_gyro_bias
    850                  mpu_get_accel_sens(&accel_sens);
   \   00000054   0xA800             ADD      R0,SP,#+0
   \   00000056   0x.... 0x....      BL       mpu_get_accel_sens
    851                  accel[0] *= accel_sens;
   \   0000005A   0x9802             LDR      R0,[SP, #+8]
   \   0000005C   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000060   0x4348             MULS     R0,R1,R0
   \   00000062   0x9002             STR      R0,[SP, #+8]
    852                  accel[1] *= accel_sens;
   \   00000064   0x9803             LDR      R0,[SP, #+12]
   \   00000066   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   0000006A   0x4348             MULS     R0,R1,R0
   \   0000006C   0x9003             STR      R0,[SP, #+12]
    853                  accel[2] *= accel_sens;
   \   0000006E   0x9804             LDR      R0,[SP, #+16]
   \   00000070   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000074   0x4348             MULS     R0,R1,R0
   \   00000076   0x9004             STR      R0,[SP, #+16]
    854                  dmp_set_accel_bias(accel);
   \   00000078   0xA802             ADD      R0,SP,#+8
   \   0000007A   0x.... 0x....      BL       dmp_set_accel_bias
    855              }
    856          }
   \                     ??run_self_test_0:
   \   0000007E   0xB008             ADD      SP,SP,#+32
   \   00000080   0xBD10             POP      {R4,PC}          ;; return
    857          //

   \                                 In section .text, align 2, keep-with-next
    858          int mpu_write_mem(unsigned short mem_addr, unsigned short length, unsigned char *data)
    859          {
   \                     mpu_write_mem:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
    860              unsigned char tmp[2];
    861          
    862              if (!data)
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD102             BNE.N    ??mpu_write_mem_0
    863                  return -1;
   \   0000000E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000012   0xE040             B.N      ??mpu_write_mem_1
    864              if (!st.chip_cfg.sensors)
   \                     ??mpu_write_mem_0:
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   00000018   0x7A80             LDRB     R0,[R0, #+10]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD102             BNE.N    ??mpu_write_mem_2
    865                  return -1;
   \   0000001E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000022   0xE038             B.N      ??mpu_write_mem_1
    866          
    867              tmp[0] = (unsigned char)(mem_addr >> 8);
   \                     ??mpu_write_mem_2:
   \   00000024   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000026   0x0A30             LSRS     R0,R6,#+8
   \   00000028   0xF88D 0x0000      STRB     R0,[SP, #+0]
    868              tmp[1] = (unsigned char)(mem_addr & 0xFF);
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    869          
    870              /* Check bank boundaries. */
    871              if (tmp[1] + length > st.hw->bank_size)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   00000036   0x6840             LDR      R0,[R0, #+4]
   \   00000038   0x8940             LDRH     R0,[R0, #+10]
   \   0000003A   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   0000003E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000040   0xFA54 0xF181      UXTAB    R1,R4,R1
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xDA02             BGE.N    ??mpu_write_mem_3
    872                  return -1;
   \   00000048   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000004C   0xE023             B.N      ??mpu_write_mem_1
    873          
    874              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->bank_sel, 2, tmp))
   \                     ??mpu_write_mem_3:
   \   0000004E   0xAB00             ADD      R3,SP,#+0
   \   00000050   0x2202             MOVS     R2,#+2
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x7E01             LDRB     R1,[R0, #+24]
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   0000005E   0x6840             LDR      R0,[R0, #+4]
   \   00000060   0x7800             LDRB     R0,[R0, #+0]
   \   00000062   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD002             BEQ.N    ??mpu_write_mem_4
    875                  return -1;
   \   0000006A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000006E   0xE012             B.N      ??mpu_write_mem_1
    876              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->mem_r_w, length, data))
   \                     ??mpu_write_mem_4:
   \   00000070   0x002B             MOVS     R3,R5
   \   00000072   0x0022             MOVS     R2,R4
   \   00000074   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x7D41             LDRB     R1,[R0, #+21]
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   00000082   0x6840             LDR      R0,[R0, #+4]
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD002             BEQ.N    ??mpu_write_mem_5
    877                  return -1;
   \   0000008E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000092   0xE000             B.N      ??mpu_write_mem_1
    878              return 0;
   \                     ??mpu_write_mem_5:
   \   00000094   0x2000             MOVS     R0,#+0
   \                     ??mpu_write_mem_1:
   \   00000096   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    879          }

   \                                 In section .text, align 2, keep-with-next
    880          int mpu_read_mem(unsigned short mem_addr, unsigned short length,  unsigned char *data)
    881          {
   \                     mpu_read_mem:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
    882              unsigned char tmp[2];
    883          
    884              if (!data)
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD102             BNE.N    ??mpu_read_mem_0
    885                  return -1;
   \   0000000E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000012   0xE040             B.N      ??mpu_read_mem_1
    886              if (!st.chip_cfg.sensors)
   \                     ??mpu_read_mem_0:
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   00000018   0x7A80             LDRB     R0,[R0, #+10]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD102             BNE.N    ??mpu_read_mem_2
    887                  return -1;
   \   0000001E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000022   0xE038             B.N      ??mpu_read_mem_1
    888          
    889              tmp[0] = (unsigned char)(mem_addr >> 8);
   \                     ??mpu_read_mem_2:
   \   00000024   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000026   0x0A30             LSRS     R0,R6,#+8
   \   00000028   0xF88D 0x0000      STRB     R0,[SP, #+0]
    890              tmp[1] = (unsigned char)(mem_addr & 0xFF);
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    891          
    892              /* Check bank boundaries. */
    893              if (tmp[1] + length > st.hw->bank_size)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   00000036   0x6840             LDR      R0,[R0, #+4]
   \   00000038   0x8940             LDRH     R0,[R0, #+10]
   \   0000003A   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   0000003E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000040   0xFA54 0xF181      UXTAB    R1,R4,R1
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xDA02             BGE.N    ??mpu_read_mem_3
    894                  return -1;
   \   00000048   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000004C   0xE023             B.N      ??mpu_read_mem_1
    895          
    896              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->bank_sel, 2, tmp))
   \                     ??mpu_read_mem_3:
   \   0000004E   0xAB00             ADD      R3,SP,#+0
   \   00000050   0x2202             MOVS     R2,#+2
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x7E01             LDRB     R1,[R0, #+24]
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   0000005E   0x6840             LDR      R0,[R0, #+4]
   \   00000060   0x7800             LDRB     R0,[R0, #+0]
   \   00000062   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD002             BEQ.N    ??mpu_read_mem_4
    897                  return -1;
   \   0000006A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000006E   0xE012             B.N      ??mpu_read_mem_1
    898              if (AnBT_DMP_I2C_Read(st.hw->addr, st.reg->mem_r_w, length, data))
   \                     ??mpu_read_mem_4:
   \   00000070   0x002B             MOVS     R3,R5
   \   00000072   0x0022             MOVS     R2,R4
   \   00000074   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x7D41             LDRB     R1,[R0, #+21]
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   00000082   0x6840             LDR      R0,[R0, #+4]
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x.... 0x....      BL       AnBT_DMP_I2C_Read
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD002             BEQ.N    ??mpu_read_mem_5
    899                  return -1;
   \   0000008E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000092   0xE000             B.N      ??mpu_read_mem_1
    900              return 0;
   \                     ??mpu_read_mem_5:
   \   00000094   0x2000             MOVS     R0,#+0
   \                     ??mpu_read_mem_1:
   \   00000096   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    901          }

   \                                 In section .text, align 2, keep-with-next
    902          int mpu_read_fifo_stream(unsigned short length, unsigned char *data, unsigned char *more)
    903          {
   \                     mpu_read_fifo_stream:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    904              unsigned char tmp[2];
    905              unsigned short fifo_count;
    906              if (!st.chip_cfg.dmp_on)
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   0000000C   0xF890 0x0024      LDRB     R0,[R0, #+36]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD102             BNE.N    ??mpu_read_fifo_stream_0
    907                  return -1;
   \   00000014   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000018   0xE064             B.N      ??mpu_read_fifo_stream_1
    908              if (!st.chip_cfg.sensors)
   \                     ??mpu_read_fifo_stream_0:
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   0000001E   0x7A80             LDRB     R0,[R0, #+10]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD102             BNE.N    ??mpu_read_fifo_stream_2
    909                  return -1;
   \   00000024   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000028   0xE05C             B.N      ??mpu_read_fifo_stream_1
    910          
    911              if (AnBT_DMP_I2C_Read(st.hw->addr, st.reg->fifo_count_h, 2, tmp))
   \                     ??mpu_read_fifo_stream_2:
   \   0000002A   0xAB00             ADD      R3,SP,#+0
   \   0000002C   0x2202             MOVS     R2,#+2
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x7A81             LDRB     R1,[R0, #+10]
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   0000003A   0x6840             LDR      R0,[R0, #+4]
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x.... 0x....      BL       AnBT_DMP_I2C_Read
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD002             BEQ.N    ??mpu_read_fifo_stream_3
    912                  return -1;
   \   00000046   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000004A   0xE04B             B.N      ??mpu_read_fifo_stream_1
    913              fifo_count = (tmp[0] << 8) | tmp[1];
   \                     ??mpu_read_fifo_stream_3:
   \   0000004C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000050   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   00000054   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000058   0x0007             MOVS     R7,R0
    914              if (fifo_count < length) {
   \   0000005A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000005C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000005E   0x42A7             CMP      R7,R4
   \   00000060   0xD204             BCS.N    ??mpu_read_fifo_stream_4
    915                  more[0] = 0;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x7030             STRB     R0,[R6, #+0]
    916                  return -1;
   \   00000066   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000006A   0xE03B             B.N      ??mpu_read_fifo_stream_1
    917              }
    918              if (fifo_count > (st.hw->max_fifo >> 1)) {
   \                     ??mpu_read_fifo_stream_4:
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   00000070   0x6840             LDR      R0,[R0, #+4]
   \   00000072   0x8840             LDRH     R0,[R0, #+2]
   \   00000074   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000076   0x0840             LSRS     R0,R0,#+1
   \   00000078   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000007A   0x42B8             CMP      R0,R7
   \   0000007C   0xD219             BCS.N    ??mpu_read_fifo_stream_5
    919                  /* FIFO is 50% full, better check overflow bit. */
    920                  if (AnBT_DMP_I2C_Read(st.hw->addr, st.reg->int_status, 1, tmp))
   \   0000007E   0xAB00             ADD      R3,SP,#+0
   \   00000080   0x2201             MOVS     R2,#+1
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x7C41             LDRB     R1,[R0, #+17]
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   0000008E   0x6840             LDR      R0,[R0, #+4]
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0x.... 0x....      BL       AnBT_DMP_I2C_Read
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD002             BEQ.N    ??mpu_read_fifo_stream_6
    921                      return -1;
   \   0000009A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000009E   0xE021             B.N      ??mpu_read_fifo_stream_1
    922                  if (tmp[0] & BIT_FIFO_OVERFLOW) {
   \                     ??mpu_read_fifo_stream_6:
   \   000000A0   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000A4   0x06C0             LSLS     R0,R0,#+27
   \   000000A6   0xD504             BPL.N    ??mpu_read_fifo_stream_5
    923                      mpu_reset_fifo();
   \   000000A8   0x.... 0x....      BL       mpu_reset_fifo
    924                      return -2;
   \   000000AC   0xF07F 0x0001      MVNS     R0,#+1
   \   000000B0   0xE018             B.N      ??mpu_read_fifo_stream_1
    925                  }
    926              }
    927          
    928              if (AnBT_DMP_I2C_Read(st.hw->addr, st.reg->fifo_r_w, length, data))
   \                     ??mpu_read_fifo_stream_5:
   \   000000B2   0x002B             MOVS     R3,R5
   \   000000B4   0x0022             MOVS     R2,R4
   \   000000B6   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0x7AC1             LDRB     R1,[R0, #+11]
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   000000C4   0x6840             LDR      R0,[R0, #+4]
   \   000000C6   0x7800             LDRB     R0,[R0, #+0]
   \   000000C8   0x.... 0x....      BL       AnBT_DMP_I2C_Read
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD002             BEQ.N    ??mpu_read_fifo_stream_7
    929                  return -1;
   \   000000D0   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000D4   0xE006             B.N      ??mpu_read_fifo_stream_1
    930              more[0] = fifo_count / length - 1;
   \                     ??mpu_read_fifo_stream_7:
   \   000000D6   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000D8   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000DA   0xFB97 0xF0F4      SDIV     R0,R7,R4
   \   000000DE   0x1E40             SUBS     R0,R0,#+1
   \   000000E0   0x7030             STRB     R0,[R6, #+0]
    931              return 0;
   \   000000E2   0x2000             MOVS     R0,#+0
   \                     ??mpu_read_fifo_stream_1:
   \   000000E4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    932          }

   \                                 In section .text, align 2, keep-with-next
    933          int mpu_load_firmware(unsigned short length, const unsigned char *firmware,unsigned short start_addr, unsigned short sample_rate)
    934          {
   \                     mpu_load_firmware:
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    935              unsigned short ii;
    936              unsigned short this_write;
    937              /* Must divide evenly into st.hw->bank_size to avoid bank crossings. */
    938          #define LOAD_CHUNK  (16)
    939              unsigned char cur[LOAD_CHUNK], tmp[2];
    940          
    941              if (st.chip_cfg.dmp_loaded)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   00000012   0xF890 0x0025      LDRB     R0,[R0, #+37]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD002             BEQ.N    ??mpu_load_firmware_0
    942                  /* DMP should only be loaded once. */
    943                  return -1;
   \   0000001A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000001E   0xE065             B.N      ??mpu_load_firmware_1
    944          
    945              if (!firmware)
   \                     ??mpu_load_firmware_0:
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD102             BNE.N    ??mpu_load_firmware_2
    946                  return -1;
   \   00000024   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000028   0xE060             B.N      ??mpu_load_firmware_1
    947              for (ii = 0; ii < length; ii += this_write) {
   \                     ??mpu_load_firmware_2:
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x4680             MOV      R8,R0
   \                     ??mpu_load_firmware_3:
   \   0000002E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000032   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000034   0x45A0             CMP      R8,R4
   \   00000036   0xD238             BCS.N    ??mpu_load_firmware_4
    948                  this_write = min(LOAD_CHUNK, length - ii);
   \   00000038   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000003A   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000003E   0xEBB4 0x0008      SUBS     R0,R4,R8
   \   00000042   0x2811             CMP      R0,#+17
   \   00000044   0xDB02             BLT.N    ??mpu_load_firmware_5
   \   00000046   0xF05F 0x0910      MOVS     R9,#+16
   \   0000004A   0xE001             B.N      ??mpu_load_firmware_6
   \                     ??mpu_load_firmware_5:
   \   0000004C   0xEBB4 0x0908      SUBS     R9,R4,R8
    949                  if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
   \                     ??mpu_load_firmware_6:
   \   00000050   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000054   0xEB18 0x0205      ADDS     R2,R8,R5
   \   00000058   0x4649             MOV      R1,R9
   \   0000005A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000005C   0x4640             MOV      R0,R8
   \   0000005E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000060   0x.... 0x....      BL       mpu_write_mem
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD002             BEQ.N    ??mpu_load_firmware_7
    950                      return -1;
   \   00000068   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000006C   0xE03E             B.N      ??mpu_load_firmware_1
    951                  if (mpu_read_mem(ii, this_write, cur))
   \                     ??mpu_load_firmware_7:
   \   0000006E   0xAA01             ADD      R2,SP,#+4
   \   00000070   0x4649             MOV      R1,R9
   \   00000072   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000074   0x4640             MOV      R0,R8
   \   00000076   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000078   0x.... 0x....      BL       mpu_read_mem
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD002             BEQ.N    ??mpu_load_firmware_8
    952                      return -1;
   \   00000080   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000084   0xE032             B.N      ??mpu_load_firmware_1
    953                  if (memcmp(firmware+ii, cur, this_write))
   \                     ??mpu_load_firmware_8:
   \   00000086   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000008A   0x464A             MOV      R2,R9
   \   0000008C   0xA901             ADD      R1,SP,#+4
   \   0000008E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000092   0xEB18 0x0005      ADDS     R0,R8,R5
   \   00000096   0x.... 0x....      BL       memcmp
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD002             BEQ.N    ??mpu_load_firmware_9
    954                      return -2;
   \   0000009E   0xF07F 0x0001      MVNS     R0,#+1
   \   000000A2   0xE023             B.N      ??mpu_load_firmware_1
    955              }
   \                     ??mpu_load_firmware_9:
   \   000000A4   0xEB19 0x0808      ADDS     R8,R9,R8
   \   000000A8   0xE7C1             B.N      ??mpu_load_firmware_3
    956          
    957              /* Set program start address. */
    958              tmp[0] = start_addr >> 8;
   \                     ??mpu_load_firmware_4:
   \   000000AA   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000AC   0x0A30             LSRS     R0,R6,#+8
   \   000000AE   0xF88D 0x0000      STRB     R0,[SP, #+0]
    959              tmp[1] = start_addr & 0xFF;
   \   000000B2   0x0030             MOVS     R0,R6
   \   000000B4   0xF88D 0x0001      STRB     R0,[SP, #+1]
    960              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
   \   000000B8   0xAB00             ADD      R3,SP,#+0
   \   000000BA   0x2202             MOVS     R2,#+2
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   000000C0   0x6800             LDR      R0,[R0, #+0]
   \   000000C2   0x7E81             LDRB     R1,[R0, #+26]
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   000000C8   0x6840             LDR      R0,[R0, #+4]
   \   000000CA   0x7800             LDRB     R0,[R0, #+0]
   \   000000CC   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD002             BEQ.N    ??mpu_load_firmware_10
    961                  return -1;
   \   000000D4   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000D8   0xE008             B.N      ??mpu_load_firmware_1
    962          
    963              st.chip_cfg.dmp_loaded = 1;
   \                     ??mpu_load_firmware_10:
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   000000DE   0x2101             MOVS     R1,#+1
   \   000000E0   0xF880 0x1025      STRB     R1,[R0, #+37]
    964              st.chip_cfg.dmp_sample_rate = sample_rate;
   \   000000E4   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   000000E8   0x84C7             STRH     R7,[R0, #+38]
    965              return 0;
   \   000000EA   0x2000             MOVS     R0,#+0
   \                     ??mpu_load_firmware_1:
   \   000000EC   0xB005             ADD      SP,SP,#+20
   \   000000EE   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    966          }
    967          

   \                                 In section .text, align 2, keep-with-next
    968          static  unsigned short inv_row_2_scale(const signed char *row)
    969          {
   \                     inv_row_2_scale:
   \   00000000   0x0001             MOVS     R1,R0
    970              unsigned short b;
    971          	//
    972              if (row[0] > 0)    b = 0;
   \   00000002   0xF991 0x2000      LDRSB    R2,[R1, #+0]
   \   00000006   0x2A01             CMP      R2,#+1
   \   00000008   0xDB02             BLT.N    ??inv_row_2_scale_0
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x0010             MOVS     R0,R2
   \   0000000E   0xE024             B.N      ??inv_row_2_scale_1
    973              else if (row[0] < 0)  b = 4;
   \                     ??inv_row_2_scale_0:
   \   00000010   0xF991 0x2000      LDRSB    R2,[R1, #+0]
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD502             BPL.N    ??inv_row_2_scale_2
   \   00000018   0x2204             MOVS     R2,#+4
   \   0000001A   0x0010             MOVS     R0,R2
   \   0000001C   0xE01D             B.N      ??inv_row_2_scale_1
    974              else if (row[1] > 0)   b = 1;
   \                     ??inv_row_2_scale_2:
   \   0000001E   0xF991 0x2001      LDRSB    R2,[R1, #+1]
   \   00000022   0x2A01             CMP      R2,#+1
   \   00000024   0xDB02             BLT.N    ??inv_row_2_scale_3
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0x0010             MOVS     R0,R2
   \   0000002A   0xE016             B.N      ??inv_row_2_scale_1
    975              else if (row[1] < 0)   b = 5;
   \                     ??inv_row_2_scale_3:
   \   0000002C   0xF991 0x2001      LDRSB    R2,[R1, #+1]
   \   00000030   0x2A00             CMP      R2,#+0
   \   00000032   0xD502             BPL.N    ??inv_row_2_scale_4
   \   00000034   0x2205             MOVS     R2,#+5
   \   00000036   0x0010             MOVS     R0,R2
   \   00000038   0xE00F             B.N      ??inv_row_2_scale_1
    976              else if (row[2] > 0)       b = 2;
   \                     ??inv_row_2_scale_4:
   \   0000003A   0xF991 0x2002      LDRSB    R2,[R1, #+2]
   \   0000003E   0x2A01             CMP      R2,#+1
   \   00000040   0xDB02             BLT.N    ??inv_row_2_scale_5
   \   00000042   0x2202             MOVS     R2,#+2
   \   00000044   0x0010             MOVS     R0,R2
   \   00000046   0xE008             B.N      ??inv_row_2_scale_1
    977              else if (row[2] < 0)   b = 6;
   \                     ??inv_row_2_scale_5:
   \   00000048   0xF991 0x2002      LDRSB    R2,[R1, #+2]
   \   0000004C   0x2A00             CMP      R2,#+0
   \   0000004E   0xD502             BPL.N    ??inv_row_2_scale_6
   \   00000050   0x2206             MOVS     R2,#+6
   \   00000052   0x0010             MOVS     R0,R2
   \   00000054   0xE001             B.N      ??inv_row_2_scale_1
    978              else         b = 7;      // error
   \                     ??inv_row_2_scale_6:
   \   00000056   0x2207             MOVS     R2,#+7
   \   00000058   0x0010             MOVS     R0,R2
    979              return b;
   \                     ??inv_row_2_scale_1:
   \   0000005A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005C   0x4770             BX       LR               ;; return
    980          }
    981          

   \                                 In section .text, align 2, keep-with-next
    982          static  unsigned short inv_orientation_matrix_to_scalar(const signed char *mtx)
    983          {
   \                     inv_orientation_matrix_to_scalar:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    984              unsigned short scalar;
    985          
    986              /*
    987                 XYZ  010_001_000 Identity Matrix
    988                 XZY  001_010_000
    989                 YXZ  010_000_001
    990                 YZX  000_010_001
    991                 ZXY  001_000_010
    992                 ZYX  000_001_010
    993               */
    994          
    995              scalar = inv_row_2_scale(mtx);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       inv_row_2_scale
   \   0000000A   0x0005             MOVS     R5,R0
    996              scalar |= inv_row_2_scale(mtx + 3) << 3;
   \   0000000C   0x1CE0             ADDS     R0,R4,#+3
   \   0000000E   0x.... 0x....      BL       inv_row_2_scale
   \   00000012   0xEA55 0x00C0      ORRS     R0,R5,R0, LSL #+3
   \   00000016   0x0005             MOVS     R5,R0
    997              scalar |= inv_row_2_scale(mtx + 6) << 6;
   \   00000018   0x1DA0             ADDS     R0,R4,#+6
   \   0000001A   0x.... 0x....      BL       inv_row_2_scale
   \   0000001E   0xEA55 0x1080      ORRS     R0,R5,R0, LSL #+6
   \   00000022   0x0005             MOVS     R5,R0
    998              return scalar;
   \   00000024   0x0028             MOVS     R0,R5
   \   00000026   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    999          }
   1000          
   1001          //

   \                                 In section .text, align 2, keep-with-next
   1002          uint8 AnBT_DMP_MPU6050_DEV_CFG(void)		
   1003          {
   \                     AnBT_DMP_MPU6050_DEV_CFG:
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   1004          	  unsigned char anbt_dmp_data[6], anbt_dmp_rev;
   1005          		//
   1006          		if (AnBT_DMP_I2C_Read(st.hw->addr, st.reg->who_am_i, 1, &(anbt_dmp_data[0]))) return 1;   
   \   00000002   0xAB00             ADD      R3,SP,#+0
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x7801             LDRB     R1,[R0, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable30_9
   \   00000012   0x6840             LDR      R0,[R0, #+4]
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x.... 0x....      BL       AnBT_DMP_I2C_Read
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??AnBT_DMP_MPU6050_DEV_CFG_0
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE0F9             B.N      ??AnBT_DMP_MPU6050_DEV_CFG_1
   1007          	  if (anbt_dmp_data[0]!=PRODUCT_WHOAMI) 
   \                     ??AnBT_DMP_MPU6050_DEV_CFG_0:
   \   00000022   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000026   0x2868             CMP      R0,#+104
   \   00000028   0xD00A             BEQ.N    ??AnBT_DMP_MPU6050_DEV_CFG_2
   1008          		{
   1009          			AnBT_Uart1_Send_String("WHOAMI error",12); 
   \   0000002A   0x210C             MOVS     R1,#+12
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable30_10
   \   00000030   0x.... 0x....      BL       AnBT_Uart1_Send_String
   1010          			AnBT_Uart1_Send_Num(anbt_dmp_data[0]);
   \   00000034   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000038   0x.... 0x....      BL       AnBT_Uart1_Send_Num
   1011          			return 2;    
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0xE0EA             B.N      ??AnBT_DMP_MPU6050_DEV_CFG_1
   1012              }
   1013          		//
   1014              anbt_dmp_data[0] = 0x80;	//etootle: BIT_RESET, Reset device
   \                     ??AnBT_DMP_MPU6050_DEV_CFG_2:
   \   00000040   0x2080             MOVS     R0,#+128
   \   00000042   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1015              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &(anbt_dmp_data[0]))) return 3;   
   \   00000046   0xAB00             ADD      R3,SP,#+0
   \   00000048   0x2201             MOVS     R2,#+1
   \   0000004A   0x....             LDR.N    R0,??DataTable30_9
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x7C81             LDRB     R1,[R0, #+18]
   \   00000050   0x....             LDR.N    R0,??DataTable30_9
   \   00000052   0x6840             LDR      R0,[R0, #+4]
   \   00000054   0x7800             LDRB     R0,[R0, #+0]
   \   00000056   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD001             BEQ.N    ??AnBT_DMP_MPU6050_DEV_CFG_3
   \   0000005E   0x2003             MOVS     R0,#+3
   \   00000060   0xE0D9             B.N      ??AnBT_DMP_MPU6050_DEV_CFG_1
   1016              AnBT_DMP_Delay_ms(100);
   \                     ??AnBT_DMP_MPU6050_DEV_CFG_3:
   \   00000062   0x2064             MOVS     R0,#+100
   \   00000064   0x.... 0x....      BL       AnBT_DMP_Delay_ms
   1017          		//
   1018              anbt_dmp_data[0] = 0x00; //etootle: Wake up chip
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1019              if (AnBT_DMP_I2C_Write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &(anbt_dmp_data[0]))) return 4;
   \   0000006E   0xAB00             ADD      R3,SP,#+0
   \   00000070   0x2201             MOVS     R2,#+1
   \   00000072   0x....             LDR.N    R0,??DataTable30_9
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x7C81             LDRB     R1,[R0, #+18]
   \   00000078   0x....             LDR.N    R0,??DataTable30_9
   \   0000007A   0x6840             LDR      R0,[R0, #+4]
   \   0000007C   0x7800             LDRB     R0,[R0, #+0]
   \   0000007E   0x.... 0x....      BL       AnBT_DMP_I2C_Write
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD001             BEQ.N    ??AnBT_DMP_MPU6050_DEV_CFG_4
   \   00000086   0x2004             MOVS     R0,#+4
   \   00000088   0xE0C5             B.N      ??AnBT_DMP_MPU6050_DEV_CFG_1
   1020              //
   1021              if (AnBT_DMP_I2C_Read(st.hw->addr, st.reg->accel_offs, 6, anbt_dmp_data))	return 5;	//etootle:Check product revision  
   \                     ??AnBT_DMP_MPU6050_DEV_CFG_4:
   \   0000008A   0xAB00             ADD      R3,SP,#+0
   \   0000008C   0x2206             MOVS     R2,#+6
   \   0000008E   0x....             LDR.N    R0,??DataTable30_9
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x7D81             LDRB     R1,[R0, #+22]
   \   00000094   0x....             LDR.N    R0,??DataTable30_9
   \   00000096   0x6840             LDR      R0,[R0, #+4]
   \   00000098   0x7800             LDRB     R0,[R0, #+0]
   \   0000009A   0x.... 0x....      BL       AnBT_DMP_I2C_Read
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD001             BEQ.N    ??AnBT_DMP_MPU6050_DEV_CFG_5
   \   000000A2   0x2005             MOVS     R0,#+5
   \   000000A4   0xE0B7             B.N      ??AnBT_DMP_MPU6050_DEV_CFG_1
   1022              anbt_dmp_rev = ((anbt_dmp_data[5] & 0x01) << 2) | ((anbt_dmp_data[3] & 0x01) << 1) | (anbt_dmp_data[1] & 0x01);
   \                     ??AnBT_DMP_MPU6050_DEV_CFG_5:
   \   000000A6   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   000000AA   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000AE   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   000000B2   0xF011 0x0101      ANDS     R1,R1,#0x1
   \   000000B6   0x0049             LSLS     R1,R1,#+1
   \   000000B8   0xEA51 0x0080      ORRS     R0,R1,R0, LSL #+2
   \   000000BC   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   000000C0   0xF011 0x0101      ANDS     R1,R1,#0x1
   \   000000C4   0x4308             ORRS     R0,R1,R0
   \   000000C6   0x0004             MOVS     R4,R0
   1023              if (anbt_dmp_rev)  //Congrats, these parts are better
   \   000000C8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CA   0x2C00             CMP      R4,#+0
   \   000000CC   0xD013             BEQ.N    ??AnBT_DMP_MPU6050_DEV_CFG_6
   1024          		{
   1025          			if (anbt_dmp_rev == 1) st.chip_cfg.accel_half = 1;   
   \   000000CE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000D0   0x2C01             CMP      R4,#+1
   \   000000D2   0xD103             BNE.N    ??AnBT_DMP_MPU6050_DEV_CFG_7
   \   000000D4   0x....             LDR.N    R0,??DataTable30_9
   \   000000D6   0x2101             MOVS     R1,#+1
   \   000000D8   0x74C1             STRB     R1,[R0, #+19]
   \   000000DA   0xE036             B.N      ??AnBT_DMP_MPU6050_DEV_CFG_8
   1026                else if (anbt_dmp_rev == 2) st.chip_cfg.accel_half = 0;   
   \                     ??AnBT_DMP_MPU6050_DEV_CFG_7:
   \   000000DC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000DE   0x2C02             CMP      R4,#+2
   \   000000E0   0xD103             BNE.N    ??AnBT_DMP_MPU6050_DEV_CFG_9
   \   000000E2   0x....             LDR.N    R0,??DataTable30_9
   \   000000E4   0x2100             MOVS     R1,#+0
   \   000000E6   0x74C1             STRB     R1,[R0, #+19]
   \   000000E8   0xE02F             B.N      ??AnBT_DMP_MPU6050_DEV_CFG_8
   1027                else 
   1028          			{
   1029          				AnBT_Uart1_Send_String("Unsupported version=1.0",23);  
   \                     ??AnBT_DMP_MPU6050_DEV_CFG_9:
   \   000000EA   0x2117             MOVS     R1,#+23
   \   000000EC   0x....             LDR.N    R0,??DataTable30_11
   \   000000EE   0x.... 0x....      BL       AnBT_Uart1_Send_String
   1030                  return 6;
   \   000000F2   0x2006             MOVS     R0,#+6
   \   000000F4   0xE08F             B.N      ??AnBT_DMP_MPU6050_DEV_CFG_1
   1031          			}
   1032              } 
   1033          		else 
   1034          		{
   1035          			if (AnBT_DMP_I2C_Read(st.hw->addr, st.reg->prod_id, 1, &(anbt_dmp_data[0]))) return 7;      
   \                     ??AnBT_DMP_MPU6050_DEV_CFG_6:
   \   000000F6   0xAB00             ADD      R3,SP,#+0
   \   000000F8   0x2201             MOVS     R2,#+1
   \   000000FA   0x....             LDR.N    R0,??DataTable30_9
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0x78C1             LDRB     R1,[R0, #+3]
   \   00000100   0x....             LDR.N    R0,??DataTable30_9
   \   00000102   0x6840             LDR      R0,[R0, #+4]
   \   00000104   0x7800             LDRB     R0,[R0, #+0]
   \   00000106   0x.... 0x....      BL       AnBT_DMP_I2C_Read
   \   0000010A   0x2800             CMP      R0,#+0
   \   0000010C   0xD001             BEQ.N    ??AnBT_DMP_MPU6050_DEV_CFG_10
   \   0000010E   0x2007             MOVS     R0,#+7
   \   00000110   0xE081             B.N      ??AnBT_DMP_MPU6050_DEV_CFG_1
   1036                anbt_dmp_rev = anbt_dmp_data[0] & 0x0F;
   \                     ??AnBT_DMP_MPU6050_DEV_CFG_10:
   \   00000112   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000116   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000011A   0x0004             MOVS     R4,R0
   1037                if (!anbt_dmp_rev) 
   \   0000011C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000011E   0x2C00             CMP      R4,#+0
   \   00000120   0xD105             BNE.N    ??AnBT_DMP_MPU6050_DEV_CFG_11
   1038          			{
   1039          				AnBT_Uart1_Send_String("Product ID error",16); 
   \   00000122   0x2110             MOVS     R1,#+16
   \   00000124   0x....             LDR.N    R0,??DataTable30_12
   \   00000126   0x.... 0x....      BL       AnBT_Uart1_Send_String
   1040          				return 5;    
   \   0000012A   0x2005             MOVS     R0,#+5
   \   0000012C   0xE073             B.N      ??AnBT_DMP_MPU6050_DEV_CFG_1
   1041                } 
   1042          			else if (anbt_dmp_rev == 4) 
   \                     ??AnBT_DMP_MPU6050_DEV_CFG_11:
   \   0000012E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000130   0x2C04             CMP      R4,#+4
   \   00000132   0xD107             BNE.N    ??AnBT_DMP_MPU6050_DEV_CFG_12
   1043          			{
   1044          				AnBT_Uart1_Send_String("Half Sensitivity Part",21); 
   \   00000134   0x2115             MOVS     R1,#+21
   \   00000136   0x....             LDR.N    R0,??DataTable30_13
   \   00000138   0x.... 0x....      BL       AnBT_Uart1_Send_String
   1045                  st.chip_cfg.accel_half = 1;
   \   0000013C   0x....             LDR.N    R0,??DataTable30_9
   \   0000013E   0x2101             MOVS     R1,#+1
   \   00000140   0x74C1             STRB     R1,[R0, #+19]
   \   00000142   0xE002             B.N      ??AnBT_DMP_MPU6050_DEV_CFG_8
   1046                } 
   1047          			else
   1048          			{
   1049          				st.chip_cfg.accel_half = 0;
   \                     ??AnBT_DMP_MPU6050_DEV_CFG_12:
   \   00000144   0x....             LDR.N    R0,??DataTable30_9
   \   00000146   0x2100             MOVS     R1,#+0
   \   00000148   0x74C1             STRB     R1,[R0, #+19]
   1050          			}
   1051              }
   1052          
   1053              /* Set to invalid values to ensure no I2C writes are skipped. */
   1054              st.chip_cfg.sensors = 0xFF;
   \                     ??AnBT_DMP_MPU6050_DEV_CFG_8:
   \   0000014A   0x....             LDR.N    R0,??DataTable30_9
   \   0000014C   0x21FF             MOVS     R1,#+255
   \   0000014E   0x7281             STRB     R1,[R0, #+10]
   1055              st.chip_cfg.gyro_fsr = 0xFF;
   \   00000150   0x....             LDR.N    R0,??DataTable30_9
   \   00000152   0x21FF             MOVS     R1,#+255
   \   00000154   0x7201             STRB     R1,[R0, #+8]
   1056              st.chip_cfg.accel_fsr = 0xFF;
   \   00000156   0x....             LDR.N    R0,??DataTable30_9
   \   00000158   0x21FF             MOVS     R1,#+255
   \   0000015A   0x7241             STRB     R1,[R0, #+9]
   1057              st.chip_cfg.lpf = 0xFF;
   \   0000015C   0x....             LDR.N    R0,??DataTable30_9
   \   0000015E   0x21FF             MOVS     R1,#+255
   \   00000160   0x72C1             STRB     R1,[R0, #+11]
   1058              st.chip_cfg.sample_rate = 0xFFFF;
   \   00000162   0x....             LDR.N    R0,??DataTable30_9
   \   00000164   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000168   0x81C1             STRH     R1,[R0, #+14]
   1059              st.chip_cfg.fifo_enable = 0xFF;
   \   0000016A   0x....             LDR.N    R0,??DataTable30_9
   \   0000016C   0x21FF             MOVS     R1,#+255
   \   0000016E   0x7401             STRB     R1,[R0, #+16]
   1060              st.chip_cfg.bypass_mode = 0xFF;
   \   00000170   0x....             LDR.N    R0,??DataTable30_9
   \   00000172   0x21FF             MOVS     R1,#+255
   \   00000174   0x7481             STRB     R1,[R0, #+18]
   1061          
   1062              /* mpu_set_sensors always preserves this setting. */
   1063              st.chip_cfg.clk_src = INV_CLK_PLL;
   \   00000176   0x....             LDR.N    R0,??DataTable30_9
   \   00000178   0x2101             MOVS     R1,#+1
   \   0000017A   0x7301             STRB     R1,[R0, #+12]
   1064              /* Handled in next call to mpu_set_bypass. */
   1065              st.chip_cfg.active_low_int = 1;
   \   0000017C   0x....             LDR.N    R0,??DataTable30_9
   \   0000017E   0x2101             MOVS     R1,#+1
   \   00000180   0xF880 0x1022      STRB     R1,[R0, #+34]
   1066              st.chip_cfg.latched_int = 0;
   \   00000184   0x....             LDR.N    R0,??DataTable30_9
   \   00000186   0x2100             MOVS     R1,#+0
   \   00000188   0xF880 0x1023      STRB     R1,[R0, #+35]
   1067              st.chip_cfg.int_motion_only = 0;
   \   0000018C   0x....             LDR.N    R0,??DataTable30_9
   \   0000018E   0x2100             MOVS     R1,#+0
   \   00000190   0x7541             STRB     R1,[R0, #+21]
   1068              st.chip_cfg.lp_accel_mode = 0;
   \   00000192   0x....             LDR.N    R0,??DataTable30_9
   \   00000194   0x2100             MOVS     R1,#+0
   \   00000196   0x7501             STRB     R1,[R0, #+20]
   1069              memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
   \   00000198   0x220C             MOVS     R2,#+12
   \   0000019A   0x2100             MOVS     R1,#+0
   \   0000019C   0x....             LDR.N    R0,??DataTable30_14
   \   0000019E   0x.... 0x....      BL       memset
   1070              st.chip_cfg.dmp_on = 0;
   \   000001A2   0x....             LDR.N    R0,??DataTable30_9
   \   000001A4   0x2100             MOVS     R1,#+0
   \   000001A6   0xF880 0x1024      STRB     R1,[R0, #+36]
   1071              st.chip_cfg.dmp_loaded = 0;
   \   000001AA   0x....             LDR.N    R0,??DataTable30_9
   \   000001AC   0x2100             MOVS     R1,#+0
   \   000001AE   0xF880 0x1025      STRB     R1,[R0, #+37]
   1072              st.chip_cfg.dmp_sample_rate = 0;
   \   000001B2   0x....             LDR.N    R0,??DataTable30_9
   \   000001B4   0x2100             MOVS     R1,#+0
   \   000001B6   0x84C1             STRH     R1,[R0, #+38]
   1073          
   1074              if (mpu_set_gyro_fsr(2000)) return 0x10;
   \   000001B8   0xF44F 0x60FA      MOV      R0,#+2000
   \   000001BC   0x.... 0x....      BL       mpu_set_gyro_fsr
   \   000001C0   0x2800             CMP      R0,#+0
   \   000001C2   0xD001             BEQ.N    ??AnBT_DMP_MPU6050_DEV_CFG_13
   \   000001C4   0x2010             MOVS     R0,#+16
   \   000001C6   0xE026             B.N      ??AnBT_DMP_MPU6050_DEV_CFG_1
   1075              if (mpu_set_accel_fsr(2)) return 0x11;   
   \                     ??AnBT_DMP_MPU6050_DEV_CFG_13:
   \   000001C8   0x2002             MOVS     R0,#+2
   \   000001CA   0x.... 0x....      BL       mpu_set_accel_fsr
   \   000001CE   0x2800             CMP      R0,#+0
   \   000001D0   0xD001             BEQ.N    ??AnBT_DMP_MPU6050_DEV_CFG_14
   \   000001D2   0x2011             MOVS     R0,#+17
   \   000001D4   0xE01F             B.N      ??AnBT_DMP_MPU6050_DEV_CFG_1
   1076              if (mpu_set_lpf(42)) return 0x12; 
   \                     ??AnBT_DMP_MPU6050_DEV_CFG_14:
   \   000001D6   0x202A             MOVS     R0,#+42
   \   000001D8   0x.... 0x....      BL       mpu_set_lpf
   \   000001DC   0x2800             CMP      R0,#+0
   \   000001DE   0xD001             BEQ.N    ??AnBT_DMP_MPU6050_DEV_CFG_15
   \   000001E0   0x2012             MOVS     R0,#+18
   \   000001E2   0xE018             B.N      ??AnBT_DMP_MPU6050_DEV_CFG_1
   1077              if (mpu_set_sample_rate(50)) return 0x13;
   \                     ??AnBT_DMP_MPU6050_DEV_CFG_15:
   \   000001E4   0x2032             MOVS     R0,#+50
   \   000001E6   0x.... 0x....      BL       mpu_set_sample_rate
   \   000001EA   0x2800             CMP      R0,#+0
   \   000001EC   0xD001             BEQ.N    ??AnBT_DMP_MPU6050_DEV_CFG_16
   \   000001EE   0x2013             MOVS     R0,#+19
   \   000001F0   0xE011             B.N      ??AnBT_DMP_MPU6050_DEV_CFG_1
   1078              if (mpu_configure_fifo(0)) return 0x14;
   \                     ??AnBT_DMP_MPU6050_DEV_CFG_16:
   \   000001F2   0x2000             MOVS     R0,#+0
   \   000001F4   0x.... 0x....      BL       mpu_configure_fifo
   \   000001F8   0x2800             CMP      R0,#+0
   \   000001FA   0xD001             BEQ.N    ??AnBT_DMP_MPU6050_DEV_CFG_17
   \   000001FC   0x2014             MOVS     R0,#+20
   \   000001FE   0xE00A             B.N      ??AnBT_DMP_MPU6050_DEV_CFG_1
   1079                  
   1080              /* Already disabled by setup_compass. */
   1081              if (mpu_set_bypass(0)) return 0x15;
   \                     ??AnBT_DMP_MPU6050_DEV_CFG_17:
   \   00000200   0x2000             MOVS     R0,#+0
   \   00000202   0x.... 0x....      BL       mpu_set_bypass
   \   00000206   0x2800             CMP      R0,#+0
   \   00000208   0xD001             BEQ.N    ??AnBT_DMP_MPU6050_DEV_CFG_18
   \   0000020A   0x2015             MOVS     R0,#+21
   \   0000020C   0xE003             B.N      ??AnBT_DMP_MPU6050_DEV_CFG_1
   1082              mpu_set_sensors(0);
   \                     ??AnBT_DMP_MPU6050_DEV_CFG_18:
   \   0000020E   0x2000             MOVS     R0,#+0
   \   00000210   0x.... 0x....      BL       mpu_set_sensors
   1083              return 0;
   \   00000214   0x2000             MOVS     R0,#+0
   \                     ??AnBT_DMP_MPU6050_DEV_CFG_1:
   \   00000216   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1084          }
   1085          
   1086          

   \                                 In section .text, align 2, keep-with-next
   1087          uint8 AnBT_DMP_MPU6050_Init(void)	
   1088          {
   \                     AnBT_DMP_MPU6050_Init:
   \   00000000   0xB580             PUSH     {R7,LR}
   1089          	AnBT_DMP_MPU6050_DEV_CFG();		//etootle: init the mpu6050 chip
   \   00000002   0x.... 0x....      BL       AnBT_DMP_MPU6050_DEV_CFG
   1090          	AnBT_Uart1_Send_String("P-1,Finish DMP device init.",27); 
   \   00000006   0x211B             MOVS     R1,#+27
   \   00000008   0x....             LDR.N    R0,??DataTable30_15
   \   0000000A   0x.... 0x....      BL       AnBT_Uart1_Send_String
   1091          	//
   1092          	if(!mpu_set_sensors(INV_XYZ_GYRO | INV_XYZ_ACCEL)) AnBT_Uart1_Send_String("P-2,Finish DMP set sensor.",26);
   \   0000000E   0x2078             MOVS     R0,#+120
   \   00000010   0x.... 0x....      BL       mpu_set_sensors
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD104             BNE.N    ??AnBT_DMP_MPU6050_Init_0
   \   00000018   0x211A             MOVS     R1,#+26
   \   0000001A   0x....             LDR.N    R0,??DataTable30_16
   \   0000001C   0x.... 0x....      BL       AnBT_Uart1_Send_String
   \   00000020   0xE003             B.N      ??AnBT_DMP_MPU6050_Init_1
   1093          	else AnBT_Uart1_Send_String("P-2,DMP set sensor error.",25);
   \                     ??AnBT_DMP_MPU6050_Init_0:
   \   00000022   0x2119             MOVS     R1,#+25
   \   00000024   0x....             LDR.N    R0,??DataTable30_17
   \   00000026   0x.... 0x....      BL       AnBT_Uart1_Send_String
   1094          	//
   1095          	if(!mpu_configure_fifo(INV_XYZ_GYRO | INV_XYZ_ACCEL)) AnBT_Uart1_Send_String("P-3,Finish DMP configure fifo.",30);
   \                     ??AnBT_DMP_MPU6050_Init_1:
   \   0000002A   0x2078             MOVS     R0,#+120
   \   0000002C   0x.... 0x....      BL       mpu_configure_fifo
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD104             BNE.N    ??AnBT_DMP_MPU6050_Init_2
   \   00000034   0x211E             MOVS     R1,#+30
   \   00000036   0x....             LDR.N    R0,??DataTable30_18
   \   00000038   0x.... 0x....      BL       AnBT_Uart1_Send_String
   \   0000003C   0xE003             B.N      ??AnBT_DMP_MPU6050_Init_3
   1096          	else AnBT_Uart1_Send_String("P-3,DMP configure fifo error.",29);
   \                     ??AnBT_DMP_MPU6050_Init_2:
   \   0000003E   0x211D             MOVS     R1,#+29
   \   00000040   0x....             LDR.N    R0,??DataTable30_19
   \   00000042   0x.... 0x....      BL       AnBT_Uart1_Send_String
   1097          	//
   1098          	if(!mpu_set_sample_rate(DEFAULT_MPU_HZ))AnBT_Uart1_Send_String("P-4,Finish DMP set sample rate.",31);
   \                     ??AnBT_DMP_MPU6050_Init_3:
   \   00000046   0x2064             MOVS     R0,#+100
   \   00000048   0x.... 0x....      BL       mpu_set_sample_rate
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD104             BNE.N    ??AnBT_DMP_MPU6050_Init_4
   \   00000050   0x211F             MOVS     R1,#+31
   \   00000052   0x....             LDR.N    R0,??DataTable30_20
   \   00000054   0x.... 0x....      BL       AnBT_Uart1_Send_String
   \   00000058   0xE003             B.N      ??AnBT_DMP_MPU6050_Init_5
   1099          	else AnBT_Uart1_Send_String("P-4,DMP set sample_rate error.",30);
   \                     ??AnBT_DMP_MPU6050_Init_4:
   \   0000005A   0x211E             MOVS     R1,#+30
   \   0000005C   0x....             LDR.N    R0,??DataTable30_21
   \   0000005E   0x.... 0x....      BL       AnBT_Uart1_Send_String
   1100          	//
   1101          	if(!dmp_load_motion_driver_firmware())	AnBT_Uart1_Send_String("P-5,Finish DMP load motion driver firmware.",43);
   \                     ??AnBT_DMP_MPU6050_Init_5:
   \   00000062   0x.... 0x....      BL       dmp_load_motion_driver_firmware
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD104             BNE.N    ??AnBT_DMP_MPU6050_Init_6
   \   0000006A   0x212B             MOVS     R1,#+43
   \   0000006C   0x....             LDR.N    R0,??DataTable30_22
   \   0000006E   0x.... 0x....      BL       AnBT_Uart1_Send_String
   \   00000072   0xE003             B.N      ??AnBT_DMP_MPU6050_Init_7
   1102          	else AnBT_Uart1_Send_String("P-5,DMP load motion driver firmware error.",42);
   \                     ??AnBT_DMP_MPU6050_Init_6:
   \   00000074   0x212A             MOVS     R1,#+42
   \   00000076   0x....             LDR.N    R0,??DataTable30_23
   \   00000078   0x.... 0x....      BL       AnBT_Uart1_Send_String
   1103          	//
   1104          	if(!dmp_set_orientation(inv_orientation_matrix_to_scalar(gyro_orientation))) AnBT_Uart1_Send_String("P-6,Finish DMP set orientation.",31);
   \                     ??AnBT_DMP_MPU6050_Init_7:
   \   0000007C   0x....             LDR.N    R0,??DataTable30_24
   \   0000007E   0x.... 0x....      BL       inv_orientation_matrix_to_scalar
   \   00000082   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000084   0x.... 0x....      BL       dmp_set_orientation
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD104             BNE.N    ??AnBT_DMP_MPU6050_Init_8
   \   0000008C   0x211F             MOVS     R1,#+31
   \   0000008E   0x....             LDR.N    R0,??DataTable30_25
   \   00000090   0x.... 0x....      BL       AnBT_Uart1_Send_String
   \   00000094   0xE003             B.N      ??AnBT_DMP_MPU6050_Init_9
   1105          	else AnBT_Uart1_Send_String("P-6,DMP set orientation error.",30);
   \                     ??AnBT_DMP_MPU6050_Init_8:
   \   00000096   0x211E             MOVS     R1,#+30
   \   00000098   0x....             LDR.N    R0,??DataTable30_26
   \   0000009A   0x.... 0x....      BL       AnBT_Uart1_Send_String
   1106          	//
   1107          	if(!dmp_enable_feature(DMP_FEATURE_6X_LP_QUAT | DMP_FEATURE_TAP |
   1108          	DMP_FEATURE_ANDROID_ORIENT | DMP_FEATURE_SEND_RAW_ACCEL | DMP_FEATURE_SEND_CAL_GYRO |
   1109          	DMP_FEATURE_GYRO_CAL))		AnBT_Uart1_Send_String("P-7,Finish DMP enable feature.",30);
   \                     ??AnBT_DMP_MPU6050_Init_9:
   \   0000009E   0xF240 0x1073      MOVW     R0,#+371
   \   000000A2   0x.... 0x....      BL       dmp_enable_feature
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD104             BNE.N    ??AnBT_DMP_MPU6050_Init_10
   \   000000AA   0x211E             MOVS     R1,#+30
   \   000000AC   0x....             LDR.N    R0,??DataTable30_27
   \   000000AE   0x.... 0x....      BL       AnBT_Uart1_Send_String
   \   000000B2   0xE003             B.N      ??AnBT_DMP_MPU6050_Init_11
   1110          	else AnBT_Uart1_Send_String("P-7,DMP enable feature error.",29);
   \                     ??AnBT_DMP_MPU6050_Init_10:
   \   000000B4   0x211D             MOVS     R1,#+29
   \   000000B6   0x....             LDR.N    R0,??DataTable30_28
   \   000000B8   0x.... 0x....      BL       AnBT_Uart1_Send_String
   1111          	//
   1112          	if(!dmp_set_fifo_rate(DEFAULT_MPU_HZ)) AnBT_Uart1_Send_String("P-8,Finish DMP set fifo rate.",29);
   \                     ??AnBT_DMP_MPU6050_Init_11:
   \   000000BC   0x2064             MOVS     R0,#+100
   \   000000BE   0x.... 0x....      BL       dmp_set_fifo_rate
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD104             BNE.N    ??AnBT_DMP_MPU6050_Init_12
   \   000000C6   0x211D             MOVS     R1,#+29
   \   000000C8   0x....             LDR.N    R0,??DataTable30_29
   \   000000CA   0x.... 0x....      BL       AnBT_Uart1_Send_String
   \   000000CE   0xE003             B.N      ??AnBT_DMP_MPU6050_Init_13
   1113          	else AnBT_Uart1_Send_String("P-8,DMP set fifo rate error.",28);
   \                     ??AnBT_DMP_MPU6050_Init_12:
   \   000000D0   0x211C             MOVS     R1,#+28
   \   000000D2   0x....             LDR.N    R0,??DataTable30_30
   \   000000D4   0x.... 0x....      BL       AnBT_Uart1_Send_String
   1114          	//
   1115          	run_self_test();
   \                     ??AnBT_DMP_MPU6050_Init_13:
   \   000000D8   0x.... 0x....      BL       run_self_test
   1116          	if(!mpu_set_dmp_state(1)) AnBT_Uart1_Send_String("P-9,Finish DMP set dmp state.",29);
   \   000000DC   0x2001             MOVS     R0,#+1
   \   000000DE   0x.... 0x....      BL       mpu_set_dmp_state
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD104             BNE.N    ??AnBT_DMP_MPU6050_Init_14
   \   000000E6   0x211D             MOVS     R1,#+29
   \   000000E8   0x....             LDR.N    R0,??DataTable30_31
   \   000000EA   0x.... 0x....      BL       AnBT_Uart1_Send_String
   \   000000EE   0xE003             B.N      ??AnBT_DMP_MPU6050_Init_15
   1117          	else AnBT_Uart1_Send_String("P-9,DMP set dmp state error.",28);	
   \                     ??AnBT_DMP_MPU6050_Init_14:
   \   000000F0   0x211C             MOVS     R1,#+28
   \   000000F2   0x....             LDR.N    R0,??DataTable30_32
   \   000000F4   0x.... 0x....      BL       AnBT_Uart1_Send_String
   1118          	//
   1119          	return 0;
   \                     ??AnBT_DMP_MPU6050_Init_15:
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xBD02             POP      {R1,PC}          ;; return
   1120          }
   1121          

   \                                 In section .text, align 2, keep-with-next
   1122          void AnBT_DMP_MPU6050_SEND_DATA_FUN(void)	
   1123          {
   \                     AnBT_DMP_MPU6050_SEND_DATA_FUN:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   1124          	dmp_read_fifo(gyro, accel, anbt_mpu6050_quat_data, &sensor_timestamp, &sensors, &more);	 
   \   00000004   0x....             LDR.N    R0,??DataTable30_33
   \   00000006   0x9001             STR      R0,[SP, #+4]
   \   00000008   0x....             LDR.N    R0,??DataTable30_34
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x....             LDR.N    R3,??DataTable30_35
   \   0000000E   0x....             LDR.N    R2,??DataTable30_36
   \   00000010   0x....             LDR.N    R1,??DataTable30_37
   \   00000012   0x....             LDR.N    R0,??DataTable30_38
   \   00000014   0x.... 0x....      BL       dmp_read_fifo
   1125          	//ANBT_SEND_DMP_DATA(anbt_mpu6050_quat_data);
   1126          }
   \   00000018   0xBD07             POP      {R0-R2,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     st

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     st+0x10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x........         DC32     st

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x........         DC32     test

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x3EAE147B         DC32     0x3eae147b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_1:
   \   00000000   0x3F845A1D         DC32     0x3f845a1d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_2:
   \   00000000   0x43030000         DC32     0x43030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_3:
   \   00000000   0x42830000         DC32     0x42830000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_4:
   \   00000000   0x42033333         DC32     0x42033333

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_5:
   \   00000000   0x41833333         DC32     0x41833333

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_6:
   \   00000000   0xBF800000         DC32     0xbf800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_7:
   \   00000000   0x454CB000         DC32     0x454cb000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_8:
   \   00000000   0x3F85E354         DC32     0x3f85e354

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_9:
   \   00000000   0x........         DC32     st

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_10:
   \   00000000   0x........         DC32     `?<Constant "WHOAMI error">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_11:
   \   00000000   0x........         DC32     `?<Constant "Unsupported version=1.0">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_12:
   \   00000000   0x........         DC32     `?<Constant "Product ID error">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_13:
   \   00000000   0x........         DC32     `?<Constant "Half Sensitivity Part">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_14:
   \   00000000   0x........         DC32     st+0x16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_15:
   \   00000000   0x........         DC32     `?<Constant "P-1,Finish DMP device...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_16:
   \   00000000   0x........         DC32     `?<Constant "P-2,Finish DMP set se...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_17:
   \   00000000   0x........         DC32     `?<Constant "P-2,DMP set sensor er...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_18:
   \   00000000   0x........         DC32     `?<Constant "P-3,Finish DMP config...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_19:
   \   00000000   0x........         DC32     `?<Constant "P-3,DMP configure fif...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_20:
   \   00000000   0x........         DC32     `?<Constant "P-4,Finish DMP set sa...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_21:
   \   00000000   0x........         DC32     `?<Constant "P-4,DMP set sample_ra...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_22:
   \   00000000   0x........         DC32     `?<Constant "P-5,Finish DMP load m...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_23:
   \   00000000   0x........         DC32     `?<Constant "P-5,DMP load motion d...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_24:
   \   00000000   0x........         DC32     gyro_orientation

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_25:
   \   00000000   0x........         DC32     `?<Constant "P-6,Finish DMP set or...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_26:
   \   00000000   0x........         DC32     `?<Constant "P-6,DMP set orientati...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_27:
   \   00000000   0x........         DC32     `?<Constant "P-7,Finish DMP enable...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_28:
   \   00000000   0x........         DC32     `?<Constant "P-7,DMP enable featur...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_29:
   \   00000000   0x........         DC32     `?<Constant "P-8,Finish DMP set fi...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_30:
   \   00000000   0x........         DC32     `?<Constant "P-8,DMP set fifo rate...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_31:
   \   00000000   0x........         DC32     `?<Constant "P-9,Finish DMP set dm...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_32:
   \   00000000   0x........         DC32     `?<Constant "P-9,DMP set dmp state...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_33:
   \   00000000   0x........         DC32     more

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_34:
   \   00000000   0x........         DC32     sensors

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_35:
   \   00000000   0x........         DC32     sensor_timestamp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_36:
   \   00000000   0x........         DC32     anbt_mpu6050_quat_data

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_37:
   \   00000000   0x........         DC32     accel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_38:
   \   00000000   0x........         DC32     gyro

   \                                 In section .rodata, align 4
   \                     `?<Constant "WHOAMI error">`:
   \   00000000   0x57 0x48          DC8 "WHOAMI error"
   \              0x4F 0x41    
   \              0x4D 0x49    
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "Unsupported version=1.0">`:
   \   00000000   0x55 0x6E          DC8 "Unsupported version=1.0"
   \              0x73 0x75    
   \              0x70 0x70    
   \              0x6F 0x72    
   \              0x74 0x65    
   \              0x64 0x20    
   \              0x76 0x65    
   \              0x72 0x73    
   \              0x69 0x6F    
   \              0x6E 0x3D    
   \              0x31 0x2E    
   \              0x30 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "Product ID error">`:
   \   00000000   0x50 0x72          DC8 "Product ID error"
   \              0x6F 0x64    
   \              0x75 0x63    
   \              0x74 0x20    
   \              0x49 0x44    
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "Half Sensitivity Part">`:
   \   00000000   0x48 0x61          DC8 "Half Sensitivity Part"
   \              0x6C 0x66    
   \              0x20 0x53    
   \              0x65 0x6E    
   \              0x73 0x69    
   \              0x74 0x69    
   \              0x76 0x69    
   \              0x74 0x79    
   \              0x20 0x50    
   \              0x61 0x72    
   \              0x74 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "P-1,Finish DMP device...">`:
   \   00000000   0x50 0x2D          DC8 "P-1,Finish DMP device init."
   \              0x31 0x2C    
   \              0x46 0x69    
   \              0x6E 0x69    
   \              0x73 0x68    
   \              0x20 0x44    
   \              0x4D 0x50    
   \              0x20 0x64    
   \              0x65 0x76    
   \              0x69 0x63    
   \              0x65 0x20    
   \              0x69 0x6E    
   \              0x69 0x74    
   \              0x2E 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "P-2,Finish DMP set se...">`:
   \   00000000   0x50 0x2D          DC8 "P-2,Finish DMP set sensor."
   \              0x32 0x2C    
   \              0x46 0x69    
   \              0x6E 0x69    
   \              0x73 0x68    
   \              0x20 0x44    
   \              0x4D 0x50    
   \              0x20 0x73    
   \              0x65 0x74    
   \              0x20 0x73    
   \              0x65 0x6E    
   \              0x73 0x6F    
   \              0x72 0x2E    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "P-2,DMP set sensor er...">`:
   \   00000000   0x50 0x2D          DC8 "P-2,DMP set sensor error."
   \              0x32 0x2C    
   \              0x44 0x4D    
   \              0x50 0x20    
   \              0x73 0x65    
   \              0x74 0x20    
   \              0x73 0x65    
   \              0x6E 0x73    
   \              0x6F 0x72    
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x2E 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "P-3,Finish DMP config...">`:
   \   00000000   0x50 0x2D          DC8 "P-3,Finish DMP configure fifo."
   \              0x33 0x2C    
   \              0x46 0x69    
   \              0x6E 0x69    
   \              0x73 0x68    
   \              0x20 0x44    
   \              0x4D 0x50    
   \              0x20 0x63    
   \              0x6F 0x6E    
   \              0x66 0x69    
   \              0x67 0x75    
   \              0x72 0x65    
   \              0x20 0x66    
   \              0x69 0x66    
   \              0x6F 0x2E    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "P-3,DMP configure fif...">`:
   \   00000000   0x50 0x2D          DC8 "P-3,DMP configure fifo error."
   \              0x33 0x2C    
   \              0x44 0x4D    
   \              0x50 0x20    
   \              0x63 0x6F    
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x75 0x72    
   \              0x65 0x20    
   \              0x66 0x69    
   \              0x66 0x6F    
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x2E 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "P-4,Finish DMP set sa...">`:
   \   00000000   0x50 0x2D          DC8 "P-4,Finish DMP set sample rate."
   \              0x34 0x2C    
   \              0x46 0x69    
   \              0x6E 0x69    
   \              0x73 0x68    
   \              0x20 0x44    
   \              0x4D 0x50    
   \              0x20 0x73    
   \              0x65 0x74    
   \              0x20 0x73    
   \              0x61 0x6D    
   \              0x70 0x6C    
   \              0x65 0x20    
   \              0x72 0x61    
   \              0x74 0x65    
   \              0x2E 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "P-4,DMP set sample_ra...">`:
   \   00000000   0x50 0x2D          DC8 "P-4,DMP set sample_rate error."
   \              0x34 0x2C    
   \              0x44 0x4D    
   \              0x50 0x20    
   \              0x73 0x65    
   \              0x74 0x20    
   \              0x73 0x61    
   \              0x6D 0x70    
   \              0x6C 0x65    
   \              0x5F 0x72    
   \              0x61 0x74    
   \              0x65 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x2E    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "P-5,Finish DMP load m...">`:
   \   00000000   0x50 0x2D          DC8 "P-5,Finish DMP load motion driver firmware."
   \              0x35 0x2C    
   \              0x46 0x69    
   \              0x6E 0x69    
   \              0x73 0x68    
   \              0x20 0x44    
   \              0x4D 0x50    
   \              0x20 0x6C    
   \              0x6F 0x61    
   \              0x64 0x20    
   \              0x6D 0x6F    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x20 0x64    
   \              0x72 0x69    
   \              0x76 0x65    
   \              0x72 0x20    
   \              0x66 0x69    
   \              0x72 0x6D    
   \              0x77 0x61    
   \              0x72 0x65    
   \              0x2E 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "P-5,DMP load motion d...">`:
   \   00000000   0x50 0x2D          DC8 "P-5,DMP load motion driver firmware error."
   \              0x35 0x2C    
   \              0x44 0x4D    
   \              0x50 0x20    
   \              0x6C 0x6F    
   \              0x61 0x64    
   \              0x20 0x6D    
   \              0x6F 0x74    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x64 0x72    
   \              0x69 0x76    
   \              0x65 0x72    
   \              0x20 0x66    
   \              0x69 0x72    
   \              0x6D 0x77    
   \              0x61 0x72    
   \              0x65 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x2E    
   \              0x00         
   \   0000002B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "P-6,Finish DMP set or...">`:
   \   00000000   0x50 0x2D          DC8 "P-6,Finish DMP set orientation."
   \              0x36 0x2C    
   \              0x46 0x69    
   \              0x6E 0x69    
   \              0x73 0x68    
   \              0x20 0x44    
   \              0x4D 0x50    
   \              0x20 0x73    
   \              0x65 0x74    
   \              0x20 0x6F    
   \              0x72 0x69    
   \              0x65 0x6E    
   \              0x74 0x61    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x2E 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "P-6,DMP set orientati...">`:
   \   00000000   0x50 0x2D          DC8 "P-6,DMP set orientation error."
   \              0x36 0x2C    
   \              0x44 0x4D    
   \              0x50 0x20    
   \              0x73 0x65    
   \              0x74 0x20    
   \              0x6F 0x72    
   \              0x69 0x65    
   \              0x6E 0x74    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x2E    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "P-7,Finish DMP enable...">`:
   \   00000000   0x50 0x2D          DC8 "P-7,Finish DMP enable feature."
   \              0x37 0x2C    
   \              0x46 0x69    
   \              0x6E 0x69    
   \              0x73 0x68    
   \              0x20 0x44    
   \              0x4D 0x50    
   \              0x20 0x65    
   \              0x6E 0x61    
   \              0x62 0x6C    
   \              0x65 0x20    
   \              0x66 0x65    
   \              0x61 0x74    
   \              0x75 0x72    
   \              0x65 0x2E    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "P-7,DMP enable featur...">`:
   \   00000000   0x50 0x2D          DC8 "P-7,DMP enable feature error."
   \              0x37 0x2C    
   \              0x44 0x4D    
   \              0x50 0x20    
   \              0x65 0x6E    
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x20 0x66    
   \              0x65 0x61    
   \              0x74 0x75    
   \              0x72 0x65    
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x2E 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "P-8,Finish DMP set fi...">`:
   \   00000000   0x50 0x2D          DC8 "P-8,Finish DMP set fifo rate."
   \              0x38 0x2C    
   \              0x46 0x69    
   \              0x6E 0x69    
   \              0x73 0x68    
   \              0x20 0x44    
   \              0x4D 0x50    
   \              0x20 0x73    
   \              0x65 0x74    
   \              0x20 0x66    
   \              0x69 0x66    
   \              0x6F 0x20    
   \              0x72 0x61    
   \              0x74 0x65    
   \              0x2E 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "P-8,DMP set fifo rate...">`:
   \   00000000   0x50 0x2D          DC8 "P-8,DMP set fifo rate error."
   \              0x38 0x2C    
   \              0x44 0x4D    
   \              0x50 0x20    
   \              0x73 0x65    
   \              0x74 0x20    
   \              0x66 0x69    
   \              0x66 0x6F    
   \              0x20 0x72    
   \              0x61 0x74    
   \              0x65 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x2E    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "P-9,Finish DMP set dm...">`:
   \   00000000   0x50 0x2D          DC8 "P-9,Finish DMP set dmp state."
   \              0x39 0x2C    
   \              0x46 0x69    
   \              0x6E 0x69    
   \              0x73 0x68    
   \              0x20 0x44    
   \              0x4D 0x50    
   \              0x20 0x73    
   \              0x65 0x74    
   \              0x20 0x64    
   \              0x6D 0x70    
   \              0x20 0x73    
   \              0x74 0x61    
   \              0x74 0x65    
   \              0x2E 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "P-9,DMP set dmp state...">`:
   \   00000000   0x50 0x2D          DC8 "P-9,DMP set dmp state error."
   \              0x39 0x2C    
   \              0x44 0x4D    
   \              0x50 0x20    
   \              0x73 0x65    
   \              0x74 0x20    
   \              0x64 0x6D    
   \              0x70 0x20    
   \              0x73 0x74    
   \              0x61 0x74    
   \              0x65 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x2E    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1127          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  AnBT_DMP_MPU6050_DEV_CFG
             16 -> AnBT_DMP_Delay_ms
             16 -> AnBT_DMP_I2C_Read
             16 -> AnBT_DMP_I2C_Write
             16 -> AnBT_Uart1_Send_Num
             16 -> AnBT_Uart1_Send_String
             16 -> memset
             16 -> mpu_configure_fifo
             16 -> mpu_set_accel_fsr
             16 -> mpu_set_bypass
             16 -> mpu_set_gyro_fsr
             16 -> mpu_set_lpf
             16 -> mpu_set_sample_rate
             16 -> mpu_set_sensors
        8  AnBT_DMP_MPU6050_Init
              8 -> AnBT_DMP_MPU6050_DEV_CFG
              8 -> AnBT_Uart1_Send_String
              8 -> dmp_enable_feature
              8 -> dmp_load_motion_driver_firmware
              8 -> dmp_set_fifo_rate
              8 -> dmp_set_orientation
              8 -> inv_orientation_matrix_to_scalar
              8 -> mpu_configure_fifo
              8 -> mpu_set_dmp_state
              8 -> mpu_set_sample_rate
              8 -> mpu_set_sensors
              8 -> run_self_test
       16  AnBT_DMP_MPU6050_SEND_DATA_FUN
             16 -> dmp_read_fifo
       48  accel_self_test
             48 -> __aeabi_cdcmple
             48 -> __aeabi_cfcmpeq
             48 -> __aeabi_cfcmple
             48 -> __aeabi_f2d
             48 -> __aeabi_fadd
             48 -> __aeabi_fdiv
             48 -> __aeabi_i2f
             48 -> get_accel_prod_shift
             48 -> labs
       24  get_accel_prod_shift
             24 -> AnBT_DMP_I2C_Read
             24 -> __aeabi_fmul
       56  get_st_biases
             56 -> AnBT_DMP_Delay_ms
             56 -> AnBT_DMP_I2C_Read
             56 -> AnBT_DMP_I2C_Write
             56 -> __aeabi_ldivmod
       48  gyro_self_test
             48 -> AnBT_DMP_I2C_Read
             48 -> __aeabi_cdcmple
             48 -> __aeabi_cfcmple
             48 -> __aeabi_f2d
             48 -> __aeabi_fadd
             48 -> __aeabi_fdiv
             48 -> __aeabi_fmul
             48 -> __aeabi_i2f
             48 -> __aeabi_ui2f
             48 -> labs
       16  inv_orientation_matrix_to_scalar
             16 -> inv_row_2_scale
        0  inv_row_2_scale
       16  mpu_configure_fifo
             16 -> mpu_reset_fifo
             16 -> set_int_enable
        0  mpu_get_accel_fsr
        0  mpu_get_accel_sens
        0  mpu_get_fifo_config
        0  mpu_get_gyro_fsr
        0  mpu_get_gyro_sens
        0  mpu_get_lpf
        0  mpu_get_sample_rate
       48  mpu_load_firmware
             48 -> AnBT_DMP_I2C_Write
             48 -> memcmp
             48 -> mpu_read_mem
             48 -> mpu_write_mem
       16  mpu_lp_accel_mode
             16 -> AnBT_DMP_I2C_Write
             16 -> mpu_configure_fifo
             16 -> mpu_set_int_latched
             16 -> mpu_set_lpf
       24  mpu_read_fifo_stream
             24 -> AnBT_DMP_I2C_Read
             24 -> mpu_reset_fifo
       24  mpu_read_mem
             24 -> AnBT_DMP_I2C_Read
             24 -> AnBT_DMP_I2C_Write
        8  mpu_reset_fifo
              8 -> AnBT_DMP_Delay_ms
              8 -> AnBT_DMP_I2C_Write
       72  mpu_run_self_test
             72 -> accel_self_test
             72 -> get_st_biases
             72 -> gyro_self_test
             72 -> mpu_configure_fifo
             72 -> mpu_get_accel_fsr
             72 -> mpu_get_fifo_config
             72 -> mpu_get_gyro_fsr
             72 -> mpu_get_lpf
             72 -> mpu_get_sample_rate
             72 -> mpu_set_accel_fsr
             72 -> mpu_set_dmp_state
             72 -> mpu_set_gyro_fsr
             72 -> mpu_set_lpf
             72 -> mpu_set_sample_rate
             72 -> mpu_set_sensors
       16  mpu_set_accel_fsr
             16 -> AnBT_DMP_I2C_Write
       16  mpu_set_bypass
             16 -> AnBT_DMP_Delay_ms
             16 -> AnBT_DMP_I2C_Read
             16 -> AnBT_DMP_I2C_Write
       16  mpu_set_dmp_state
             16 -> AnBT_DMP_I2C_Write
             16 -> mpu_reset_fifo
             16 -> mpu_set_bypass
             16 -> mpu_set_sample_rate
             16 -> set_int_enable
       16  mpu_set_gyro_fsr
             16 -> AnBT_DMP_I2C_Write
       16  mpu_set_int_latched
             16 -> AnBT_DMP_I2C_Write
       16  mpu_set_lpf
             16 -> AnBT_DMP_I2C_Write
       16  mpu_set_sample_rate
             16 -> AnBT_DMP_I2C_Write
             16 -> mpu_lp_accel_mode
             16 -> mpu_set_lpf
       16  mpu_set_sensors
             16 -> AnBT_DMP_Delay_ms
             16 -> AnBT_DMP_I2C_Write
             16 -> mpu_set_int_latched
       24  mpu_write_mem
             24 -> AnBT_DMP_I2C_Write
       40  run_self_test
             40 -> __aeabi_f2iz
             40 -> __aeabi_fmul
             40 -> __aeabi_i2f
             40 -> dmp_set_accel_bias
             40 -> dmp_set_gyro_bias
             40 -> mpu_get_accel_sens
             40 -> mpu_get_gyro_sens
             40 -> mpu_run_self_test
       16  set_int_enable
             16 -> AnBT_DMP_I2C_Write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      24  ?<Constant "Half Sensitivity Part">
      28  ?<Constant "P-1,Finish DMP device...">
      28  ?<Constant "P-2,DMP set sensor er...">
      28  ?<Constant "P-2,Finish DMP set se...">
      32  ?<Constant "P-3,DMP configure fif...">
      32  ?<Constant "P-3,Finish DMP config...">
      32  ?<Constant "P-4,DMP set sample_ra...">
      32  ?<Constant "P-4,Finish DMP set sa...">
      44  ?<Constant "P-5,DMP load motion d...">
      44  ?<Constant "P-5,Finish DMP load m...">
      32  ?<Constant "P-6,DMP set orientati...">
      32  ?<Constant "P-6,Finish DMP set or...">
      32  ?<Constant "P-7,DMP enable featur...">
      32  ?<Constant "P-7,Finish DMP enable...">
      32  ?<Constant "P-8,DMP set fifo rate...">
      32  ?<Constant "P-8,Finish DMP set fi...">
      32  ?<Constant "P-9,DMP set dmp state...">
      32  ?<Constant "P-9,Finish DMP set dm...">
      20  ?<Constant "Product ID error">
      24  ?<Constant "Unsupported version=1.0">
      16  ?<Constant "WHOAMI error">
       4  ??DataTable16
       4  ??DataTable20
       4  ??DataTable27
       4  ??DataTable28
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_10
       4  ??DataTable30_11
       4  ??DataTable30_12
       4  ??DataTable30_13
       4  ??DataTable30_14
       4  ??DataTable30_15
       4  ??DataTable30_16
       4  ??DataTable30_17
       4  ??DataTable30_18
       4  ??DataTable30_19
       4  ??DataTable30_2
       4  ??DataTable30_20
       4  ??DataTable30_21
       4  ??DataTable30_22
       4  ??DataTable30_23
       4  ??DataTable30_24
       4  ??DataTable30_25
       4  ??DataTable30_26
       4  ??DataTable30_27
       4  ??DataTable30_28
       4  ??DataTable30_29
       4  ??DataTable30_3
       4  ??DataTable30_30
       4  ??DataTable30_31
       4  ??DataTable30_32
       4  ??DataTable30_33
       4  ??DataTable30_34
       4  ??DataTable30_35
       4  ??DataTable30_36
       4  ??DataTable30_37
       4  ??DataTable30_38
       4  ??DataTable30_4
       4  ??DataTable30_5
       4  ??DataTable30_6
       4  ??DataTable30_7
       4  ??DataTable30_8
       4  ??DataTable30_9
     536  AnBT_DMP_MPU6050_DEV_CFG
     252  AnBT_DMP_MPU6050_Init
      26  AnBT_DMP_MPU6050_SEND_DATA_FUN
       8  accel
     174  accel_self_test
      16  anbt_mpu6050_quat_data
     200  get_accel_prod_shift
    1216  get_st_biases
       8  gyro
      12  gyro_orientation
     274  gyro_self_test
      12  hw
      42  inv_orientation_matrix_to_scalar
      94  inv_row_2_scale
       1  more
     148  mpu_configure_fifo
      70  mpu_get_accel_fsr
      84  mpu_get_accel_sens
      12  mpu_get_fifo_config
      60  mpu_get_gyro_fsr
      66  mpu_get_gyro_sens
      74  mpu_get_lpf
      28  mpu_get_sample_rate
     242  mpu_load_firmware
     254  mpu_lp_accel_mode
     230  mpu_read_fifo_stream
     152  mpu_read_mem
     556  mpu_reset_fifo
     346  mpu_run_self_test
     156  mpu_set_accel_fsr
     390  mpu_set_bypass
     152  mpu_set_dmp_state
     162  mpu_set_gyro_fsr
     136  mpu_set_int_latched
     164  mpu_set_lpf
     196  mpu_set_sample_rate
     232  mpu_set_sensors
     152  mpu_write_mem
      28  reg
     130  run_self_test
       4  sensor_timestamp
       2  sensors
     188  set_int_enable
      44  st
      40  test

 
    39 bytes in section .bss
    56 bytes in section .data
   720 bytes in section .rodata
 7 366 bytes in section .text
 
 7 366 bytes of CODE  memory
   720 bytes of CONST memory
    95 bytes of DATA  memory

Errors: none
Warnings: none
