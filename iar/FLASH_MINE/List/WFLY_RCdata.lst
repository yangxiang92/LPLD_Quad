###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     08/Aug/2014  19:52:18 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\source\app\ #
#                    SignalProcess\WFLY_RCdata.c                              #
#    Command line =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\source\app\ #
#                    SignalProcess\WFLY_RCdata.c -D LPLD_K60 -lCN             #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\FLASH_M #
#                    INE\List\ -lB E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_ #
#                    V3\iar\FLASH_MINE\List\ -o E:\ShawnDocuments\IAR_WorkSpa #
#                    ce\LPLD_Quad_V3\iar\FLASH_MINE\Obj\ --no_cse             #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\app\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\ #
#                    iar\..\source\app\Control\ -I                            #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\app\Others\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Q #
#                    uad_V3\iar\..\source\app\Communicate\ -I                 #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\app\Algorithm\ -I E:\ShawnDocuments\IAR_WorkSpace\LPL #
#                    D_Quad_V3\iar\..\source\app\SignalProcess\ -I            #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\module\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_ #
#                    V3\iar\..\source\module\anbt_dmp\ -I                     #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\module\eMPL\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_ #
#                    Quad_V3\iar\..\source\lib\CPU\ -I                        #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\common\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Q #
#                    uad_V3\iar\..\source\lib\LPLD\ -I                        #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\LPLD\HW\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_ #
#                    Quad_V3\iar\..\source\lib\LPLD\DEV\ -I                   #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\uCOS-II\Ports\ -I E:\ShawnDocuments\IAR_WorkSpace #
#                    \LPLD_Quad_V3\iar\..\source\lib\uCOS-II\Source\ -I       #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\FatFs\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Qu #
#                    ad_V3\iar\..\source\lib\FatFs\option\ -I                 #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\USB\common\ -I E:\ShawnDocuments\IAR_WorkSpace\LP #
#                    LD_Quad_V3\iar\..\source\lib\USB\driver\ -I              #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\USB\descriptor\ -I E:\ShawnDocuments\IAR_WorkSpac #
#                    e\LPLD_Quad_V3\iar\..\source\lib\USB\class\ -I           #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\MyLib\ -On -I "D:\Program Files\IAR               #
#                    Systems\Embedded Workbench 6.4\arm\CMSIS\Include\" -D    #
#                    ARM_MATH_CM4                                             #
#    List file    =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\FLASH_M #
#                    INE\List\WFLY_RCdata.lst                                 #
#    Object file  =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\FLASH_M #
#                    INE\Obj\WFLY_RCdata.o                                    #
#                                                                             #
#                                                                             #
###############################################################################

E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\source\app\SignalProcess\WFLY_RCdata.c
      1          /****************************************************************************** 
      2           *       WFLY_RCdata.c ----- The Program to process the data from the WFLY RC       *
      3           *       (c) Copyright 2012 HUST RENESAS LAB,The Department of CSE, HUST       *
      4           *                        All Rights Reserved                                  *
      5           *Filename             :  WFLY_RCdata.c                                           *
      6           *Programmer(s)        :  Yang Xiang                                           *
      7           *Description          :                                                       *
      8           *Modification History :                                                       *
      9           *01a 2014/4/28 20:03:04                                                       *
     10           ******************************************************************************/
     11          #include "WFLY_RCdata.h"
     12          

   \                                 In section .data, align 4
     13          uint32 g_u32WFLY_RC_offset[4] = {1520, 1520, 1520, 1520};
   \                     g_u32WFLY_RC_offset:
   \   00000000   0x000005F0         DC32 1520, 1520, 1520, 1520
   \              0x000005F0   
   \              0x000005F0   
   \              0x000005F0   

   \                                 In section .data, align 4
     14          uint32 g_u32WFLY_RC_max_range[4] = {798, 736, 760, 754};
   \                     g_u32WFLY_RC_max_range:
   \   00000000   0x0000031E         DC32 798, 736, 760, 754
   \              0x000002E0   
   \              0x000002F8   
   \              0x000002F2   
     15          

   \                                 In section .rodata, align 4
     16          extern const float gc_f32MaxRCYawAngle = 10;
   \                     gc_f32MaxRCYawAngle:
   \   00000000   0x41200000         DC32 41200000H

   \                                 In section .rodata, align 4
     17          extern const float gc_f32MaxRCPitchAngle = 10;
   \                     gc_f32MaxRCPitchAngle:
   \   00000000   0x41200000         DC32 41200000H

   \                                 In section .rodata, align 4
     18          extern const float gc_f32MaxRCRollAngle = 10;
   \                     gc_f32MaxRCRollAngle:
   \   00000000   0x41200000         DC32 41200000H

   \                                 In section .rodata, align 4
     19          extern const float gc_f32MaxRCThrottle = 0.7;
   \                     gc_f32MaxRCThrottle:
   \   00000000   0x3F333333         DC32 3F333333H

   \                                 In section .rodata, align 4
     20          extern const float gc_f32MaxRCHeight = 1.5;
   \                     gc_f32MaxRCHeight:
   \   00000000   0x3FC00000         DC32 3FC00000H
     21          

   \                                 In section .rodata, align 4
     22          extern const float gc_f32RCThrottleDeadZone = 0.1;
   \                     gc_f32RCThrottleDeadZone:
   \   00000000   0x3DCCCCCD         DC32 3DCCCCCDH
     23          

   \                                 In section .text, align 2, keep-with-next
     24          void WFLY_RC_GetOffset(void)
     25          {
   \                     WFLY_RC_GetOffset:
   \   00000000   0xB53F             PUSH     {R0-R5,LR}
     26              int i = 0;
   \   00000002   0x2400             MOVS     R4,#+0
     27              int j = 0;
   \   00000004   0x2500             MOVS     R5,#+0
     28              uint32 WFLY_RC_offset_sum[4] = {0,0,0,0};
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x2110             MOVS     R1,#+16
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr4
     29          
     30              for(i = 0; i < WFLY_RC_OFFSET_SAMPLE_AMOUNT; i++)
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x0004             MOVS     R4,R0
   \                     ??WFLY_RC_GetOffset_0:
   \   00000012   0x2C0A             CMP      R4,#+10
   \   00000014   0xDA1B             BGE.N    ??WFLY_RC_GetOffset_1
     31              {
     32                  g_u32TimerMsCnt = 0;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable9
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x6001             STR      R1,[R0, #+0]
     33                  for(j = 0; j < 4; j++)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x0005             MOVS     R5,R0
   \                     ??WFLY_RC_GetOffset_2:
   \   00000022   0x2D04             CMP      R5,#+4
   \   00000024   0xDA0C             BGE.N    ??WFLY_RC_GetOffset_3
     34                  {
     35                      WFLY_RC_offset_sum[j] += g_WFLY_RC_pluse_width_us[j];
   \   00000026   0xA800             ADD      R0,SP,#+0
   \   00000028   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   00000030   0xF851 0x1025      LDR      R1,[R1, R5, LSL #+2]
   \   00000034   0x1808             ADDS     R0,R1,R0
   \   00000036   0xA900             ADD      R1,SP,#+0
   \   00000038   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
     36                  }
   \   0000003C   0x1C6D             ADDS     R5,R5,#+1
   \   0000003E   0xE7F0             B.N      ??WFLY_RC_GetOffset_2
     37                  while(g_u32TimerMsCnt < WFLY_RC_OFFSET_SAMPLE_PERIOD_MS);
   \                     ??WFLY_RC_GetOffset_3:
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x2814             CMP      R0,#+20
   \   00000048   0xD3FA             BCC.N    ??WFLY_RC_GetOffset_3
     38              }
   \   0000004A   0x1C64             ADDS     R4,R4,#+1
   \   0000004C   0xE7E1             B.N      ??WFLY_RC_GetOffset_0
     39          
     40              for(j = 0; j < 4; j++)
   \                     ??WFLY_RC_GetOffset_1:
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x0005             MOVS     R5,R0
   \                     ??WFLY_RC_GetOffset_4:
   \   00000052   0x2D04             CMP      R5,#+4
   \   00000054   0xDA0B             BGE.N    ??WFLY_RC_GetOffset_5
     41              {
     42                  g_u32WFLY_RC_offset[j] = WFLY_RC_offset_sum[j] / WFLY_RC_OFFSET_SAMPLE_AMOUNT;
   \   00000056   0xA800             ADD      R0,SP,#+0
   \   00000058   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000005C   0x210A             MOVS     R1,#+10
   \   0000005E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \   00000066   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
     43              }
   \   0000006A   0x1C6D             ADDS     R5,R5,#+1
   \   0000006C   0xE7F1             B.N      ??WFLY_RC_GetOffset_4
     44          }
   \                     ??WFLY_RC_GetOffset_5:
   \   0000006E   0xBD3F             POP      {R0-R5,PC}       ;; return
     45          

   \                                 In section .text, align 2, keep-with-next
     46          void WFLY_RC_GetMaxRange(void)
     47          {
   \                     WFLY_RC_GetMaxRange:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
     48              int i = 0;
   \   00000004   0x2400             MOVS     R4,#+0
     49          
     50              int32 positive_max_range[4] = {0,0,0,0};
   \   00000006   0xA808             ADD      R0,SP,#+32
   \   00000008   0x2110             MOVS     R1,#+16
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr4
     51              int32 negative_max_range[4] = {0,0,0,0};
   \   0000000E   0xA804             ADD      R0,SP,#+16
   \   00000010   0x2110             MOVS     R1,#+16
   \   00000012   0x.... 0x....      BL       __aeabi_memclr4
     52          
     53              int32 pluse_width_err[4] = {0,0,0,0};
   \   00000016   0xA800             ADD      R0,SP,#+0
   \   00000018   0x2110             MOVS     R1,#+16
   \   0000001A   0x.... 0x....      BL       __aeabi_memclr4
     54          
     55              SetLightsOnOff(GETTING_WFLY_RC_MAX_RANGE_LED_HINT);
   \   0000001E   0x20F5             MOVS     R0,#+245
   \   00000020   0x.... 0x....      BL       SetLightsOnOff
     56          
     57              while(!ReadSwitches(GET_WFLY_RC_OFFSET_SWITCH_BIT_MASK))
   \                     ??WFLY_RC_GetMaxRange_0:
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0x.... 0x....      BL       ReadSwitches
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD12B             BNE.N    ??WFLY_RC_GetMaxRange_1
     58              {
     59                  for(i = 0; i < 4; i++)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x0004             MOVS     R4,R0
   \                     ??WFLY_RC_GetMaxRange_2:
   \   00000032   0x2C04             CMP      R4,#+4
   \   00000034   0xDAF6             BGE.N    ??WFLY_RC_GetMaxRange_0
     60                  {
     61                      pluse_width_err[i] = (int32)g_WFLY_RC_pluse_width_us[i] - (int32)g_u32WFLY_RC_offset[i];
   \   00000036   0x....             LDR.N    R0,??DataTable9_1
   \   00000038   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000003C   0x....             LDR.N    R1,??DataTable9_2
   \   0000003E   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000042   0x1A40             SUBS     R0,R0,R1
   \   00000044   0xA900             ADD      R1,SP,#+0
   \   00000046   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
     62                      if(pluse_width_err[i] > positive_max_range[i])
   \   0000004A   0xA808             ADD      R0,SP,#+32
   \   0000004C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000050   0xA900             ADD      R1,SP,#+0
   \   00000052   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000056   0x4288             CMP      R0,R1
   \   00000058   0xDA05             BGE.N    ??WFLY_RC_GetMaxRange_3
     63                      {
     64                          positive_max_range[i] = pluse_width_err[i];
   \   0000005A   0xA808             ADD      R0,SP,#+32
   \   0000005C   0xA900             ADD      R1,SP,#+0
   \   0000005E   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000062   0xF840 0x1024      STR      R1,[R0, R4, LSL #+2]
     65                      }
     66                      if(pluse_width_err[i] < negative_max_range[i])
   \                     ??WFLY_RC_GetMaxRange_3:
   \   00000066   0xA800             ADD      R0,SP,#+0
   \   00000068   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000006C   0xA904             ADD      R1,SP,#+16
   \   0000006E   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000072   0x4288             CMP      R0,R1
   \   00000074   0xDA05             BGE.N    ??WFLY_RC_GetMaxRange_4
     67                      {
     68                          negative_max_range[i] = pluse_width_err[i];
   \   00000076   0xA804             ADD      R0,SP,#+16
   \   00000078   0xA900             ADD      R1,SP,#+0
   \   0000007A   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000007E   0xF840 0x1024      STR      R1,[R0, R4, LSL #+2]
     69                      }
     70                  }
   \                     ??WFLY_RC_GetMaxRange_4:
   \   00000082   0x1C64             ADDS     R4,R4,#+1
   \   00000084   0xE7D5             B.N      ??WFLY_RC_GetMaxRange_2
     71              }
     72          
     73              for(i = 0; i < 4; i++)
   \                     ??WFLY_RC_GetMaxRange_1:
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x0004             MOVS     R4,R0
   \                     ??WFLY_RC_GetMaxRange_5:
   \   0000008A   0x2C04             CMP      R4,#+4
   \   0000008C   0xDA19             BGE.N    ??WFLY_RC_GetMaxRange_6
     74              {
     75                  if(positive_max_range[i] >= (-negative_max_range[i]))
   \   0000008E   0xA808             ADD      R0,SP,#+32
   \   00000090   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000094   0xA904             ADD      R1,SP,#+16
   \   00000096   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000009A   0x42C8             CMN      R0,R1
   \   0000009C   0xDB08             BLT.N    ??WFLY_RC_GetMaxRange_7
     76                  {
     77                      g_u32WFLY_RC_max_range[i] = (-negative_max_range[i]) * 2;
   \   0000009E   0xA804             ADD      R0,SP,#+16
   \   000000A0   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000000A4   0x4240             RSBS     R0,R0,#+0
   \   000000A6   0x0040             LSLS     R0,R0,#+1
   \   000000A8   0x....             LDR.N    R1,??DataTable9_3
   \   000000AA   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
   \   000000AE   0xE006             B.N      ??WFLY_RC_GetMaxRange_8
     78                  }
     79                  else
     80                  {
     81                      g_u32WFLY_RC_max_range[i] = positive_max_range[i] * 2;
   \                     ??WFLY_RC_GetMaxRange_7:
   \   000000B0   0xA808             ADD      R0,SP,#+32
   \   000000B2   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000000B6   0x0040             LSLS     R0,R0,#+1
   \   000000B8   0x....             LDR.N    R1,??DataTable9_3
   \   000000BA   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
     82                  }
     83              }
   \                     ??WFLY_RC_GetMaxRange_8:
   \   000000BE   0x1C64             ADDS     R4,R4,#+1
   \   000000C0   0xE7E3             B.N      ??WFLY_RC_GetMaxRange_5
     84          
     85              g_u32WFLY_RC_max_range[THROTTLE_CHANNEL] = positive_max_range[THROTTLE_CHANNEL]; 
   \                     ??WFLY_RC_GetMaxRange_6:
   \   000000C2   0x....             LDR.N    R0,??DataTable9_3
   \   000000C4   0x990A             LDR      R1,[SP, #+40]
   \   000000C6   0x6081             STR      R1,[R0, #+8]
     86          }
   \   000000C8   0xB00C             ADD      SP,SP,#+48
   \   000000CA   0xBD10             POP      {R4,PC}          ;; return
     87          

   \                                 In section .text, align 2, keep-with-next
     88          void WFLY_RC_GetOffsetOpe(void)
     89          {
   \                     WFLY_RC_GetOffsetOpe:
   \   00000000   0xB580             PUSH     {R7,LR}
     90          #ifdef GET_WFLY_RC_OFFSET_WITH_BUZZER_HINT
     91              SetBuzzerMode(1);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       SetBuzzerMode
     92              DelayWithTimer(GET_WFLY_RC_OFFSET_WARNING_TIME_MS);
   \   00000008   0xF44F 0x707A      MOV      R0,#+1000
   \   0000000C   0x.... 0x....      BL       DelayWithTimer
     93              SetBuzzerMode(0);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      BL       SetBuzzerMode
     94              WFLY_RC_GetOffset();
   \   00000016   0x.... 0x....      BL       WFLY_RC_GetOffset
     95              SetBuzzerMode(1);
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x.... 0x....      BL       SetBuzzerMode
     96              DelayWithTimer(GET_WFLY_RC_OFFSET_WARNING_TIME_MS);
   \   00000020   0xF44F 0x707A      MOV      R0,#+1000
   \   00000024   0x.... 0x....      BL       DelayWithTimer
     97              SetBuzzerMode(0);           
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      BL       SetBuzzerMode
     98          #else
     99              WFLY_RC_GetOffset();
    100          #endif
    101              while(!WFLY_RC_CheckOffsetValid())
   \                     ??WFLY_RC_GetOffsetOpe_0:
   \   0000002E   0x.... 0x....      BL       WFLY_RC_CheckOffsetValid
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD103             BNE.N    ??WFLY_RC_GetOffsetOpe_1
    102              {
    103                  SetBuzzerMode(1);
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x.... 0x....      BL       SetBuzzerMode
   \   0000003C   0xE7F7             B.N      ??WFLY_RC_GetOffsetOpe_0
    104              }
    105          }
   \                     ??WFLY_RC_GetOffsetOpe_1:
   \   0000003E   0xBD01             POP      {R0,PC}          ;; return
    106          

   \                                 In section .text, align 2, keep-with-next
    107          void WFLY_RC_GetMaxRangeOpe(void)
    108          {
   \                     WFLY_RC_GetMaxRangeOpe:
   \   00000000   0xB580             PUSH     {R7,LR}
    109          #ifdef GET_WFLY_RC_OFFSET_WITH_BUZZER_HINT
    110              SetBuzzerMode(1);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       SetBuzzerMode
    111              DelayWithTimer(GET_WFLY_RC_OFFSET_WARNING_TIME_MS);
   \   00000008   0xF44F 0x707A      MOV      R0,#+1000
   \   0000000C   0x.... 0x....      BL       DelayWithTimer
    112              SetBuzzerMode(0);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      BL       SetBuzzerMode
    113              WFLY_RC_GetMaxRange();
   \   00000016   0x.... 0x....      BL       WFLY_RC_GetMaxRange
    114              SetBuzzerMode(1);
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x.... 0x....      BL       SetBuzzerMode
    115              DelayWithTimer(GET_WFLY_RC_OFFSET_WARNING_TIME_MS);
   \   00000020   0xF44F 0x707A      MOV      R0,#+1000
   \   00000024   0x.... 0x....      BL       DelayWithTimer
    116              SetBuzzerMode(0);           
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      BL       SetBuzzerMode
    117          #else
    118              WFLY_RC_GetMaxRange();
    119          #endif
    120              while(!WFLY_RC_CheckMaxRangeValid())
   \                     ??WFLY_RC_GetMaxRangeOpe_0:
   \   0000002E   0x.... 0x....      BL       WFLY_RC_CheckMaxRangeValid
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD103             BNE.N    ??WFLY_RC_GetMaxRangeOpe_1
    121              {
    122                  SetBuzzerMode(1);
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x.... 0x....      BL       SetBuzzerMode
   \   0000003C   0xE7F7             B.N      ??WFLY_RC_GetMaxRangeOpe_0
    123              }    
    124          }
   \                     ??WFLY_RC_GetMaxRangeOpe_1:
   \   0000003E   0xBD01             POP      {R0,PC}          ;; return
    125          

   \                                 In section .text, align 2, keep-with-next
    126          uint8 WFLY_RC_CheckOffsetValid(void)
    127          {
    128              uint8 success = 0;
   \                     WFLY_RC_CheckOffsetValid:
   \   00000000   0x2000             MOVS     R0,#+0
    129          
    130              if((g_u32WFLY_RC_offset[THROTTLE_CHANNEL] <= WFLY_RC_MAX_THROTTLE_OFFSET) && (g_u32WFLY_RC_offset[THROTTLE_CHANNEL] >= WFLY_RC_MIN_THROTTLE_OFFSET))
   \   00000002   0x....             LDR.N    R1,??DataTable9_2
   \   00000004   0x6889             LDR      R1,[R1, #+8]
   \   00000006   0xF5B1 0x6FFA      CMP      R1,#+2000
   \   0000000A   0xD807             BHI.N    ??WFLY_RC_CheckOffsetValid_0
   \   0000000C   0x....             LDR.N    R1,??DataTable9_2
   \   0000000E   0x6889             LDR      R1,[R1, #+8]
   \   00000010   0xF5B1 0x6FE1      CMP      R1,#+1800
   \   00000014   0xD302             BCC.N    ??WFLY_RC_CheckOffsetValid_0
    131              {
    132                  success = 1;
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x0008             MOVS     R0,R1
   \   0000001A   0xE001             B.N      ??WFLY_RC_CheckOffsetValid_1
    133              }
    134              else
    135              {
    136                  success = 0;
   \                     ??WFLY_RC_CheckOffsetValid_0:
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x0008             MOVS     R0,R1
    137              }
    138          
    139              if((g_u32WFLY_RC_offset[YAW_CHANNEL] <= WFLY_RC_MAX_YAW_OFFSET) && (g_u32WFLY_RC_offset[YAW_CHANNEL] >= WFLY_RC_MIN_YAW_OFFSET))
   \                     ??WFLY_RC_CheckOffsetValid_1:
   \   00000020   0x....             LDR.N    R1,??DataTable9_2
   \   00000022   0x68C9             LDR      R1,[R1, #+12]
   \   00000024   0xF5B1 0x6FC8      CMP      R1,#+1600
   \   00000028   0xD807             BHI.N    ??WFLY_RC_CheckOffsetValid_2
   \   0000002A   0x....             LDR.N    R1,??DataTable9_2
   \   0000002C   0x68C9             LDR      R1,[R1, #+12]
   \   0000002E   0xF5B1 0x6FAF      CMP      R1,#+1400
   \   00000032   0xD302             BCC.N    ??WFLY_RC_CheckOffsetValid_2
    140              {
    141                  success = 1;
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x0008             MOVS     R0,R1
   \   00000038   0xE001             B.N      ??WFLY_RC_CheckOffsetValid_3
    142              }
    143              else
    144              {
    145                  success = 0;
   \                     ??WFLY_RC_CheckOffsetValid_2:
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x0008             MOVS     R0,R1
    146              }
    147          
    148              if((g_u32WFLY_RC_offset[PITCH_CHANNEL] <= WFLY_RC_MAX_PITCH_OFFSET) && (g_u32WFLY_RC_offset[PITCH_CHANNEL] >= WFLY_RC_MIN_PITCH_OFFSET))
   \                     ??WFLY_RC_CheckOffsetValid_3:
   \   0000003E   0x....             LDR.N    R1,??DataTable9_2
   \   00000040   0x6849             LDR      R1,[R1, #+4]
   \   00000042   0xF5B1 0x6FC8      CMP      R1,#+1600
   \   00000046   0xD807             BHI.N    ??WFLY_RC_CheckOffsetValid_4
   \   00000048   0x....             LDR.N    R1,??DataTable9_2
   \   0000004A   0x6849             LDR      R1,[R1, #+4]
   \   0000004C   0xF5B1 0x6FAF      CMP      R1,#+1400
   \   00000050   0xD302             BCC.N    ??WFLY_RC_CheckOffsetValid_4
    149              {
    150                  success = 1;
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x0008             MOVS     R0,R1
   \   00000056   0xE001             B.N      ??WFLY_RC_CheckOffsetValid_5
    151              }
    152              else
    153              {
    154                  success = 0;
   \                     ??WFLY_RC_CheckOffsetValid_4:
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0x0008             MOVS     R0,R1
    155              }
    156          
    157              if((g_u32WFLY_RC_offset[ROLL_CHANNEL] <= WFLY_RC_MAX_ROLL_OFFSET) && (g_u32WFLY_RC_offset[ROLL_CHANNEL] >= WFLY_RC_MIN_ROLL_OFFSET))
   \                     ??WFLY_RC_CheckOffsetValid_5:
   \   0000005C   0x....             LDR.N    R1,??DataTable9_2
   \   0000005E   0x6809             LDR      R1,[R1, #+0]
   \   00000060   0xF5B1 0x6FC8      CMP      R1,#+1600
   \   00000064   0xD807             BHI.N    ??WFLY_RC_CheckOffsetValid_6
   \   00000066   0x....             LDR.N    R1,??DataTable9_2
   \   00000068   0x6809             LDR      R1,[R1, #+0]
   \   0000006A   0xF5B1 0x6FAF      CMP      R1,#+1400
   \   0000006E   0xD302             BCC.N    ??WFLY_RC_CheckOffsetValid_6
    158              {
    159                  success = 1;
   \   00000070   0x2101             MOVS     R1,#+1
   \   00000072   0x0008             MOVS     R0,R1
   \   00000074   0xE001             B.N      ??WFLY_RC_CheckOffsetValid_7
    160              }
    161              else
    162              {
    163                  success = 0;
   \                     ??WFLY_RC_CheckOffsetValid_6:
   \   00000076   0x2100             MOVS     R1,#+0
   \   00000078   0x0008             MOVS     R0,R1
    164              }
    165          
    166              return success;
   \                     ??WFLY_RC_CheckOffsetValid_7:
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0x4770             BX       LR               ;; return
    167          }
    168          

   \                                 In section .text, align 2, keep-with-next
    169          uint8 WFLY_RC_CheckMaxRangeValid(void)
    170          {
    171              int i = 0;
   \                     WFLY_RC_CheckMaxRangeValid:
   \   00000000   0x2100             MOVS     R1,#+0
    172          
    173              for(i = 0; i < 4; i++)
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x0001             MOVS     R1,R0
   \                     ??WFLY_RC_CheckMaxRangeValid_0:
   \   00000006   0x2904             CMP      R1,#+4
   \   00000008   0xDA09             BGE.N    ??WFLY_RC_CheckMaxRangeValid_1
    174              {
    175                  if(g_u32WFLY_RC_max_range[i] < 400)
   \   0000000A   0x....             LDR.N    R0,??DataTable9_3
   \   0000000C   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000010   0xF5B0 0x7FC8      CMP      R0,#+400
   \   00000014   0xD201             BCS.N    ??WFLY_RC_CheckMaxRangeValid_2
    176                  {
    177                      return 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE002             B.N      ??WFLY_RC_CheckMaxRangeValid_3
    178                  }
    179              }
   \                     ??WFLY_RC_CheckMaxRangeValid_2:
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \   0000001C   0xE7F3             B.N      ??WFLY_RC_CheckMaxRangeValid_0
    180          
    181              return 1;
   \                     ??WFLY_RC_CheckMaxRangeValid_1:
   \   0000001E   0x2001             MOVS     R0,#+1
   \                     ??WFLY_RC_CheckMaxRangeValid_3:
   \   00000020   0x4770             BX       LR               ;; return
    182          }
    183          

   \                                 In section .text, align 2, keep-with-next
    184          float WFLY_RC_GetThrottleRatio(void)
    185          {
   \                     WFLY_RC_GetThrottleRatio:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    186              float throttle_ratio = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    187          
    188              throttle_ratio = ((float)g_WFLY_RC_pluse_width_us[THROTTLE_CHANNEL] - (float)g_u32WFLY_RC_offset[THROTTLE_CHANNEL]) / (float)g_u32WFLY_RC_max_range[THROTTLE_CHANNEL];
   \   00000004   0x....             LDR.N    R0,??DataTable9_1
   \   00000006   0x6880             LDR      R0,[R0, #+8]
   \   00000008   0x.... 0x....      BL       __aeabi_ui2f
   \   0000000C   0x0005             MOVS     R5,R0
   \   0000000E   0x....             LDR.N    R0,??DataTable9_2
   \   00000010   0x6880             LDR      R0,[R0, #+8]
   \   00000012   0x.... 0x....      BL       __aeabi_ui2f
   \   00000016   0x0001             MOVS     R1,R0
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       __aeabi_fsub
   \   0000001E   0x0005             MOVS     R5,R0
   \   00000020   0x....             LDR.N    R0,??DataTable9_3
   \   00000022   0x6880             LDR      R0,[R0, #+8]
   \   00000024   0x.... 0x....      BL       __aeabi_ui2f
   \   00000028   0x0001             MOVS     R1,R0
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000030   0x0004             MOVS     R4,R0
    189          
    190              throttle_ratio = WFLY_RC_CheckRatioValid(throttle_ratio);
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       WFLY_RC_CheckRatioValid
   \   00000038   0x0004             MOVS     R4,R0
    191          
    192              if(throttle_ratio < 0)
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000042   0xD201             BCS.N    ??WFLY_RC_GetThrottleRatio_0
    193              {
    194                  throttle_ratio = 0;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x0004             MOVS     R4,R0
    195              }
    196          
    197              return throttle_ratio;
   \                     ??WFLY_RC_GetThrottleRatio_0:
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    198          }
    199          

   \                                 In section .text, align 2, keep-with-next
    200          float WFLY_RC_GetYawRatio(void)
    201          {
   \                     WFLY_RC_GetYawRatio:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    202              float yaw_ratio = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    203          
    204              yaw_ratio = ((float)g_WFLY_RC_pluse_width_us[YAW_CHANNEL] - (float)g_u32WFLY_RC_offset[YAW_CHANNEL]) / ((float)g_u32WFLY_RC_max_range[YAW_CHANNEL] / 2);
   \   00000004   0x....             LDR.N    R0,??DataTable9_1
   \   00000006   0x68C0             LDR      R0,[R0, #+12]
   \   00000008   0x.... 0x....      BL       __aeabi_ui2f
   \   0000000C   0x0005             MOVS     R5,R0
   \   0000000E   0x....             LDR.N    R0,??DataTable9_2
   \   00000010   0x68C0             LDR      R0,[R0, #+12]
   \   00000012   0x.... 0x....      BL       __aeabi_ui2f
   \   00000016   0x0001             MOVS     R1,R0
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       __aeabi_fsub
   \   0000001E   0x0005             MOVS     R5,R0
   \   00000020   0x....             LDR.N    R0,??DataTable9_3
   \   00000022   0x68C0             LDR      R0,[R0, #+12]
   \   00000024   0x.... 0x....      BL       __aeabi_ui2f
   \   00000028   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   0000002C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000030   0x0001             MOVS     R1,R0
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x.... 0x....      BL       __aeabi_fdiv
   \   00000038   0x0004             MOVS     R4,R0
    205          
    206              yaw_ratio = WFLY_RC_CheckRatioValid(yaw_ratio);
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       WFLY_RC_CheckRatioValid
   \   00000040   0x0004             MOVS     R4,R0
    207          
    208              return yaw_ratio;
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    209          }
    210          

   \                                 In section .text, align 2, keep-with-next
    211          float WFLY_RC_GetPitchRatio(void)
    212          {
   \                     WFLY_RC_GetPitchRatio:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    213              float pitch_ratio = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    214          
    215              pitch_ratio = ((float)g_WFLY_RC_pluse_width_us[PITCH_CHANNEL] - (float)g_u32WFLY_RC_offset[PITCH_CHANNEL]) / ((float)g_u32WFLY_RC_max_range[PITCH_CHANNEL] / 2);
   \   00000004   0x....             LDR.N    R0,??DataTable9_1
   \   00000006   0x6840             LDR      R0,[R0, #+4]
   \   00000008   0x.... 0x....      BL       __aeabi_ui2f
   \   0000000C   0x0005             MOVS     R5,R0
   \   0000000E   0x....             LDR.N    R0,??DataTable9_2
   \   00000010   0x6840             LDR      R0,[R0, #+4]
   \   00000012   0x.... 0x....      BL       __aeabi_ui2f
   \   00000016   0x0001             MOVS     R1,R0
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       __aeabi_fsub
   \   0000001E   0x0005             MOVS     R5,R0
   \   00000020   0x....             LDR.N    R0,??DataTable9_3
   \   00000022   0x6840             LDR      R0,[R0, #+4]
   \   00000024   0x.... 0x....      BL       __aeabi_ui2f
   \   00000028   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   0000002C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000030   0x0001             MOVS     R1,R0
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x.... 0x....      BL       __aeabi_fdiv
   \   00000038   0x0004             MOVS     R4,R0
    216          
    217              pitch_ratio = WFLY_RC_CheckRatioValid(pitch_ratio);
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       WFLY_RC_CheckRatioValid
   \   00000040   0x0004             MOVS     R4,R0
    218          
    219              return pitch_ratio;
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    220          }
    221          

   \                                 In section .text, align 2, keep-with-next
    222          float WFLY_RC_GetRollRatio(void)
    223          {
   \                     WFLY_RC_GetRollRatio:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    224              float roll_ratio = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    225          
    226              roll_ratio = ((float)g_WFLY_RC_pluse_width_us[ROLL_CHANNEL] - (float)g_u32WFLY_RC_offset[ROLL_CHANNEL]) / ((float)g_u32WFLY_RC_max_range[ROLL_CHANNEL] / 2);
   \   00000004   0x....             LDR.N    R0,??DataTable9_1
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x.... 0x....      BL       __aeabi_ui2f
   \   0000000C   0x0005             MOVS     R5,R0
   \   0000000E   0x....             LDR.N    R0,??DataTable9_2
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x.... 0x....      BL       __aeabi_ui2f
   \   00000016   0x0001             MOVS     R1,R0
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       __aeabi_fsub
   \   0000001E   0x0005             MOVS     R5,R0
   \   00000020   0x....             LDR.N    R0,??DataTable9_3
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x.... 0x....      BL       __aeabi_ui2f
   \   00000028   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   0000002C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000030   0x0001             MOVS     R1,R0
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x.... 0x....      BL       __aeabi_fdiv
   \   00000038   0x0004             MOVS     R4,R0
    227          
    228              roll_ratio = WFLY_RC_CheckRatioValid(roll_ratio);
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       WFLY_RC_CheckRatioValid
   \   00000040   0x0004             MOVS     R4,R0
    229          
    230              return roll_ratio;
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    231          }
    232          

   \                                 In section .text, align 2, keep-with-next
    233          uint8 WFLY_RC_GetCH5OnOff(void)
    234          {
    235              uint8 ret = 0;
   \                     WFLY_RC_GetCH5OnOff:
   \   00000000   0x2000             MOVS     R0,#+0
    236          
    237              if(g_WFLY_RC_pluse_width_us[CHANNEL_5] > 1000)
   \   00000002   0x....             LDR.N    R1,??DataTable9_1
   \   00000004   0x6909             LDR      R1,[R1, #+16]
   \   00000006   0xF5B1 0x7F7A      CMP      R1,#+1000
   \   0000000A   0xD902             BLS.N    ??WFLY_RC_GetCH5OnOff_0
    238              {
    239                  ret = 1;
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x0008             MOVS     R0,R1
   \   00000010   0xE001             B.N      ??WFLY_RC_GetCH5OnOff_1
    240              }
    241              else
    242              {
    243                  ret = 0;
   \                     ??WFLY_RC_GetCH5OnOff_0:
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x0008             MOVS     R0,R1
    244              }
    245          
    246              return ret;
   \                     ??WFLY_RC_GetCH5OnOff_1:
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x4770             BX       LR               ;; return
    247          }
    248          

   \                                 In section .text, align 2, keep-with-next
    249          float WFLY_RC_CheckRatioValid(float ratio_to_check)
    250          {
   \                     WFLY_RC_CheckRatioValid:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0002             MOVS     R2,R0
    251              float checked_ratio = 0;
   \   00000004   0x2300             MOVS     R3,#+0
    252          
    253              if(ratio_to_check > 1)
   \   00000006   0x0010             MOVS     R0,R2
   \   00000008   0x....             LDR.N    R1,??DataTable9_4  ;; 0x3f800001
   \   0000000A   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000000E   0xD803             BHI.N    ??WFLY_RC_CheckRatioValid_0
    254              {
    255                  checked_ratio = 1;    
   \   00000010   0xF05F 0x507E      MOVS     R0,#+1065353216
   \   00000014   0x0003             MOVS     R3,R0
   \   00000016   0xE008             B.N      ??WFLY_RC_CheckRatioValid_1
    256              }
    257              else if(ratio_to_check < -1)
   \                     ??WFLY_RC_CheckRatioValid_0:
   \   00000018   0x0010             MOVS     R0,R2
   \   0000001A   0x....             LDR.N    R1,??DataTable9_5  ;; 0xbf800000
   \   0000001C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000020   0xD202             BCS.N    ??WFLY_RC_CheckRatioValid_2
    258              {
    259                  checked_ratio = -1;
   \   00000022   0x....             LDR.N    R0,??DataTable9_5  ;; 0xbf800000
   \   00000024   0x0003             MOVS     R3,R0
   \   00000026   0xE000             B.N      ??WFLY_RC_CheckRatioValid_1
    260              }
    261              else
    262              {
    263                  checked_ratio = ratio_to_check;
   \                     ??WFLY_RC_CheckRatioValid_2:
   \   00000028   0x0013             MOVS     R3,R2
    264              }
    265          
    266              return checked_ratio;
   \                     ??WFLY_RC_CheckRatioValid_1:
   \   0000002A   0x0018             MOVS     R0,R3
   \   0000002C   0xBD00             POP      {PC}             ;; return
    267          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     g_u32TimerMsCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     g_WFLY_RC_pluse_width_us

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     g_u32WFLY_RC_offset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     g_u32WFLY_RC_max_range

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x3F800001         DC32     0x3f800001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0xBF800000         DC32     0xbf800000

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0, 0, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0, 0, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0, 0, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0, 0, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  WFLY_RC_CheckMaxRangeValid
        0  WFLY_RC_CheckOffsetValid
        4  WFLY_RC_CheckRatioValid
              4 -> __aeabi_cfcmple
              4 -> __aeabi_cfrcmple
        0  WFLY_RC_GetCH5OnOff
       56  WFLY_RC_GetMaxRange
             56 -> ReadSwitches
             56 -> SetLightsOnOff
             56 -> __aeabi_memclr4
        8  WFLY_RC_GetMaxRangeOpe
              8 -> DelayWithTimer
              8 -> SetBuzzerMode
              8 -> WFLY_RC_CheckMaxRangeValid
              8 -> WFLY_RC_GetMaxRange
       28  WFLY_RC_GetOffset
             28 -> __aeabi_memclr4
        8  WFLY_RC_GetOffsetOpe
              8 -> DelayWithTimer
              8 -> SetBuzzerMode
              8 -> WFLY_RC_CheckOffsetValid
              8 -> WFLY_RC_GetOffset
       16  WFLY_RC_GetPitchRatio
             16 -> WFLY_RC_CheckRatioValid
             16 -> __aeabi_fdiv
             16 -> __aeabi_fsub
             16 -> __aeabi_ui2f
       16  WFLY_RC_GetRollRatio
             16 -> WFLY_RC_CheckRatioValid
             16 -> __aeabi_fdiv
             16 -> __aeabi_fsub
             16 -> __aeabi_ui2f
       16  WFLY_RC_GetThrottleRatio
             16 -> WFLY_RC_CheckRatioValid
             16 -> __aeabi_cfcmple
             16 -> __aeabi_fdiv
             16 -> __aeabi_fsub
             16 -> __aeabi_ui2f
       16  WFLY_RC_GetYawRatio
             16 -> WFLY_RC_CheckRatioValid
             16 -> __aeabi_fdiv
             16 -> __aeabi_fsub
             16 -> __aeabi_ui2f


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?<Constant {0, 0, 0, 0}>
      16  ?<Constant {0, 0, 0, 0}>_1
      16  ?<Constant {0, 0, 0, 0}>_2
      16  ?<Constant {0L, 0L, 0L, 0L}>
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
      34  WFLY_RC_CheckMaxRangeValid
     126  WFLY_RC_CheckOffsetValid
      46  WFLY_RC_CheckRatioValid
      26  WFLY_RC_GetCH5OnOff
     204  WFLY_RC_GetMaxRange
      64  WFLY_RC_GetMaxRangeOpe
     112  WFLY_RC_GetOffset
      64  WFLY_RC_GetOffsetOpe
      70  WFLY_RC_GetPitchRatio
      70  WFLY_RC_GetRollRatio
      76  WFLY_RC_GetThrottleRatio
      70  WFLY_RC_GetYawRatio
      16  g_u32WFLY_RC_max_range
      16  g_u32WFLY_RC_offset
       4  gc_f32MaxRCHeight
       4  gc_f32MaxRCPitchAngle
       4  gc_f32MaxRCRollAngle
       4  gc_f32MaxRCThrottle
       4  gc_f32MaxRCYawAngle
       4  gc_f32RCThrottleDeadZone

 
  32 bytes in section .data
  88 bytes in section .rodata
 986 bytes in section .text
 
 986 bytes of CODE  memory
  88 bytes of CONST memory
  32 bytes of DATA  memory

Errors: none
Warnings: none
