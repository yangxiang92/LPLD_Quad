###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     07/Aug/2014  15:34:31 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\source\lib\ #
#                    LPLD\HW\HW_I2C.c                                         #
#    Command line =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\source\lib\ #
#                    LPLD\HW\HW_I2C.c -D LPLD_K60 -lCN                        #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\FLASH_M #
#                    INE\List\ -lB E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_ #
#                    V3\iar\FLASH_MINE\List\ -o E:\ShawnDocuments\IAR_WorkSpa #
#                    ce\LPLD_Quad_V3\iar\FLASH_MINE\Obj\ --no_cse             #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\app\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\ #
#                    iar\..\source\app\Control\ -I                            #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\app\Others\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Q #
#                    uad_V3\iar\..\source\app\Communicate\ -I                 #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\app\Algorithm\ -I E:\ShawnDocuments\IAR_WorkSpace\LPL #
#                    D_Quad_V3\iar\..\source\app\SignalProcess\ -I            #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\module\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_ #
#                    V3\iar\..\source\module\anbt_dmp\ -I                     #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\module\eMPL\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_ #
#                    Quad_V3\iar\..\source\lib\CPU\ -I                        #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\common\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Q #
#                    uad_V3\iar\..\source\lib\LPLD\ -I                        #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\LPLD\HW\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_ #
#                    Quad_V3\iar\..\source\lib\LPLD\DEV\ -I                   #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\uCOS-II\Ports\ -I E:\ShawnDocuments\IAR_WorkSpace #
#                    \LPLD_Quad_V3\iar\..\source\lib\uCOS-II\Source\ -I       #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\FatFs\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Qu #
#                    ad_V3\iar\..\source\lib\FatFs\option\ -I                 #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\USB\common\ -I E:\ShawnDocuments\IAR_WorkSpace\LP #
#                    LD_Quad_V3\iar\..\source\lib\USB\driver\ -I              #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\USB\descriptor\ -I E:\ShawnDocuments\IAR_WorkSpac #
#                    e\LPLD_Quad_V3\iar\..\source\lib\USB\class\ -I           #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\MyLib\ -On -I "D:\Program Files\IAR               #
#                    Systems\Embedded Workbench 6.4\arm\CMSIS\Include\" -D    #
#                    ARM_MATH_CM4                                             #
#    List file    =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\FLASH_M #
#                    INE\List\HW_I2C.lst                                      #
#    Object file  =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\FLASH_M #
#                    INE\Obj\HW_I2C.o                                         #
#                                                                             #
#                                                                             #
###############################################################################

E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\source\lib\LPLD\HW\HW_I2C.c
      1          /*
      2           * @file HW_I2C.c
      3           * @version 3.02[By LPLD]
      4           * @date 2013-11-22
      5           * @brief I2C底层模块相关函数
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * 版权所有:北京拉普兰德电子技术有限公司
     10           * http://www.lpld.cn
     11           * mail:support@lpld.cn
     12           *
     13           * @par
     14           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     15           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     16           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     17           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     18           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     19           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     20           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     21           */
     22          
     23          #include "common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000004   0x0941             LSRS     R1,R0,#+5
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable7  ;; 0xe000e100
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0xF010 0x041F      ANDS     R4,R0,#0x1F
   \   00000010   0x40A3             LSLS     R3,R3,R4
   \   00000012   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000004   0x0941             LSRS     R1,R0,#+5
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable7_1  ;; 0xe000e180
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0xF010 0x041F      ANDS     R4,R0,#0x1F
   \   00000010   0x40A3             LSLS     R3,R3,R4
   \   00000012   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return
     24          #include "HW_I2C.h"
     25          
     26          //用户自定义中断服务函数数组

   \                                 In section .bss, align 4
     27          I2C_ISR_CALLBACK I2C_ISR[2];
   \                     I2C_ISR:
   \   00000000                      DS8 8
     28          
     29          /*
     30           * LPLD_I2C_Init
     31           * I2C通用初始化函数，在该函数中选择I2C通道，选择I2C SCK总线频率，
     32           * 选择I2C SDA 和 I2C SCL的引脚，配置I2C的中断回调函数
     33           * 
     34           * 参数:
     35           *    I2C_InitTypeDef--i2c_init_structure
     36           *                     具体定义见I2C_InitTypeDef
     37           * 输出:
     38           *    0--配置错误
     39           *    1--配置成功
     40           */

   \                                 In section .text, align 2, keep-with-next
     41          uint8 LPLD_I2C_Init(I2C_InitTypeDef i2c_init_structure)
     42          {
   \                     LPLD_I2C_Init:
   \   00000000   0xB4FF             PUSH     {R0-R7}
     43            I2C_Type *i2cx = i2c_init_structure.I2C_I2Cx;
   \   00000002   0x9900             LDR      R1,[SP, #+0]
     44            uint8 bus_speed = i2c_init_structure.I2C_ICR;
   \   00000004   0xF89D 0x2004      LDRB     R2,[SP, #+4]
     45            PortPinsEnum_Type scl_pin = i2c_init_structure.I2C_SclPin;
   \   00000008   0xF89D 0x3006      LDRB     R3,[SP, #+6]
     46            PortPinsEnum_Type sda_pin = i2c_init_structure.I2C_SdaPin;
   \   0000000C   0xF89D 0x4007      LDRB     R4,[SP, #+7]
     47            I2C_ISR_CALLBACK isr_func = i2c_init_structure.I2C_Isr;
   \   00000010   0x9D03             LDR      R5,[SP, #+12]
     48            boolean ode = i2c_init_structure.I2C_OpenDrainEnable;
   \   00000012   0xF89D 0x6008      LDRB     R6,[SP, #+8]
     49            uint8 ode_mask = 0;
   \   00000016   0x2700             MOVS     R7,#+0
     50          
     51            //参数检查，判断SCL频率
     52            ASSERT( bus_speed <= 0x3F);
     53            
     54            if(ode == TRUE)
   \   00000018   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001A   0x2E01             CMP      R6,#+1
   \   0000001C   0xD101             BNE.N    ??LPLD_I2C_Init_0
     55            {
     56              ode_mask = PORT_PCR_ODE_MASK;
   \   0000001E   0x2020             MOVS     R0,#+32
   \   00000020   0x0007             MOVS     R7,R0
     57            }
     58          
     59            if(i2cx == I2C0)
   \                     ??LPLD_I2C_Init_0:
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable7_2  ;; 0x40066000
   \   00000026   0x4281             CMP      R1,R0
   \   00000028   0xD143             BNE.N    ??LPLD_I2C_Init_1
     60            {
     61              SIM->SCGC4 |= SIM_SCGC4_I2C0_MASK; //开启I2C0时钟
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable7_3  ;; 0x40048034
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000034   0x.... 0x....      LDR.W    R12,??DataTable7_3  ;; 0x40048034
   \   00000038   0xF8CC 0x0000      STR      R0,[R12, #+0]
     62          
     63              if(scl_pin == PTD8)
   \   0000003C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000003E   0x2B64             CMP      R3,#+100
   \   00000040   0xD107             BNE.N    ??LPLD_I2C_Init_2
     64              {
     65                PORTD->PCR[8] = PORT_PCR_MUX(2) | ode_mask;         
   \   00000042   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000044   0xF457 0x7000      ORRS     R0,R7,#0x200
   \   00000048   0x.... 0x....      LDR.W    R12,??DataTable7_4  ;; 0x4004c020
   \   0000004C   0xF8CC 0x0000      STR      R0,[R12, #+0]
   \   00000050   0xE011             B.N      ??LPLD_I2C_Init_3
     66              }
     67              else if(scl_pin == PTB0) 
   \                     ??LPLD_I2C_Init_2:
   \   00000052   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000054   0x2B20             CMP      R3,#+32
   \   00000056   0xD107             BNE.N    ??LPLD_I2C_Init_4
     68              {
     69                PORTB->PCR[0] = PORT_PCR_MUX(2) | ode_mask;
   \   00000058   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005A   0xF457 0x7000      ORRS     R0,R7,#0x200
   \   0000005E   0x.... 0x....      LDR.W    R12,??DataTable7_5  ;; 0x4004a000
   \   00000062   0xF8CC 0x0000      STR      R0,[R12, #+0]
   \   00000066   0xE006             B.N      ??LPLD_I2C_Init_3
     70              }
     71              else //scl_pin = PTB2
     72              {
     73                PORTB->PCR[2] = PORT_PCR_MUX(2) | ode_mask;
   \                     ??LPLD_I2C_Init_4:
   \   00000068   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000006A   0xF457 0x7000      ORRS     R0,R7,#0x200
   \   0000006E   0x.... 0x....      LDR.W    R12,??DataTable7_6  ;; 0x4004a008
   \   00000072   0xF8CC 0x0000      STR      R0,[R12, #+0]
     74              }
     75          
     76              if(sda_pin == PTD9)
   \                     ??LPLD_I2C_Init_3:
   \   00000076   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000078   0x2C65             CMP      R4,#+101
   \   0000007A   0xD107             BNE.N    ??LPLD_I2C_Init_5
     77              {
     78                PORTD->PCR[9] = PORT_PCR_MUX(2) | ode_mask;
   \   0000007C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000007E   0xF457 0x7000      ORRS     R0,R7,#0x200
   \   00000082   0x.... 0x....      LDR.W    R12,??DataTable7_7  ;; 0x4004c024
   \   00000086   0xF8CC 0x0000      STR      R0,[R12, #+0]
   \   0000008A   0xE044             B.N      ??LPLD_I2C_Init_6
     79              }
     80              else if(sda_pin == PTB1) 
   \                     ??LPLD_I2C_Init_5:
   \   0000008C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008E   0x2C21             CMP      R4,#+33
   \   00000090   0xD107             BNE.N    ??LPLD_I2C_Init_7
     81              {
     82                PORTB->PCR[1] = PORT_PCR_MUX(2) | ode_mask;
   \   00000092   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000094   0xF457 0x7000      ORRS     R0,R7,#0x200
   \   00000098   0x.... 0x....      LDR.W    R12,??DataTable7_8  ;; 0x4004a004
   \   0000009C   0xF8CC 0x0000      STR      R0,[R12, #+0]
   \   000000A0   0xE039             B.N      ??LPLD_I2C_Init_6
     83              }
     84              else //sda_pin = PTB3
     85              {
     86                PORTB->PCR[3] = PORT_PCR_MUX(2) | ode_mask; 
   \                     ??LPLD_I2C_Init_7:
   \   000000A2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000A4   0xF457 0x7000      ORRS     R0,R7,#0x200
   \   000000A8   0x.... 0x....      LDR.W    R12,??DataTable7_9  ;; 0x4004a00c
   \   000000AC   0xF8CC 0x0000      STR      R0,[R12, #+0]
   \   000000B0   0xE031             B.N      ??LPLD_I2C_Init_6
     87              }
     88            }
     89            else if(i2cx == I2C1)
   \                     ??LPLD_I2C_Init_1:
   \   000000B2   0x....             LDR.N    R0,??DataTable7_10  ;; 0x40067000
   \   000000B4   0x4281             CMP      R1,R0
   \   000000B6   0xD12C             BNE.N    ??LPLD_I2C_Init_8
     90            { 
     91              SIM->SCGC4 |= SIM_SCGC4_I2C1_MASK; //开启I2C1时钟
   \   000000B8   0x....             LDR.N    R0,??DataTable7_3  ;; 0x40048034
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000C0   0x.... 0x....      LDR.W    R12,??DataTable7_3  ;; 0x40048034
   \   000000C4   0xF8CC 0x0000      STR      R0,[R12, #+0]
     92          
     93              if(scl_pin == PTE1)
   \   000000C8   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000CA   0x2B7D             CMP      R3,#+125
   \   000000CC   0xD107             BNE.N    ??LPLD_I2C_Init_9
     94              {
     95                PORTE->PCR[1] = PORT_PCR_MUX(6) | ode_mask;         
   \   000000CE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000D0   0xF457 0x60C0      ORRS     R0,R7,#0x600
   \   000000D4   0x.... 0x....      LDR.W    R12,??DataTable7_11  ;; 0x4004d004
   \   000000D8   0xF8CC 0x0000      STR      R0,[R12, #+0]
   \   000000DC   0xE006             B.N      ??LPLD_I2C_Init_10
     96              }
     97              else //scl_pin = PTC10
     98              {
     99                PORTC->PCR[10] = PORT_PCR_MUX(2) | ode_mask;  
   \                     ??LPLD_I2C_Init_9:
   \   000000DE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000E0   0xF457 0x7000      ORRS     R0,R7,#0x200
   \   000000E4   0x.... 0x....      LDR.W    R12,??DataTable7_12  ;; 0x4004b028
   \   000000E8   0xF8CC 0x0000      STR      R0,[R12, #+0]
    100              }
    101          
    102              if(sda_pin == PTE0)
   \                     ??LPLD_I2C_Init_10:
   \   000000EC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000EE   0x2C7C             CMP      R4,#+124
   \   000000F0   0xD107             BNE.N    ??LPLD_I2C_Init_11
    103              {
    104                PORTE->PCR[0] = PORT_PCR_MUX(6) | ode_mask;
   \   000000F2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000F4   0xF457 0x60C0      ORRS     R0,R7,#0x600
   \   000000F8   0x.... 0x....      LDR.W    R12,??DataTable7_13  ;; 0x4004d000
   \   000000FC   0xF8CC 0x0000      STR      R0,[R12, #+0]
   \   00000100   0xE009             B.N      ??LPLD_I2C_Init_6
    105              }
    106              else //sda_pin = PTC11
    107              {
    108                PORTC->PCR[11] = PORT_PCR_MUX(2) | ode_mask; 
   \                     ??LPLD_I2C_Init_11:
   \   00000102   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000104   0xF457 0x7000      ORRS     R0,R7,#0x200
   \   00000108   0x.... 0x....      LDR.W    R12,??DataTable7_14  ;; 0x4004b02c
   \   0000010C   0xF8CC 0x0000      STR      R0,[R12, #+0]
   \   00000110   0xE001             B.N      ??LPLD_I2C_Init_6
    109              }
    110            }
    111            else
    112              return 0;
   \                     ??LPLD_I2C_Init_8:
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0xE020             B.N      ??LPLD_I2C_Init_12
    113            
    114            if(i2c_init_structure.I2C_IntEnable == TRUE && isr_func != NULL)
   \                     ??LPLD_I2C_Init_6:
   \   00000116   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   0000011A   0x2801             CMP      R0,#+1
   \   0000011C   0xD114             BNE.N    ??LPLD_I2C_Init_13
   \   0000011E   0x0028             MOVS     R0,R5
   \   00000120   0x2800             CMP      R0,#+0
   \   00000122   0xD011             BEQ.N    ??LPLD_I2C_Init_13
    115            {
    116              //产生I2C中断的中断源：
    117              //1,完成1个字节传输时，IICIF置位产生中断;
    118              //2,当Calling Address匹配成功时产生中断，参考K60文档1456页I2Cx_S寄存器IAAS位;
    119              //3,从机模式下当总线仲裁丢失时，IICIF置位产生中断;
    120              //  需要同时写1清除II2Cx_S的ARBL标志位和 I2Cx_S的 IICIF的标志位;
    121              //4,如果SMB寄存器的SHTF2 interrupt使能，当SHTF2 timeout时IICIF置位产生中断;
    122              //  需要同时写1清除I2Cx_SMB的SLTF标志位和 I2Cx_S的 IICIF的标志位;
    123              //5,当SLT寄存器不为0时，SMBus的SCL low timer计数等于SLT的值时IICIF置位产生中断;
    124              //  需要同时写1清除I2Cx_SMB的SHTF2标志位和 I2Cx_S的 IICIF的标志位;
    125              //6,当Wakeup 使能，I2C在停止模式下接收到Wakeup信号，将产生中断.
    126          
    127              i2cx->C1 |= I2C_C1_IICIE_MASK;
   \   00000124   0x7888             LDRB     R0,[R1, #+2]
   \   00000126   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000012A   0x7088             STRB     R0,[R1, #+2]
    128          
    129              if(i2cx == I2C0)
   \   0000012C   0x....             LDR.N    R0,??DataTable7_2  ;; 0x40066000
   \   0000012E   0x4281             CMP      R1,R0
   \   00000130   0xD102             BNE.N    ??LPLD_I2C_Init_14
    130              {
    131                I2C_ISR[0] = isr_func;
   \   00000132   0x....             LDR.N    R0,??DataTable7_15
   \   00000134   0x6005             STR      R5,[R0, #+0]
   \   00000136   0xE007             B.N      ??LPLD_I2C_Init_13
    132              }
    133              else if(i2cx == I2C0)
   \                     ??LPLD_I2C_Init_14:
   \   00000138   0x....             LDR.N    R0,??DataTable7_2  ;; 0x40066000
   \   0000013A   0x4281             CMP      R1,R0
   \   0000013C   0xD102             BNE.N    ??LPLD_I2C_Init_15
    134              {
    135                I2C_ISR[1] = isr_func;
   \   0000013E   0x....             LDR.N    R0,??DataTable7_15
   \   00000140   0x6045             STR      R5,[R0, #+4]
   \   00000142   0xE001             B.N      ??LPLD_I2C_Init_13
    136              }
    137              else 
    138                return 0;
   \                     ??LPLD_I2C_Init_15:
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0xE007             B.N      ??LPLD_I2C_Init_12
    139            }
    140          
    141            //i2cx->C2 |= I2C_C2_HDRS_MASK;      //提高I2C驱动能力
    142            i2cx->F  = I2C_F_ICR(bus_speed)|I2C_F_MULT(0);   //配置I2Cx SCL BusSpeed
   \                     ??LPLD_I2C_Init_13:
   \   00000148   0xF012 0x003F      ANDS     R0,R2,#0x3F
   \   0000014C   0x7048             STRB     R0,[R1, #+1]
    143            i2cx->C1 |= I2C_C1_IICEN_MASK;      //使能I2Cx
   \   0000014E   0x7888             LDRB     R0,[R1, #+2]
   \   00000150   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000154   0x7088             STRB     R0,[R1, #+2]
    144            
    145            return 1;
   \   00000156   0x2001             MOVS     R0,#+1
   \                     ??LPLD_I2C_Init_12:
   \   00000158   0xB004             ADD      SP,SP,#+16
   \   0000015A   0xBCF0             POP      {R4-R7}
   \   0000015C   0x4770             BX       LR               ;; return
    146          }
    147          
    148          /*
    149           * LPLD_I2C_Deinit
    150           * I2C模块反初始化函数，在该函数中关闭I2Cx的外设总线时钟，关闭I2C模块的
    151           * 时钟，禁止外设中断。
    152           *
    153           * 参数:
    154           *    I2C_InitTypeDef--i2c_init_structure
    155           *                     具体定义见I2C_InitTypeDef
    156           *
    157           * 输出:
    158           *    无
    159           *
    160           */  

   \                                 In section .text, align 2, keep-with-next
    161          uint8 LPLD_I2C_Deinit(I2C_InitTypeDef i2c_init_structure)
    162          {
   \                     LPLD_I2C_Deinit:
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    163            I2C_Type *i2cx = i2c_init_structure.I2C_I2Cx;
   \   00000002   0x9C00             LDR      R4,[SP, #+0]
    164          
    165            i2cx->C1 &= ~I2C_C1_IICEN_MASK;      //I2Cx
   \   00000004   0x78A0             LDRB     R0,[R4, #+2]
   \   00000006   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   0000000A   0x70A0             STRB     R0,[R4, #+2]
    166            if(i2cx == I2C0)
   \   0000000C   0x....             LDR.N    R0,??DataTable7_2  ;; 0x40066000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD109             BNE.N    ??LPLD_I2C_Deinit_0
    167            {
    168              SIM->SCGC4 &= ~SIM_SCGC4_I2C0_MASK; //关闭I2C0时钟
   \   00000012   0x....             LDR.N    R0,??DataTable7_3  ;; 0x40048034
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000001A   0x....             LDR.N    R1,??DataTable7_3  ;; 0x40048034
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    169              disable_irq((IRQn_Type)I2C0_IRQn);
   \   0000001E   0x2018             MOVS     R0,#+24
   \   00000020   0x.... 0x....      BL       NVIC_DisableIRQ
   \   00000024   0xE00E             B.N      ??LPLD_I2C_Deinit_1
    170            }
    171            else if (i2cx == I2C1)
   \                     ??LPLD_I2C_Deinit_0:
   \   00000026   0x....             LDR.N    R0,??DataTable7_10  ;; 0x40067000
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD109             BNE.N    ??LPLD_I2C_Deinit_2
    172            {
    173              SIM->SCGC4 &= ~SIM_SCGC4_I2C1_MASK; //关闭I2C1时钟
   \   0000002C   0x....             LDR.N    R0,??DataTable7_3  ;; 0x40048034
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000034   0x....             LDR.N    R1,??DataTable7_3  ;; 0x40048034
   \   00000036   0x6008             STR      R0,[R1, #+0]
    174              disable_irq((IRQn_Type)I2C1_IRQn);
   \   00000038   0x2019             MOVS     R0,#+25
   \   0000003A   0x.... 0x....      BL       NVIC_DisableIRQ
   \   0000003E   0xE001             B.N      ??LPLD_I2C_Deinit_1
    175            }
    176            else
    177            {
    178              return 0;
   \                     ??LPLD_I2C_Deinit_2:
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xE000             B.N      ??LPLD_I2C_Deinit_3
    179            }
    180            return 1;
   \                     ??LPLD_I2C_Deinit_1:
   \   00000044   0x2001             MOVS     R0,#+1
   \                     ??LPLD_I2C_Deinit_3:
   \   00000046   0xB004             ADD      SP,SP,#+16
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
    181          }
    182          
    183          /*
    184           * LPLD_I2C_EnableIrq
    185           * I2C外设中断使能
    186           *
    187           * 参数:
    188           *    I2C_InitTypeDef--i2c_init_structure
    189           *                     具体定义见I2C_InitTypeDef
    190           *
    191           * 输出:
    192           *    无
    193           *
    194           */  

   \                                 In section .text, align 2, keep-with-next
    195          void LPLD_I2C_EnableIrq(I2C_InitTypeDef i2c_init_structure)
    196          {
   \                     LPLD_I2C_EnableIrq:
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    197            I2C_Type *i2cx = i2c_init_structure.I2C_I2Cx; 
   \   00000002   0x9C00             LDR      R4,[SP, #+0]
    198          
    199            if(i2cx == I2C0)
   \   00000004   0x....             LDR.N    R0,??DataTable7_2  ;; 0x40066000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD103             BNE.N    ??LPLD_I2C_EnableIrq_0
    200            {
    201              enable_irq((IRQn_Type)I2C0_IRQn);
   \   0000000A   0x2018             MOVS     R0,#+24
   \   0000000C   0x.... 0x....      BL       NVIC_EnableIRQ
   \   00000010   0xE007             B.N      ??LPLD_I2C_EnableIrq_1
    202            }
    203            else if (i2cx == I2C1)
   \                     ??LPLD_I2C_EnableIrq_0:
   \   00000012   0x....             LDR.N    R0,??DataTable7_10  ;; 0x40067000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD103             BNE.N    ??LPLD_I2C_EnableIrq_2
    204            {
    205              enable_irq((IRQn_Type)I2C1_IRQn);
   \   00000018   0x2019             MOVS     R0,#+25
   \   0000001A   0x.... 0x....      BL       NVIC_EnableIRQ
   \   0000001E   0xE000             B.N      ??LPLD_I2C_EnableIrq_1
    206            }
    207            else
    208            {
    209              return;
   \                     ??LPLD_I2C_EnableIrq_2:
   \   00000020   0xE7FF             B.N      ??LPLD_I2C_EnableIrq_3
    210            }
    211          }
   \                     ??LPLD_I2C_EnableIrq_1:
   \                     ??LPLD_I2C_EnableIrq_3:
   \   00000022   0xBD1F             POP      {R0-R4,PC}       ;; return
    212          
    213          /*
    214           * LPLD_I2C_DisableIrq
    215           * 禁止I2C外设中断
    216           *
    217           * 参数:
    218           *    I2C_InitTypeDef--i2c_init_structure
    219           *                     具体定义见I2C_InitTypeDef
    220           *
    221           * 输出:
    222           *    无
    223           *
    224           */  

   \                                 In section .text, align 2, keep-with-next
    225          void LPLD_I2C_DisableIrq(I2C_InitTypeDef i2c_init_structure)
    226          {
   \                     LPLD_I2C_DisableIrq:
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    227            I2C_Type *i2cx = i2c_init_structure.I2C_I2Cx;
   \   00000002   0x9C00             LDR      R4,[SP, #+0]
    228            i2cx->C1 &= ~I2C_C1_IICIE_MASK;
   \   00000004   0x78A0             LDRB     R0,[R4, #+2]
   \   00000006   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   0000000A   0x70A0             STRB     R0,[R4, #+2]
    229          
    230            if(i2cx == I2C0)
   \   0000000C   0x....             LDR.N    R0,??DataTable7_2  ;; 0x40066000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD103             BNE.N    ??LPLD_I2C_DisableIrq_0
    231            {
    232              disable_irq((IRQn_Type)I2C0_IRQn);
   \   00000012   0x2018             MOVS     R0,#+24
   \   00000014   0x.... 0x....      BL       NVIC_DisableIRQ
   \   00000018   0xE007             B.N      ??LPLD_I2C_DisableIrq_1
    233            }
    234            else if (i2cx == I2C1)
   \                     ??LPLD_I2C_DisableIrq_0:
   \   0000001A   0x....             LDR.N    R0,??DataTable7_10  ;; 0x40067000
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD103             BNE.N    ??LPLD_I2C_DisableIrq_2
    235            {
    236              disable_irq((IRQn_Type)I2C1_IRQn);
   \   00000020   0x2019             MOVS     R0,#+25
   \   00000022   0x.... 0x....      BL       NVIC_DisableIRQ
   \   00000026   0xE000             B.N      ??LPLD_I2C_DisableIrq_1
    237            }
    238            else
    239            {
    240              return;
   \                     ??LPLD_I2C_DisableIrq_2:
   \   00000028   0xE7FF             B.N      ??LPLD_I2C_DisableIrq_3
    241            }
    242          }
   \                     ??LPLD_I2C_DisableIrq_1:
   \                     ??LPLD_I2C_DisableIrq_3:
   \   0000002A   0xBD1F             POP      {R0-R4,PC}       ;; return
    243          
    244          /*
    245           * LPLD_I2C_Start
    246           * 产生I2C开始信号
    247           * 
    248           * 参数:
    249           *    i2cx--选择I2C模块的通道
    250           *      |__I2C0           --I2C通道0
    251           *      |__I2C1           --I2C通道1
    252           * 输出:
    253           *    无
    254           */

   \                                 In section .text, align 2, keep-with-next
    255          void LPLD_I2C_Start(I2C_Type *i2cx)
    256          {
    257            i2cx->C1 |= I2C_C1_TX_MASK ;
   \                     LPLD_I2C_Start:
   \   00000000   0x7881             LDRB     R1,[R0, #+2]
   \   00000002   0xF051 0x0110      ORRS     R1,R1,#0x10
   \   00000006   0x7081             STRB     R1,[R0, #+2]
    258            i2cx->C1 |= I2C_C1_MST_MASK ;
   \   00000008   0x7881             LDRB     R1,[R0, #+2]
   \   0000000A   0xF051 0x0120      ORRS     R1,R1,#0x20
   \   0000000E   0x7081             STRB     R1,[R0, #+2]
    259          }
   \   00000010   0x4770             BX       LR               ;; return
    260          
    261          /*
    262           * LPLD_ReStart
    263           * I2C再次产生开始信号
    264           * 
    265           * 参数:
    266           *    i2cx--选择I2C模块的通道
    267           *      |__I2C0           --I2C通道0
    268           *      |__I2C1           --I2C通道1
    269           * 输出:
    270           *    无
    271          */

   \                                 In section .text, align 2, keep-with-next
    272          void LPLD_I2C_ReStart(I2C_Type *i2cx)
    273          {
    274            i2cx->C1 |= I2C_C1_RSTA_MASK ;
   \                     LPLD_I2C_ReStart:
   \   00000000   0x7881             LDRB     R1,[R0, #+2]
   \   00000002   0xF051 0x0104      ORRS     R1,R1,#0x4
   \   00000006   0x7081             STRB     R1,[R0, #+2]
    275          }
   \   00000008   0x4770             BX       LR               ;; return
    276          
    277          /*
    278           * LPLD_I2C_Stop
    279           * 产生I2C停止信号
    280           * 
    281           * 参数:
    282           *    i2cx--选择I2C模块的通道
    283           *      |__I2C0           --I2C通道0
    284           *      |__I2C1           --I2C通道1
    285           * 输出:
    286           *    无
    287           */

   \                                 In section .text, align 2, keep-with-next
    288          void LPLD_I2C_Stop(I2C_Type *i2cx)
    289          {
    290            i2cx->C1 &=(~I2C_C1_MST_MASK);
   \                     LPLD_I2C_Stop:
   \   00000000   0x7881             LDRB     R1,[R0, #+2]
   \   00000002   0xF011 0x01DF      ANDS     R1,R1,#0xDF
   \   00000006   0x7081             STRB     R1,[R0, #+2]
    291            i2cx->C1 &=(~I2C_C1_TX_MASK); 
   \   00000008   0x7881             LDRB     R1,[R0, #+2]
   \   0000000A   0xF011 0x01EF      ANDS     R1,R1,#0xEF
   \   0000000E   0x7081             STRB     R1,[R0, #+2]
    292          }
   \   00000010   0x4770             BX       LR               ;; return
    293          
    294          /*
    295           * LPLD_I2C_WaitAck
    296           * I2C设置等待应答信号，开启则等待，关闭则不等待
    297           * 
    298           * 参数:
    299           *    i2cx--选择I2C模块的通道
    300           *      |__I2C0           --I2C通道0
    301           *      |__I2C1           --I2C通道1
    302           *    is_wait--选择是否等待应答
    303           *      |__I2C_ACK_OFF    --关闭等待Ack
    304           *      |__I2C_ACK_ON     --开启等待Ack，并等待ACK信号
    305           * 输出:
    306           *    无
    307           */

   \                                 In section .text, align 2, keep-with-next
    308          void LPLD_I2C_WaitAck(I2C_Type *i2cx, uint8 is_wait)
    309          {
    310            uint16 time_out;
    311            if(is_wait == I2C_ACK_ON)
   \                     LPLD_I2C_WaitAck:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD10E             BNE.N    ??LPLD_I2C_WaitAck_0
    312            {
    313              while(!(i2cx->S & I2C_S_IICIF_MASK))
   \                     ??LPLD_I2C_WaitAck_1:
   \   00000006   0x78C3             LDRB     R3,[R0, #+3]
   \   00000008   0x079B             LSLS     R3,R3,#+30
   \   0000000A   0xD406             BMI.N    ??LPLD_I2C_WaitAck_2
    314              {
    315                if(time_out>60000) //如果等待超时，强行退出
   \   0000000C   0xF64E 0x2361      MOVW     R3,#+60001
   \   00000010   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000012   0x429A             CMP      R2,R3
   \   00000014   0xD201             BCS.N    ??LPLD_I2C_WaitAck_2
    316                {
    317                  break;
    318                }
    319                else time_out++;
   \                     ??LPLD_I2C_WaitAck_3:
   \   00000016   0x1C52             ADDS     R2,R2,#+1
   \   00000018   0xE7F5             B.N      ??LPLD_I2C_WaitAck_1
    320              }
    321              i2cx->S |= I2C_S_IICIF_MASK;
   \                     ??LPLD_I2C_WaitAck_2:
   \   0000001A   0x78C3             LDRB     R3,[R0, #+3]
   \   0000001C   0xF053 0x0302      ORRS     R3,R3,#0x2
   \   00000020   0x70C3             STRB     R3,[R0, #+3]
   \   00000022   0xE003             B.N      ??LPLD_I2C_WaitAck_4
    322            }
    323            else
    324            {
    325              //关闭I2C的ACK
    326              i2cx->C1 |= I2C_C1_TXAK_MASK; 
   \                     ??LPLD_I2C_WaitAck_0:
   \   00000024   0x7883             LDRB     R3,[R0, #+2]
   \   00000026   0xF053 0x0308      ORRS     R3,R3,#0x8
   \   0000002A   0x7083             STRB     R3,[R0, #+2]
    327            }
    328          }
   \                     ??LPLD_I2C_WaitAck_4:
   \   0000002C   0x4770             BX       LR               ;; return
    329          
    330          /*
    331           * LPLD_I2C_Write
    332           * I2C发送一个字节给目的地址设备
    333           * 
    334           * 参数:
    335           *    i2cx--选择I2C模块的通道
    336           *      |__I2C0           --I2C通道0
    337           *      |__I2C1           --I2C通道1
    338           *    data8--要发送的字节数据
    339           * 输出:
    340           *    无
    341           *
    342           */

   \                                 In section .text, align 2, keep-with-next
    343          void LPLD_I2C_WriteByte(I2C_Type *i2cx, uint8 data8)
    344          {
    345            i2cx->D = data8; 
   \                     LPLD_I2C_WriteByte:
   \   00000000   0x7101             STRB     R1,[R0, #+4]
    346          }
   \   00000002   0x4770             BX       LR               ;; return
    347          
    348          /*
    349           * LPLD_I2C_Read
    350           * I2C从外部设备读一个字节
    351           * 
    352           * 参数:
    353           *    i2cx--选择I2C模块的通道
    354           *      |__I2C0           --I2C通道0
    355           *      |__I2C1           --I2C通道1
    356           * 输出:
    357           *    I2C读取的字节 
    358           */
    359          

   \                                 In section .text, align 2, keep-with-next
    360          uint8 LPLD_I2C_ReadByte(I2C_Type *i2cx)
    361          {
   \                     LPLD_I2C_ReadByte:
   \   00000000   0x0001             MOVS     R1,R0
    362            uint8 temp;
    363            temp = i2cx->D; 
   \   00000002   0x790A             LDRB     R2,[R1, #+4]
   \   00000004   0x0010             MOVS     R0,R2
    364            return temp;
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x4770             BX       LR               ;; return
    365          }
    366          
    367          /*
    368           * LPLD_I2C_SetMasterWR
    369           * I2C主机读写模式配置
    370           * 
    371           * 参数:
    372           *    IICx--选择I2C模块的通道
    373           *      |__I2C0           --I2C通道0
    374           *      |__I2C1           --I2C通道1
    375           *    mode--读写模式选择
    376           *      |__I2C_MWSR         --主机写
    377           *      |__I2C_MRSW         --主机读
    378           * 输出:
    379           *    无
    380           */

   \                                 In section .text, align 2, keep-with-next
    381          void LPLD_I2C_SetMasterWR(I2C_Type *i2cx, uint8 mode)
    382          {
    383            if(mode==I2C_MRSW) 
   \                     LPLD_I2C_SetMasterWR:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD104             BNE.N    ??LPLD_I2C_SetMasterWR_0
    384              i2cx->C1 &= (~I2C_C1_TX_MASK);
   \   00000006   0x7882             LDRB     R2,[R0, #+2]
   \   00000008   0xF012 0x02EF      ANDS     R2,R2,#0xEF
   \   0000000C   0x7082             STRB     R2,[R0, #+2]
   \   0000000E   0xE003             B.N      ??LPLD_I2C_SetMasterWR_1
    385            else
    386              i2cx->C1 |= ( I2C_C1_TX_MASK);
   \                     ??LPLD_I2C_SetMasterWR_0:
   \   00000010   0x7882             LDRB     R2,[R0, #+2]
   \   00000012   0xF052 0x0210      ORRS     R2,R2,#0x10
   \   00000016   0x7082             STRB     R2,[R0, #+2]
    387          }
   \                     ??LPLD_I2C_SetMasterWR_1:
   \   00000018   0x4770             BX       LR               ;; return
    388          
    389          /*
    390           * LPLD_I2C_StartTrans
    391           * I2C开始传输函数，需要设置外围设备地址和读写模式
    392           * 
    393           * 参数:
    394           *    IICx--选择I2C模块的通道
    395           *      |__I2C0           --I2C通道0
    396           *      |__I2C1           --I2C通道1
    397           *    addr--外围设备地址     
    398           *    mode--读写模式选择
    399           *      |__I2C_MWSR         --主机写
    400           *      |__I2C_MRSW         --主机读
    401           * 输出:
    402           *    无
    403           */

   \                                 In section .text, align 2, keep-with-next
    404          void LPLD_I2C_StartTrans(I2C_Type *i2cx, uint8 addr, uint8 mode)
    405          {
   \                     LPLD_I2C_StartTrans:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    406            //I2C产生start信号
    407            LPLD_I2C_Start(i2cx);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       LPLD_I2C_Start
    408            //将从机地址和主机读写位合成一个字节写入
    409            LPLD_I2C_WriteByte(i2cx, (addr<<1)|mode );
   \   0000000E   0xEA56 0x0145      ORRS     R1,R6,R5, LSL #+1
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       LPLD_I2C_WriteByte
    410          }
   \   0000001A   0xBD70             POP      {R4-R6,PC}       ;; return
    411          
    412          //HW层中断函数，用户无需调用

   \                                 In section .text, align 2, keep-with-next
    413          void I2C0_IRQHandler(void)
    414          {
   \                     I2C0_IRQHandler:
   \   00000000   0xB580             PUSH     {R7,LR}
    415          #if (UCOS_II > 0u)
    416            OS_CPU_SR  cpu_sr = 0u;
    417            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    418            OSIntEnter();
    419            OS_EXIT_CRITICAL();
    420          #endif
    421            if(I2C0->S & I2C_S_IICIF_MASK)
   \   00000002   0x....             LDR.N    R0,??DataTable7_16  ;; 0x40066003
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x0780             LSLS     R0,R0,#+30
   \   00000008   0xD526             BPL.N    ??I2C0_IRQHandler_0
    422            {
    423              I2C_ISR[0]();
   \   0000000A   0x....             LDR.N    R0,??DataTable7_15
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x4780             BLX      R0
    424              if(I2C0->SMB & I2C_SMB_SLTF_MASK)
   \   00000010   0x....             LDR.N    R0,??DataTable7_17  ;; 0x40066008
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x0700             LSLS     R0,R0,#+28
   \   00000016   0xD505             BPL.N    ??I2C0_IRQHandler_1
    425              {
    426                I2C0->SMB |= I2C_SMB_SLTF_MASK;
   \   00000018   0x....             LDR.N    R0,??DataTable7_17  ;; 0x40066008
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000020   0x....             LDR.N    R1,??DataTable7_17  ;; 0x40066008
   \   00000022   0x7008             STRB     R0,[R1, #+0]
    427              }
    428              if(I2C0->SMB & I2C_SMB_SHTF2_MASK)
   \                     ??I2C0_IRQHandler_1:
   \   00000024   0x....             LDR.N    R0,??DataTable7_17  ;; 0x40066008
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x0780             LSLS     R0,R0,#+30
   \   0000002A   0xD505             BPL.N    ??I2C0_IRQHandler_2
    429              {
    430                I2C0->SMB |= I2C_SMB_SHTF2_MASK;
   \   0000002C   0x....             LDR.N    R0,??DataTable7_17  ;; 0x40066008
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000034   0x....             LDR.N    R1,??DataTable7_17  ;; 0x40066008
   \   00000036   0x7008             STRB     R0,[R1, #+0]
    431              }
    432              if(I2C0->S & I2C_S_ARBL_MASK)
   \                     ??I2C0_IRQHandler_2:
   \   00000038   0x....             LDR.N    R0,??DataTable7_16  ;; 0x40066003
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x06C0             LSLS     R0,R0,#+27
   \   0000003E   0xD505             BPL.N    ??I2C0_IRQHandler_3
    433              {
    434                I2C0->S |= I2C_S_ARBL_MASK;
   \   00000040   0x....             LDR.N    R0,??DataTable7_16  ;; 0x40066003
   \   00000042   0x7800             LDRB     R0,[R0, #+0]
   \   00000044   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000048   0x....             LDR.N    R1,??DataTable7_16  ;; 0x40066003
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
    435              }
    436              I2C0->S |= I2C_S_IICIF_MASK;
   \                     ??I2C0_IRQHandler_3:
   \   0000004C   0x....             LDR.N    R0,??DataTable7_16  ;; 0x40066003
   \   0000004E   0x7800             LDRB     R0,[R0, #+0]
   \   00000050   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000054   0x....             LDR.N    R1,??DataTable7_16  ;; 0x40066003
   \   00000056   0x7008             STRB     R0,[R1, #+0]
    437            }
    438          #if (UCOS_II > 0u)
    439            OSIntExit();          //告知系统此时即将离开中断服务子函数
    440          #endif
    441          }
   \                     ??I2C0_IRQHandler_0:
   \   00000058   0xBD01             POP      {R0,PC}          ;; return
    442          //HW层中断函数，用户无需调用

   \                                 In section .text, align 2, keep-with-next
    443          void I2C1_IRQHandler(void)
    444          {
   \                     I2C1_IRQHandler:
   \   00000000   0xB580             PUSH     {R7,LR}
    445          
    446          #if (UCOS_II > 0u)
    447            OS_CPU_SR  cpu_sr = 0u;
    448            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    449            OSIntEnter();
    450            OS_EXIT_CRITICAL();
    451          #endif
    452          
    453            if(I2C1->S & I2C_S_IICIF_MASK)
   \   00000002   0x....             LDR.N    R0,??DataTable7_18  ;; 0x40067003
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x0780             LSLS     R0,R0,#+30
   \   00000008   0xD526             BPL.N    ??I2C1_IRQHandler_0
    454            {
    455              I2C_ISR[1]();
   \   0000000A   0x....             LDR.N    R0,??DataTable7_15
   \   0000000C   0x6840             LDR      R0,[R0, #+4]
   \   0000000E   0x4780             BLX      R0
    456              if(I2C1->SMB & I2C_SMB_SLTF_MASK)
   \   00000010   0x....             LDR.N    R0,??DataTable7_19  ;; 0x40067008
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x0700             LSLS     R0,R0,#+28
   \   00000016   0xD505             BPL.N    ??I2C1_IRQHandler_1
    457              {
    458                I2C1->SMB |= I2C_SMB_SLTF_MASK;
   \   00000018   0x....             LDR.N    R0,??DataTable7_19  ;; 0x40067008
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000020   0x....             LDR.N    R1,??DataTable7_19  ;; 0x40067008
   \   00000022   0x7008             STRB     R0,[R1, #+0]
    459              }
    460              if(I2C1->SMB & I2C_SMB_SHTF2_MASK)
   \                     ??I2C1_IRQHandler_1:
   \   00000024   0x....             LDR.N    R0,??DataTable7_19  ;; 0x40067008
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x0780             LSLS     R0,R0,#+30
   \   0000002A   0xD505             BPL.N    ??I2C1_IRQHandler_2
    461              {
    462                I2C1->SMB |= I2C_SMB_SHTF2_MASK;
   \   0000002C   0x....             LDR.N    R0,??DataTable7_19  ;; 0x40067008
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000034   0x....             LDR.N    R1,??DataTable7_19  ;; 0x40067008
   \   00000036   0x7008             STRB     R0,[R1, #+0]
    463              }
    464              if(I2C1->S & I2C_S_ARBL_MASK)
   \                     ??I2C1_IRQHandler_2:
   \   00000038   0x....             LDR.N    R0,??DataTable7_18  ;; 0x40067003
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x06C0             LSLS     R0,R0,#+27
   \   0000003E   0xD505             BPL.N    ??I2C1_IRQHandler_3
    465              {
    466                I2C1->S |= I2C_S_ARBL_MASK;
   \   00000040   0x....             LDR.N    R0,??DataTable7_18  ;; 0x40067003
   \   00000042   0x7800             LDRB     R0,[R0, #+0]
   \   00000044   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000048   0x....             LDR.N    R1,??DataTable7_18  ;; 0x40067003
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
    467              }
    468              I2C1->S |= I2C_S_IICIF_MASK;
   \                     ??I2C1_IRQHandler_3:
   \   0000004C   0x....             LDR.N    R0,??DataTable7_18  ;; 0x40067003
   \   0000004E   0x7800             LDRB     R0,[R0, #+0]
   \   00000050   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000054   0x....             LDR.N    R1,??DataTable7_18  ;; 0x40067003
   \   00000056   0x7008             STRB     R0,[R1, #+0]
    469            }
    470            
    471          #if (UCOS_II > 0u)
    472            OSIntExit();          //告知系统此时即将离开中断服务子函数
    473          #endif
    474          }
   \                     ??I2C1_IRQHandler_0:
   \   00000058   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x40066000         DC32     0x40066000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x4004C020         DC32     0x4004c020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x4004A000         DC32     0x4004a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x4004A008         DC32     0x4004a008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x4004C024         DC32     0x4004c024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x4004A004         DC32     0x4004a004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \   00000000   0x4004A00C         DC32     0x4004a00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \   00000000   0x40067000         DC32     0x40067000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_11:
   \   00000000   0x4004D004         DC32     0x4004d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_12:
   \   00000000   0x4004B028         DC32     0x4004b028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_13:
   \   00000000   0x4004D000         DC32     0x4004d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_14:
   \   00000000   0x4004B02C         DC32     0x4004b02c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_15:
   \   00000000   0x........         DC32     I2C_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_16:
   \   00000000   0x40066003         DC32     0x40066003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_17:
   \   00000000   0x40066008         DC32     0x40066008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_18:
   \   00000000   0x40067003         DC32     0x40067003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_19:
   \   00000000   0x40067008         DC32     0x40067008
    475          
    476          
    477          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  I2C0_IRQHandler
              8 -- Indirect call
        8  I2C1_IRQHandler
              8 -- Indirect call
       24  LPLD_I2C_Deinit
             24 -> NVIC_DisableIRQ
       24  LPLD_I2C_DisableIrq
             24 -> NVIC_DisableIRQ
       24  LPLD_I2C_EnableIrq
             24 -> NVIC_EnableIRQ
       32  LPLD_I2C_Init
        0  LPLD_I2C_ReStart
        0  LPLD_I2C_ReadByte
        0  LPLD_I2C_SetMasterWR
        0  LPLD_I2C_Start
       16  LPLD_I2C_StartTrans
             16 -> LPLD_I2C_Start
             16 -> LPLD_I2C_WriteByte
        0  LPLD_I2C_Stop
        0  LPLD_I2C_WaitAck
        0  LPLD_I2C_WriteByte
        4  NVIC_DisableIRQ
        4  NVIC_EnableIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_14
       4  ??DataTable7_15
       4  ??DataTable7_16
       4  ??DataTable7_17
       4  ??DataTable7_18
       4  ??DataTable7_19
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
      90  I2C0_IRQHandler
      90  I2C1_IRQHandler
       8  I2C_ISR
      74  LPLD_I2C_Deinit
      44  LPLD_I2C_DisableIrq
      36  LPLD_I2C_EnableIrq
     350  LPLD_I2C_Init
      10  LPLD_I2C_ReStart
      10  LPLD_I2C_ReadByte
      26  LPLD_I2C_SetMasterWR
      18  LPLD_I2C_Start
      28  LPLD_I2C_StartTrans
      18  LPLD_I2C_Stop
      46  LPLD_I2C_WaitAck
       4  LPLD_I2C_WriteByte
      26  NVIC_DisableIRQ
      26  NVIC_EnableIRQ

 
   8 bytes in section .bss
 976 bytes in section .text
 
 976 bytes of CODE memory
   8 bytes of DATA memory

Errors: none
Warnings: none
