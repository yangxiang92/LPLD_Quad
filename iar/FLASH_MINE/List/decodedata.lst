###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     08/Aug/2014  19:52:19 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\source\app\ #
#                    Communicate\decodedata.c                                 #
#    Command line =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\source\app\ #
#                    Communicate\decodedata.c -D LPLD_K60 -lCN                #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\FLASH_M #
#                    INE\List\ -lB E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_ #
#                    V3\iar\FLASH_MINE\List\ -o E:\ShawnDocuments\IAR_WorkSpa #
#                    ce\LPLD_Quad_V3\iar\FLASH_MINE\Obj\ --no_cse             #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\app\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\ #
#                    iar\..\source\app\Control\ -I                            #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\app\Others\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Q #
#                    uad_V3\iar\..\source\app\Communicate\ -I                 #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\app\Algorithm\ -I E:\ShawnDocuments\IAR_WorkSpace\LPL #
#                    D_Quad_V3\iar\..\source\app\SignalProcess\ -I            #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\module\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_ #
#                    V3\iar\..\source\module\anbt_dmp\ -I                     #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\module\eMPL\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_ #
#                    Quad_V3\iar\..\source\lib\CPU\ -I                        #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\common\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Q #
#                    uad_V3\iar\..\source\lib\LPLD\ -I                        #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\LPLD\HW\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_ #
#                    Quad_V3\iar\..\source\lib\LPLD\DEV\ -I                   #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\uCOS-II\Ports\ -I E:\ShawnDocuments\IAR_WorkSpace #
#                    \LPLD_Quad_V3\iar\..\source\lib\uCOS-II\Source\ -I       #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\FatFs\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Qu #
#                    ad_V3\iar\..\source\lib\FatFs\option\ -I                 #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\USB\common\ -I E:\ShawnDocuments\IAR_WorkSpace\LP #
#                    LD_Quad_V3\iar\..\source\lib\USB\driver\ -I              #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\USB\descriptor\ -I E:\ShawnDocuments\IAR_WorkSpac #
#                    e\LPLD_Quad_V3\iar\..\source\lib\USB\class\ -I           #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\MyLib\ -On -I "D:\Program Files\IAR               #
#                    Systems\Embedded Workbench 6.4\arm\CMSIS\Include\" -D    #
#                    ARM_MATH_CM4                                             #
#    List file    =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\FLASH_M #
#                    INE\List\decodedata.lst                                  #
#    Object file  =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\FLASH_M #
#                    INE\Obj\decodedata.o                                     #
#                                                                             #
#                                                                             #
###############################################################################

E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\source\app\Communicate\decodedata.c
      1          /****************************************************************************** 
      2           *       decodedata.c ----- Decode the data receved from the uart          *
      3           *       (c) Copyright 2012 HUST RENESAS LAB,The Department of CSE, HUST       *
      4           *                        All Rights Reserved                                  *
      5           *Filename             :  decodedata.c                                           *
      6           *Programmer(s)        :  Yang Xiang                                           *
      7           *Description          :                                                       *
      8           *Modification History :                                                       *
      9           *01a 2014/4/23 15:24:46                                                       *
     10           ******************************************************************************/
     11          #include "decodedata.h"
     12          

   \                                 In section .data, align 4
     13          static uint8 s_u8DecodedFlag[6] = {1,1,1,1,1,1};
   \                     s_u8DecodedFlag:
   \   00000000   0x01 0x01          DC8 1, 1, 1, 1, 1, 1, 0, 0
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x00 0x00    
     14          

   \                                 In section .text, align 2, keep-with-next
     15          uint8 RecvFrame(int8 recv, UART_Type * uartx)
     16          {
   \                     RecvFrame:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     17              uint8 ret = 0;
   \   00000006   0x2600             MOVS     R6,#+0
     18              static uint8 frame_length = 0;
     19              static uint8 frame_state_flag = 0;
     20              static uint8 frame_byte_count = 0;
     21              static uint8 frame_type = 0;
     22          
     23              if(CheckDecodedFlag(uartx) == 1)
   \   00000008   0x0028             MOVS     R0,R5
   \   0000000A   0x.... 0x....      BL       CheckDecodedFlag
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xF040 0x80BF      BNE.W    ??RecvFrame_0
     24              {
     25                  if(frame_state_flag == 0)
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable2
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD115             BNE.N    ??RecvFrame_1
     26                  {
     27                      if(((uint8)recv) == 0xA5)
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x28A5             CMP      R0,#+165
   \   00000024   0xD109             BNE.N    ??RecvFrame_2
     28                      {
     29                          PushUartRecvQueue(uartx, recv);
   \   00000026   0x0021             MOVS     R1,R4
   \   00000028   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0x.... 0x....      BL       PushUartRecvQueue
     30                          frame_state_flag = 1;            
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable2
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x7001             STRB     R1,[R0, #+0]
   \   00000038   0xE0AB             B.N      ??RecvFrame_0
     31                      }
     32                      else
     33                      {
     34                          ClearUartRecvQueue(uartx);
   \                     ??RecvFrame_2:
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0x.... 0x....      BL       ClearUartRecvQueue
     35                          frame_state_flag = 0;
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable2
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x7001             STRB     R1,[R0, #+0]
   \   00000048   0xE0A3             B.N      ??RecvFrame_0
     36                      }
     37                  }
     38          
     39                  else if(frame_state_flag == 1)
   \                     ??RecvFrame_1:
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable2
   \   0000004E   0x7800             LDRB     R0,[R0, #+0]
   \   00000050   0x2801             CMP      R0,#+1
   \   00000052   0xD119             BNE.N    ??RecvFrame_3
     40                  {
     41                      if(((uint8)recv) == 0x5A)
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0x285A             CMP      R0,#+90
   \   0000005A   0xD10D             BNE.N    ??RecvFrame_4
     42                      {
     43                          PushUartRecvQueue(uartx, recv);
   \   0000005C   0x0021             MOVS     R1,R4
   \   0000005E   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   00000060   0x0028             MOVS     R0,R5
   \   00000062   0x.... 0x....      BL       PushUartRecvQueue
     44                          frame_state_flag = 2;
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable2
   \   0000006A   0x2102             MOVS     R1,#+2
   \   0000006C   0x7001             STRB     R1,[R0, #+0]
     45                          frame_byte_count = 0;
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable2_1
   \   00000072   0x2100             MOVS     R1,#+0
   \   00000074   0x7001             STRB     R1,[R0, #+0]
   \   00000076   0xE08C             B.N      ??RecvFrame_0
     46                      }
     47                      else
     48                      {
     49                          ClearUartRecvQueue(uartx);
   \                     ??RecvFrame_4:
   \   00000078   0x0028             MOVS     R0,R5
   \   0000007A   0x.... 0x....      BL       ClearUartRecvQueue
     50                          frame_state_flag = 0;
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable2
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0x7001             STRB     R1,[R0, #+0]
   \   00000086   0xE084             B.N      ??RecvFrame_0
     51                      }
     52                  }
     53          
     54                  else if(frame_state_flag == 2)
   \                     ??RecvFrame_3:
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable2
   \   0000008C   0x7800             LDRB     R0,[R0, #+0]
   \   0000008E   0x2802             CMP      R0,#+2
   \   00000090   0xD121             BNE.N    ??RecvFrame_5
     55                  {
     56                      frame_length = (uint8) recv;
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable2_2
   \   00000096   0x7004             STRB     R4,[R0, #+0]
     57                      if((frame_length > 2) && (frame_length < 50))
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable2_2
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0x2803             CMP      R0,#+3
   \   000000A0   0xD312             BCC.N    ??RecvFrame_6
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable2_2
   \   000000A6   0x7800             LDRB     R0,[R0, #+0]
   \   000000A8   0x2832             CMP      R0,#+50
   \   000000AA   0xD20D             BCS.N    ??RecvFrame_6
     58                      {
     59                          PushUartRecvQueue(uartx, recv);
   \   000000AC   0x0021             MOVS     R1,R4
   \   000000AE   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   000000B0   0x0028             MOVS     R0,R5
   \   000000B2   0x.... 0x....      BL       PushUartRecvQueue
     60                          frame_byte_count ++;
   \   000000B6   0x....             LDR.N    R0,??DataTable2_1
   \   000000B8   0x7800             LDRB     R0,[R0, #+0]
   \   000000BA   0x1C40             ADDS     R0,R0,#+1
   \   000000BC   0x....             LDR.N    R1,??DataTable2_1
   \   000000BE   0x7008             STRB     R0,[R1, #+0]
     61                          frame_state_flag = 3;
   \   000000C0   0x....             LDR.N    R0,??DataTable2
   \   000000C2   0x2103             MOVS     R1,#+3
   \   000000C4   0x7001             STRB     R1,[R0, #+0]
   \   000000C6   0xE064             B.N      ??RecvFrame_0
     62                      }
     63                      else
     64                      {
     65                          ClearUartRecvQueue(uartx);
   \                     ??RecvFrame_6:
   \   000000C8   0x0028             MOVS     R0,R5
   \   000000CA   0x.... 0x....      BL       ClearUartRecvQueue
     66                          frame_state_flag = 0;        
   \   000000CE   0x....             LDR.N    R0,??DataTable2
   \   000000D0   0x2100             MOVS     R1,#+0
   \   000000D2   0x7001             STRB     R1,[R0, #+0]
   \   000000D4   0xE05D             B.N      ??RecvFrame_0
     67                      }
     68                  }
     69          
     70                  else if(frame_state_flag == 3)
   \                     ??RecvFrame_5:
   \   000000D6   0x....             LDR.N    R0,??DataTable2
   \   000000D8   0x7800             LDRB     R0,[R0, #+0]
   \   000000DA   0x2803             CMP      R0,#+3
   \   000000DC   0xD10F             BNE.N    ??RecvFrame_7
     71                  {
     72                      PushUartRecvQueue(uartx, recv);
   \   000000DE   0x0021             MOVS     R1,R4
   \   000000E0   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   000000E2   0x0028             MOVS     R0,R5
   \   000000E4   0x.... 0x....      BL       PushUartRecvQueue
     73                      frame_type = (uint8)recv;
   \   000000E8   0x....             LDR.N    R0,??DataTable2_3
   \   000000EA   0x7004             STRB     R4,[R0, #+0]
     74                      frame_byte_count ++;
   \   000000EC   0x....             LDR.N    R0,??DataTable2_1
   \   000000EE   0x7800             LDRB     R0,[R0, #+0]
   \   000000F0   0x1C40             ADDS     R0,R0,#+1
   \   000000F2   0x....             LDR.N    R1,??DataTable2_1
   \   000000F4   0x7008             STRB     R0,[R1, #+0]
     75                      frame_state_flag = 4;
   \   000000F6   0x....             LDR.N    R0,??DataTable2
   \   000000F8   0x2104             MOVS     R1,#+4
   \   000000FA   0x7001             STRB     R1,[R0, #+0]
   \   000000FC   0xE049             B.N      ??RecvFrame_0
     76                  }
     77          
     78                  else if(frame_state_flag == 4)
   \                     ??RecvFrame_7:
   \   000000FE   0x....             LDR.N    R0,??DataTable2
   \   00000100   0x7800             LDRB     R0,[R0, #+0]
   \   00000102   0x2804             CMP      R0,#+4
   \   00000104   0xD121             BNE.N    ??RecvFrame_8
     79                  {
     80                      if(frame_byte_count < frame_length )
   \   00000106   0x....             LDR.N    R0,??DataTable2_1
   \   00000108   0x7800             LDRB     R0,[R0, #+0]
   \   0000010A   0x....             LDR.N    R1,??DataTable2_2
   \   0000010C   0x7809             LDRB     R1,[R1, #+0]
   \   0000010E   0x4288             CMP      R0,R1
   \   00000110   0xD214             BCS.N    ??RecvFrame_9
     81                      {
     82                          if(frame_byte_count == (frame_length - 1))
   \   00000112   0x....             LDR.N    R0,??DataTable2_1
   \   00000114   0x7800             LDRB     R0,[R0, #+0]
   \   00000116   0x....             LDR.N    R1,??DataTable2_2
   \   00000118   0x7809             LDRB     R1,[R1, #+0]
   \   0000011A   0x1E49             SUBS     R1,R1,#+1
   \   0000011C   0x4288             CMP      R0,R1
   \   0000011E   0xD102             BNE.N    ??RecvFrame_10
     83                          {
     84                              frame_state_flag = 5;
   \   00000120   0x....             LDR.N    R0,??DataTable2
   \   00000122   0x2105             MOVS     R1,#+5
   \   00000124   0x7001             STRB     R1,[R0, #+0]
     85                          }            
     86                          PushUartRecvQueue(uartx, recv);
   \                     ??RecvFrame_10:
   \   00000126   0x0021             MOVS     R1,R4
   \   00000128   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   0000012A   0x0028             MOVS     R0,R5
   \   0000012C   0x.... 0x....      BL       PushUartRecvQueue
     87                          frame_byte_count ++;
   \   00000130   0x....             LDR.N    R0,??DataTable2_1
   \   00000132   0x7800             LDRB     R0,[R0, #+0]
   \   00000134   0x1C40             ADDS     R0,R0,#+1
   \   00000136   0x....             LDR.N    R1,??DataTable2_1
   \   00000138   0x7008             STRB     R0,[R1, #+0]
   \   0000013A   0xE02A             B.N      ??RecvFrame_0
     88                      }
     89                      else
     90                      {
     91                          ClearUartRecvQueue(uartx);
   \                     ??RecvFrame_9:
   \   0000013C   0x0028             MOVS     R0,R5
   \   0000013E   0x.... 0x....      BL       ClearUartRecvQueue
     92                          frame_state_flag = 0;
   \   00000142   0x....             LDR.N    R0,??DataTable2
   \   00000144   0x2100             MOVS     R1,#+0
   \   00000146   0x7001             STRB     R1,[R0, #+0]
   \   00000148   0xE023             B.N      ??RecvFrame_0
     93                      }
     94                  }    
     95          
     96                  else if(frame_state_flag == 5)
   \                     ??RecvFrame_8:
   \   0000014A   0x....             LDR.N    R0,??DataTable2
   \   0000014C   0x7800             LDRB     R0,[R0, #+0]
   \   0000014E   0x2805             CMP      R0,#+5
   \   00000150   0xD119             BNE.N    ??RecvFrame_11
     97                  {
     98                      if(((uint8)recv) == 0xAA)
   \   00000152   0x0020             MOVS     R0,R4
   \   00000154   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000156   0x28AA             CMP      R0,#+170
   \   00000158   0xD10E             BNE.N    ??RecvFrame_12
     99                      {
    100                          PushUartRecvQueue(uartx, recv);
   \   0000015A   0x0021             MOVS     R1,R4
   \   0000015C   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   0000015E   0x0028             MOVS     R0,R5
   \   00000160   0x.... 0x....      BL       PushUartRecvQueue
    101                          frame_state_flag = 0;
   \   00000164   0x....             LDR.N    R0,??DataTable2
   \   00000166   0x2100             MOVS     R1,#+0
   \   00000168   0x7001             STRB     R1,[R0, #+0]
    102                          ret = frame_type;
   \   0000016A   0x....             LDR.N    R0,??DataTable2_3
   \   0000016C   0x7800             LDRB     R0,[R0, #+0]
   \   0000016E   0x0006             MOVS     R6,R0
    103                          ClearDecodedFlag(uartx);
   \   00000170   0x0028             MOVS     R0,R5
   \   00000172   0x.... 0x....      BL       ClearDecodedFlag
   \   00000176   0xE00C             B.N      ??RecvFrame_0
    104                      }
    105                      else
    106                      {
    107                          ClearUartRecvQueue(uartx);
   \                     ??RecvFrame_12:
   \   00000178   0x0028             MOVS     R0,R5
   \   0000017A   0x.... 0x....      BL       ClearUartRecvQueue
    108                          frame_state_flag = 0;
   \   0000017E   0x....             LDR.N    R0,??DataTable2
   \   00000180   0x2100             MOVS     R1,#+0
   \   00000182   0x7001             STRB     R1,[R0, #+0]
   \   00000184   0xE005             B.N      ??RecvFrame_0
    109                      }        
    110                  }
    111          
    112                  else
    113                  {
    114                      ClearUartRecvQueue(uartx);
   \                     ??RecvFrame_11:
   \   00000186   0x0028             MOVS     R0,R5
   \   00000188   0x.... 0x....      BL       ClearUartRecvQueue
    115                      frame_state_flag = 0;
   \   0000018C   0x....             LDR.N    R0,??DataTable2
   \   0000018E   0x2100             MOVS     R1,#+0
   \   00000190   0x7001             STRB     R1,[R0, #+0]
    116                  }
    117              }
    118          
    119              return ret;
   \                     ??RecvFrame_0:
   \   00000192   0x0030             MOVS     R0,R6
   \   00000194   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000196   0xBD70             POP      {R4-R6,PC}       ;; return
    120          }

   \                                 In section .bss, align 1
   \                     ??frame_length:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     ??frame_state_flag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     ??frame_byte_count:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     ??frame_type:
   \   00000000                      DS8 1
    121          

   \                                 In section .text, align 2, keep-with-next
    122          uint8 DecodeControlParaData(TransferControlParaData * ctrl_para_data, UART_Type * uartx)
    123          {
   \                     DecodeControlParaData:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB094             SUB      SP,SP,#+80
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    124              uint8 ret = 1;
   \   0000000A   0x2601             MOVS     R6,#+1
    125              int i = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    126              int8 data_buf[64];
    127              int16 queue_size = GetUartRecvQueueSize(uartx);
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0x.... 0x....      BL       GetUartRecvQueueSize
   \   00000016   0x0007             MOVS     R7,R0
    128              TransferControlParaDataFrame ctrl_data_frame;
    129          
    130              if(queue_size != sizeof(TransferControlParaDataFrame))
   \   00000018   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000001A   0x2F0F             CMP      R7,#+15
   \   0000001C   0xD001             BEQ.N    ??DecodeControlParaData_0
    131              {
    132                  ret = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x0006             MOVS     R6,R0
    133              }
    134          
    135              for(i = 0; i < sizeof(TransferControlParaDataFrame); i++)
   \                     ??DecodeControlParaData_0:
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x4680             MOV      R8,R0
   \                     ??DecodeControlParaData_1:
   \   00000026   0xF1B8 0x0F0F      CMP      R8,#+15
   \   0000002A   0xD208             BCS.N    ??DecodeControlParaData_2
    136              {
    137                  data_buf[i] = PopUartRecvQueue(uartx);
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0x.... 0x....      BL       PopUartRecvQueue
   \   00000032   0xA904             ADD      R1,SP,#+16
   \   00000034   0xF808 0x0001      STRB     R0,[R8, R1]
    138              }
   \   00000038   0xF118 0x0801      ADDS     R8,R8,#+1
   \   0000003C   0xE7F3             B.N      ??DecodeControlParaData_1
    139          
    140              ctrl_data_frame = *((TransferControlParaDataFrame*)data_buf);
   \                     ??DecodeControlParaData_2:
   \   0000003E   0xA800             ADD      R0,SP,#+0
   \   00000040   0xA904             ADD      R1,SP,#+16
   \   00000042   0x220F             MOVS     R2,#+15
   \   00000044   0x.... 0x....      BL       __aeabi_memcpy4
    141          
    142              if(ctrl_data_frame.frame_type != 0x01)
   \   00000048   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xD001             BEQ.N    ??DecodeControlParaData_3
    143              {
    144                  ret = 0;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x0006             MOVS     R6,R0
    145              }
    146              if(ctrl_data_frame.header1 != 0xA5)
   \                     ??DecodeControlParaData_3:
   \   00000054   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000058   0x28A5             CMP      R0,#+165
   \   0000005A   0xD001             BEQ.N    ??DecodeControlParaData_4
    147              {
    148                  ret = 0;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x0006             MOVS     R6,R0
    149              }
    150              if(ctrl_data_frame.header2 != 0x5A)
   \                     ??DecodeControlParaData_4:
   \   00000060   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000064   0x285A             CMP      R0,#+90
   \   00000066   0xD001             BEQ.N    ??DecodeControlParaData_5
    151              {
    152                  ret = 0;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x0006             MOVS     R6,R0
    153              }
    154              if(ctrl_data_frame.frame_size != sizeof(TransferControlParaDataFrame) - 3)
   \                     ??DecodeControlParaData_5:
   \   0000006C   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000070   0x280C             CMP      R0,#+12
   \   00000072   0xD001             BEQ.N    ??DecodeControlParaData_6
    155              {
    156                  ret = 0;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x0006             MOVS     R6,R0
    157              }
    158              if(ctrl_data_frame.ender != 0xAA)
   \                     ??DecodeControlParaData_6:
   \   00000078   0xF89D 0x000E      LDRB     R0,[SP, #+14]
   \   0000007C   0x28AA             CMP      R0,#+170
   \   0000007E   0xD001             BEQ.N    ??DecodeControlParaData_7
    159              {
    160                  ret = 0;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x0006             MOVS     R6,R0
    161              }
    162              if(CalculateCrc16_HalfByte((uint8 *)(&ctrl_data_frame) + 2, sizeof(TransferControlParaDataFrame) - 3) != 0)
   \                     ??DecodeControlParaData_7:
   \   00000084   0x210C             MOVS     R1,#+12
   \   00000086   0xF10D 0x0002      ADD      R0,SP,#+2
   \   0000008A   0x.... 0x....      BL       CalculateCrc16_HalfByte
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD001             BEQ.N    ??DecodeControlParaData_8
    163              {
    164                  ret = 0;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x0006             MOVS     R6,R0
    165              }
    166          
    167              SetDecodedFlag(uartx);
   \                     ??DecodeControlParaData_8:
   \   00000096   0x0028             MOVS     R0,R5
   \   00000098   0x.... 0x....      BL       SetDecodedFlag
    168              ClearUartRecvQueue(uartx);   
   \   0000009C   0x0028             MOVS     R0,R5
   \   0000009E   0x.... 0x....      BL       ClearUartRecvQueue
    169              if(ret == 1)
   \   000000A2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A4   0x2E01             CMP      R6,#+1
   \   000000A6   0xD103             BNE.N    ??DecodeControlParaData_9
    170              { 
    171                  *ctrl_para_data = ctrl_data_frame.data;
   \   000000A8   0xE9DD 0x0101      LDRD     R0,R1,[SP, #+4]
   \   000000AC   0xE9C4 0x0100      STRD     R0,R1,[R4, #+0]
    172              }
    173              return ret;
   \                     ??DecodeControlParaData_9:
   \   000000B0   0x0030             MOVS     R0,R6
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B4   0xB014             ADD      SP,SP,#+80
   \   000000B6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    174          }
    175          

   \                                 In section .text, align 2, keep-with-next
    176          uint8 DecodePX4FLOWData(PX4FLOW_Data * p_px4flow_data, UART_Type * uartx)
    177          {
   \                     DecodePX4FLOWData:
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB097             SUB      SP,SP,#+92
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    178              uint8 ret = 1;
   \   0000000A   0x2601             MOVS     R6,#+1
    179              int i = 0;
   \   0000000C   0x2700             MOVS     R7,#+0
    180              int8 data_buf[64];
    181              int16 queue_size = GetUartRecvQueueSize(uartx);
   \   0000000E   0x0028             MOVS     R0,R5
   \   00000010   0x.... 0x....      BL       GetUartRecvQueueSize
   \   00000014   0x4680             MOV      R8,R0
    182              int16 frame_size = sizeof(PX4FLOW_DataFrame);
   \   00000016   0xF05F 0x091B      MOVS     R9,#+27
    183              PX4FLOW_DataFrame px4flow_data_frame;
    184          
    185              if(queue_size != frame_size)
   \   0000001A   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   0000001E   0xFA0F 0xF989      SXTH     R9,R9            ;; SignExt  R9,R9,#+16,#+16
   \   00000022   0x45C8             CMP      R8,R9
   \   00000024   0xD001             BEQ.N    ??DecodePX4FLOWData_0
    186              {
    187                  ret = 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x0006             MOVS     R6,R0
    188              }
    189          
    190              for(i = 0; i < frame_size; i++)
   \                     ??DecodePX4FLOWData_0:
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x0007             MOVS     R7,R0
   \                     ??DecodePX4FLOWData_1:
   \   0000002E   0xFA0F 0xF989      SXTH     R9,R9            ;; SignExt  R9,R9,#+16,#+16
   \   00000032   0x454F             CMP      R7,R9
   \   00000034   0xDA06             BGE.N    ??DecodePX4FLOWData_2
    191              {
    192                  data_buf[i] = PopUartRecvQueue(uartx);
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0x.... 0x....      BL       PopUartRecvQueue
   \   0000003C   0xA907             ADD      R1,SP,#+28
   \   0000003E   0x5478             STRB     R0,[R7, R1]
    193              }
   \   00000040   0x1C7F             ADDS     R7,R7,#+1
   \   00000042   0xE7F4             B.N      ??DecodePX4FLOWData_1
    194          
    195              px4flow_data_frame = *((PX4FLOW_DataFrame*)data_buf);
   \                     ??DecodePX4FLOWData_2:
   \   00000044   0xA800             ADD      R0,SP,#+0
   \   00000046   0xA907             ADD      R1,SP,#+28
   \   00000048   0x221B             MOVS     R2,#+27
   \   0000004A   0x.... 0x....      BL       __aeabi_memcpy4
    196          
    197              if(px4flow_data_frame.frame_type != 0x03)
   \   0000004E   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000052   0x2803             CMP      R0,#+3
   \   00000054   0xD001             BEQ.N    ??DecodePX4FLOWData_3
    198              {
    199                  ret = 0;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x0006             MOVS     R6,R0
    200              }
    201              if(px4flow_data_frame.header1 != 0xA5)
   \                     ??DecodePX4FLOWData_3:
   \   0000005A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005E   0x28A5             CMP      R0,#+165
   \   00000060   0xD001             BEQ.N    ??DecodePX4FLOWData_4
    202              {
    203                  ret = 0;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x0006             MOVS     R6,R0
    204              }
    205              if(px4flow_data_frame.header2 != 0x5A)
   \                     ??DecodePX4FLOWData_4:
   \   00000066   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000006A   0x285A             CMP      R0,#+90
   \   0000006C   0xD001             BEQ.N    ??DecodePX4FLOWData_5
    206              {
    207                  ret = 0;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x0006             MOVS     R6,R0
    208              }
    209              if(px4flow_data_frame.frame_size != frame_size - 3)
   \                     ??DecodePX4FLOWData_5:
   \   00000072   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000076   0xFA0F 0xF989      SXTH     R9,R9            ;; SignExt  R9,R9,#+16,#+16
   \   0000007A   0xF1B9 0x0103      SUBS     R1,R9,#+3
   \   0000007E   0x4288             CMP      R0,R1
   \   00000080   0xD001             BEQ.N    ??DecodePX4FLOWData_6
    210              {
    211                  ret = 0;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x0006             MOVS     R6,R0
    212              }
    213              if(px4flow_data_frame.ender != 0xAA)
   \                     ??DecodePX4FLOWData_6:
   \   00000086   0xF89D 0x001A      LDRB     R0,[SP, #+26]
   \   0000008A   0x28AA             CMP      R0,#+170
   \   0000008C   0xD001             BEQ.N    ??DecodePX4FLOWData_7
    214              {
    215                  ret = 0;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x0006             MOVS     R6,R0
    216              }
    217              if(CalculateCrc16_HalfByte((uint8 *)(&px4flow_data_frame) + 2, frame_size - 3) != 0)
   \                     ??DecodePX4FLOWData_7:
   \   00000092   0xF1B9 0x0103      SUBS     R1,R9,#+3
   \   00000096   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000098   0xF10D 0x0002      ADD      R0,SP,#+2
   \   0000009C   0x.... 0x....      BL       CalculateCrc16_HalfByte
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD001             BEQ.N    ??DecodePX4FLOWData_8
    218              {
    219                  ret = 0;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x0006             MOVS     R6,R0
    220              }
    221          
    222              SetDecodedFlag(uartx);
   \                     ??DecodePX4FLOWData_8:
   \   000000A8   0x0028             MOVS     R0,R5
   \   000000AA   0x.... 0x....      BL       SetDecodedFlag
    223              ClearUartRecvQueue(uartx);   
   \   000000AE   0x0028             MOVS     R0,R5
   \   000000B0   0x.... 0x....      BL       ClearUartRecvQueue
    224              if(ret == 1)
   \   000000B4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000B6   0x2E01             CMP      R6,#+1
   \   000000B8   0xD104             BNE.N    ??DecodePX4FLOWData_9
    225              { 
    226                  *p_px4flow_data = px4flow_data_frame.data;
   \   000000BA   0x0020             MOVS     R0,R4
   \   000000BC   0xA901             ADD      R1,SP,#+4
   \   000000BE   0x2214             MOVS     R2,#+20
   \   000000C0   0x.... 0x....      BL       __aeabi_memcpy
    227              }
    228              return ret;
   \                     ??DecodePX4FLOWData_9:
   \   000000C4   0x0030             MOVS     R0,R6
   \   000000C6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C8   0xB017             ADD      SP,SP,#+92
   \   000000CA   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    229          }
    230          

   \                                 In section .text, align 2, keep-with-next
    231          uint8 CheckDecodedFlag(UART_Type * uartx)
    232          {
   \                     CheckDecodedFlag:
   \   00000000   0x0001             MOVS     R1,R0
    233              if(uartx == UART0)
   \   00000002   0x....             LDR.N    R0,??DataTable2_4  ;; 0x4006a000
   \   00000004   0x4281             CMP      R1,R0
   \   00000006   0xD102             BNE.N    ??CheckDecodedFlag_0
    234              {
    235                  return s_u8DecodedFlag[0];
   \   00000008   0x....             LDR.N    R0,??DataTable2_5
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0xE01E             B.N      ??CheckDecodedFlag_1
    236              }
    237              else if(uartx == UART1)
   \                     ??CheckDecodedFlag_0:
   \   0000000E   0x....             LDR.N    R0,??DataTable2_6  ;; 0x4006b000
   \   00000010   0x4281             CMP      R1,R0
   \   00000012   0xD102             BNE.N    ??CheckDecodedFlag_2
    238              {
    239                  return s_u8DecodedFlag[1];
   \   00000014   0x....             LDR.N    R0,??DataTable2_5
   \   00000016   0x7840             LDRB     R0,[R0, #+1]
   \   00000018   0xE018             B.N      ??CheckDecodedFlag_1
    240              }
    241              else if(uartx == UART2)
   \                     ??CheckDecodedFlag_2:
   \   0000001A   0x....             LDR.N    R0,??DataTable2_7  ;; 0x4006c000
   \   0000001C   0x4281             CMP      R1,R0
   \   0000001E   0xD102             BNE.N    ??CheckDecodedFlag_3
    242              {
    243                  return s_u8DecodedFlag[2];
   \   00000020   0x....             LDR.N    R0,??DataTable2_5
   \   00000022   0x7880             LDRB     R0,[R0, #+2]
   \   00000024   0xE012             B.N      ??CheckDecodedFlag_1
    244              }
    245              else if(uartx == UART3)
   \                     ??CheckDecodedFlag_3:
   \   00000026   0x....             LDR.N    R0,??DataTable2_8  ;; 0x4006d000
   \   00000028   0x4281             CMP      R1,R0
   \   0000002A   0xD102             BNE.N    ??CheckDecodedFlag_4
    246              {
    247                  return s_u8DecodedFlag[3];
   \   0000002C   0x....             LDR.N    R0,??DataTable2_5
   \   0000002E   0x78C0             LDRB     R0,[R0, #+3]
   \   00000030   0xE00C             B.N      ??CheckDecodedFlag_1
    248              }
    249              else if(uartx == UART4)
   \                     ??CheckDecodedFlag_4:
   \   00000032   0x....             LDR.N    R0,??DataTable2_9  ;; 0x400ea000
   \   00000034   0x4281             CMP      R1,R0
   \   00000036   0xD102             BNE.N    ??CheckDecodedFlag_5
    250              {
    251                  return s_u8DecodedFlag[4];
   \   00000038   0x....             LDR.N    R0,??DataTable2_5
   \   0000003A   0x7900             LDRB     R0,[R0, #+4]
   \   0000003C   0xE006             B.N      ??CheckDecodedFlag_1
    252              }
    253              else if(uartx == UART5)
   \                     ??CheckDecodedFlag_5:
   \   0000003E   0x....             LDR.N    R0,??DataTable2_10  ;; 0x400eb000
   \   00000040   0x4281             CMP      R1,R0
   \   00000042   0xD102             BNE.N    ??CheckDecodedFlag_6
    254              {
    255                  return s_u8DecodedFlag[5];
   \   00000044   0x....             LDR.N    R0,??DataTable2_5
   \   00000046   0x7940             LDRB     R0,[R0, #+5]
   \   00000048   0xE000             B.N      ??CheckDecodedFlag_1
    256              }
    257              else 
    258              {
    259                  return 0;
   \                     ??CheckDecodedFlag_6:
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??CheckDecodedFlag_1:
   \   0000004C   0x4770             BX       LR               ;; return
    260              }
    261          }
    262          

   \                                 In section .text, align 2, keep-with-next
    263          void SetDecodedFlagState(UART_Type * uartx, uint8 state)
    264          {
    265              if(uartx == UART0)
   \                     SetDecodedFlagState:
   \   00000000   0x....             LDR.N    R2,??DataTable2_4  ;; 0x4006a000
   \   00000002   0x4290             CMP      R0,R2
   \   00000004   0xD102             BNE.N    ??SetDecodedFlagState_0
    266              {
    267                  s_u8DecodedFlag[0] = state;
   \   00000006   0x....             LDR.N    R2,??DataTable2_5
   \   00000008   0x7011             STRB     R1,[R2, #+0]
   \   0000000A   0xE01C             B.N      ??SetDecodedFlagState_1
    268              }
    269              else if(uartx == UART1)
   \                     ??SetDecodedFlagState_0:
   \   0000000C   0x....             LDR.N    R2,??DataTable2_6  ;; 0x4006b000
   \   0000000E   0x4290             CMP      R0,R2
   \   00000010   0xD102             BNE.N    ??SetDecodedFlagState_2
    270              {
    271                  s_u8DecodedFlag[1] = state;
   \   00000012   0x....             LDR.N    R2,??DataTable2_5
   \   00000014   0x7051             STRB     R1,[R2, #+1]
   \   00000016   0xE016             B.N      ??SetDecodedFlagState_1
    272              }
    273              else if(uartx == UART2)
   \                     ??SetDecodedFlagState_2:
   \   00000018   0x....             LDR.N    R2,??DataTable2_7  ;; 0x4006c000
   \   0000001A   0x4290             CMP      R0,R2
   \   0000001C   0xD102             BNE.N    ??SetDecodedFlagState_3
    274              {
    275                  s_u8DecodedFlag[2] = state;
   \   0000001E   0x....             LDR.N    R2,??DataTable2_5
   \   00000020   0x7091             STRB     R1,[R2, #+2]
   \   00000022   0xE010             B.N      ??SetDecodedFlagState_1
    276              }
    277              else if(uartx == UART3)
   \                     ??SetDecodedFlagState_3:
   \   00000024   0x....             LDR.N    R2,??DataTable2_8  ;; 0x4006d000
   \   00000026   0x4290             CMP      R0,R2
   \   00000028   0xD102             BNE.N    ??SetDecodedFlagState_4
    278              {
    279                  s_u8DecodedFlag[3] = state;
   \   0000002A   0x....             LDR.N    R2,??DataTable2_5
   \   0000002C   0x70D1             STRB     R1,[R2, #+3]
   \   0000002E   0xE00A             B.N      ??SetDecodedFlagState_1
    280              }
    281              else if(uartx == UART4)
   \                     ??SetDecodedFlagState_4:
   \   00000030   0x....             LDR.N    R2,??DataTable2_9  ;; 0x400ea000
   \   00000032   0x4290             CMP      R0,R2
   \   00000034   0xD102             BNE.N    ??SetDecodedFlagState_5
    282              {
    283                  s_u8DecodedFlag[4] = state;
   \   00000036   0x....             LDR.N    R2,??DataTable2_5
   \   00000038   0x7111             STRB     R1,[R2, #+4]
   \   0000003A   0xE004             B.N      ??SetDecodedFlagState_1
    284              }
    285              else if(uartx == UART5)
   \                     ??SetDecodedFlagState_5:
   \   0000003C   0x....             LDR.N    R2,??DataTable2_10  ;; 0x400eb000
   \   0000003E   0x4290             CMP      R0,R2
   \   00000040   0xD101             BNE.N    ??SetDecodedFlagState_1
    286              {
    287                  s_u8DecodedFlag[5] = state;
   \   00000042   0x....             LDR.N    R2,??DataTable2_5
   \   00000044   0x7151             STRB     R1,[R2, #+5]
    288              }
    289          }
   \                     ??SetDecodedFlagState_1:
   \   00000046   0x4770             BX       LR               ;; return
    290          

   \                                 In section .text, align 2, keep-with-next
    291          void SetDecodedFlag(UART_Type * uartx)
    292          {
   \                     SetDecodedFlag:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    293              SetDecodedFlagState(uartx, 1);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       SetDecodedFlagState
    294          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    295          

   \                                 In section .text, align 2, keep-with-next
    296          void ClearDecodedFlag(UART_Type * uartx)
    297          {
   \                     ClearDecodedFlag:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    298              SetDecodedFlagState(uartx, 0);
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       SetDecodedFlagState
    299          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     ??frame_state_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     ??frame_byte_count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     ??frame_length

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     ??frame_type

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x4006A000         DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x........         DC32     s_u8DecodedFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x4006B000         DC32     0x4006b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x4006C000         DC32     0x4006c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x4006D000         DC32     0x4006d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0x400EA000         DC32     0x400ea000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \   00000000   0x400EB000         DC32     0x400eb000

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  CheckDecodedFlag
        8  ClearDecodedFlag
               8 -> SetDecodedFlagState
      104  DecodeControlParaData
             104 -> CalculateCrc16_HalfByte
             104 -> ClearUartRecvQueue
             104 -> GetUartRecvQueueSize
             104 -> PopUartRecvQueue
             104 -> SetDecodedFlag
             104 -> __aeabi_memcpy4
      120  DecodePX4FLOWData
             120 -> CalculateCrc16_HalfByte
             120 -> ClearUartRecvQueue
             120 -> GetUartRecvQueueSize
             120 -> PopUartRecvQueue
             120 -> SetDecodedFlag
             120 -> __aeabi_memcpy
             120 -> __aeabi_memcpy4
       16  RecvFrame
              16 -> CheckDecodedFlag
              16 -> ClearDecodedFlag
              16 -> ClearUartRecvQueue
              16 -> PushUartRecvQueue
        8  SetDecodedFlag
               8 -> SetDecodedFlagState
        0  SetDecodedFlagState


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
      78  CheckDecodedFlag
      14  ClearDecodedFlag
     186  DecodeControlParaData
     206  DecodePX4FLOWData
     408  RecvFrame
      14  SetDecodedFlag
      72  SetDecodedFlagState
       1  frame_byte_count
       1  frame_length
       1  frame_state_flag
       1  frame_type
       8  s_u8DecodedFlag

 
     4 bytes in section .bss
     8 bytes in section .data
 1 022 bytes in section .text
 
 1 022 bytes of CODE memory
    12 bytes of DATA memory

Errors: none
Warnings: none
