###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     27/Mar/2014  21:01:20 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\source\lib\ #
#                    MyLib\xprintf.c                                          #
#    Command line =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\source\lib\ #
#                    MyLib\xprintf.c -D LPLD_K60 -lCN                         #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\FLASH_M #
#                    INE\List\ -lB E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_ #
#                    V2\iar\FLASH_MINE\List\ -o E:\ShawnDocuments\IAR_WorkSpa #
#                    ce\LPLD_Quad_V2\iar\FLASH_MINE\Obj\ --no_cse             #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\sour #
#                    ce\app\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\ #
#                    iar\..\source\module\ -I E:\ShawnDocuments\IAR_WorkSpace #
#                    \LPLD_Quad_V2\iar\..\source\lib\CPU\ -I                  #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\sour #
#                    ce\lib\common\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Q #
#                    uad_V2\iar\..\source\lib\LPLD\ -I                        #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\sour #
#                    ce\lib\LPLD\HW\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_ #
#                    Quad_V2\iar\..\source\lib\LPLD\DEV\ -I                   #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\sour #
#                    ce\lib\uCOS-II\Ports\ -I E:\ShawnDocuments\IAR_WorkSpace #
#                    \LPLD_Quad_V2\iar\..\source\lib\uCOS-II\Source\ -I       #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\sour #
#                    ce\lib\FatFs\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Qu #
#                    ad_V2\iar\..\source\lib\FatFs\option\ -I                 #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\sour #
#                    ce\lib\USB\common\ -I E:\ShawnDocuments\IAR_WorkSpace\LP #
#                    LD_Quad_V2\iar\..\source\lib\USB\driver\ -I              #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\sour #
#                    ce\lib\USB\descriptor\ -I E:\ShawnDocuments\IAR_WorkSpac #
#                    e\LPLD_Quad_V2\iar\..\source\lib\USB\class\ -I           #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\sour #
#                    ce\lib\MyLib\ -On -I "D:\Program Files\IAR               #
#                    Systems\Embedded Workbench 6.4\arm\CMSIS\Include\" -D    #
#                    ARM_MATH_CM4                                             #
#    List file    =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\FLASH_M #
#                    INE\List\xprintf.lst                                     #
#    Object file  =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\FLASH_M #
#                    INE\Obj\xprintf.o                                        #
#                                                                             #
#                                                                             #
###############################################################################

E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\source\lib\MyLib\xprintf.c
      1          /*------------------------------------------------------------------------/
      2          /  Universal string handler for user console interface
      3          /-------------------------------------------------------------------------/
      4          /
      5          /  Copyright (C) 2011, ChaN, all right reserved.
      6          /
      7          / * This software is a free software and there is NO WARRANTY.
      8          / * No restriction on use. You can use, modify and redistribute it for
      9          /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
     10          / * Redistributions of source code must retain the above copyright notice.
     11          /
     12          /-------------------------------------------------------------------------*/
     13          
     14          #include "xprintf.h"
     15          
     16          
     17          #if _USE_XFUNC_OUT
     18          #include <stdarg.h>

   \                                 In section .bss, align 4
     19          void (*xfunc_out)(unsigned char);	/* Pointer to the output stream */
   \                     xfunc_out:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     20          static char *outptr;
   \                     outptr:
   \   00000000                      DS8 4
     21          
     22          /*----------------------------------------------*/
     23          /* Put a character                              */
     24          /*----------------------------------------------*/
     25          

   \                                 In section .text, align 2, keep-with-next
     26          void xputc (char c)
     27          {
   \                     xputc:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     28          	if (_CR_CRLF && c == '\n') xputc('\r');		/* CR -> CRLF */
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C0A             CMP      R4,#+10
   \   00000008   0xD102             BNE.N    ??xputc_0
   \   0000000A   0x200D             MOVS     R0,#+13
   \   0000000C   0xF7FF 0xFFF8      BL       xputc
     29          
     30          	if (outptr) {
   \                     ??xputc_0:
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable6
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD00B             BEQ.N    ??xputc_1
     31          		*outptr++ = (unsigned char)c;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable6
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x7004             STRB     R4,[R0, #+0]
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable6
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x1C40             ADDS     R0,R0,#+1
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable6
   \   0000002E   0x6008             STR      R0,[R1, #+0]
     32          		return;
   \   00000030   0xE00A             B.N      ??xputc_2
     33          	}
     34          
     35          	if (xfunc_out) xfunc_out((unsigned char)c);
   \                     ??xputc_1:
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD005             BEQ.N    ??xputc_3
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   00000044   0x6809             LDR      R1,[R1, #+0]
   \   00000046   0x4788             BLX      R1
     36          }
   \                     ??xputc_3:
   \                     ??xputc_2:
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
     37          
     38          
     39          
     40          /*----------------------------------------------*/
     41          /* Put a null-terminated string                 */
     42          /*----------------------------------------------*/
     43          

   \                                 In section .text, align 2, keep-with-next
     44          void xputs (					/* Put a string to the default device */
     45          	const char* str				/* Pointer to the string */
     46          )
     47          {
   \                     xputs:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     48          	while (*str)
   \                     ??xputs_0:
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD004             BEQ.N    ??xputs_1
     49          		xputc(*str++);
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       xputc
   \   00000010   0x1C64             ADDS     R4,R4,#+1
   \   00000012   0xE7F7             B.N      ??xputs_0
     50          }
   \                     ??xputs_1:
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
     51          
     52          

   \                                 In section .text, align 2, keep-with-next
     53          void xfputs (					/* Put a string to the specified device */
     54          	void(*func)(unsigned char),	/* Pointer to the output function */
     55          	const char*	str				/* Pointer to the string */
     56          )
     57          {
   \                     xfputs:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     58          	void (*pf)(unsigned char);
     59          
     60          
     61          	pf = xfunc_out;		/* Save current output device */
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0006             MOVS     R6,R0
     62          	xfunc_out = func;	/* Switch output to specified device */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \   00000012   0x6004             STR      R4,[R0, #+0]
     63          	while (*str)		/* Put the string */
   \                     ??xfputs_0:
   \   00000014   0x7828             LDRB     R0,[R5, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD004             BEQ.N    ??xfputs_1
     64          		xputc(*str++);
   \   0000001A   0x7828             LDRB     R0,[R5, #+0]
   \   0000001C   0x.... 0x....      BL       xputc
   \   00000020   0x1C6D             ADDS     R5,R5,#+1
   \   00000022   0xE7F7             B.N      ??xfputs_0
     65          	xfunc_out = pf;		/* Restore output device */
   \                     ??xfputs_1:
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \   00000028   0x6006             STR      R6,[R0, #+0]
     66          }
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
     67          
     68          
     69          
     70          /*----------------------------------------------*/
     71          /* Formatted string output                      */
     72          /*----------------------------------------------*/
     73          /*  xprintf("%d", 1234);			"1234"
     74              xprintf("%6d,%3d%%", -200, 5);	"  -200,  5%"
     75              xprintf("%-6u", 100);			"100   "
     76              xprintf("%ld", 12345678L);		"12345678"
     77              xprintf("%04x", 0xA3);			"00a3"
     78              xprintf("%08LX", 0x123ABC);		"00123ABC"
     79              xprintf("%016b", 0x550F);		"0101010100001111"
     80              xprintf("%s", "String");		"String"
     81              xprintf("%-4s", "abc");			"abc "
     82              xprintf("%4s", "abc");			" abc"
     83              xprintf("%c", 'a');				"a"
     84              xprintf("%f", 10.0);            <xprintf lacks floating point support>
     85          */
     86          

   \                                 In section .text, align 2, keep-with-next
     87          static
     88          void xvprintf (
     89          	const char*	fmt,	/* Pointer to the format string */
     90          	va_list arp			/* Pointer to arguments */
     91          )
     92          {
   \                     xvprintf:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x0007             MOVS     R7,R0
   \   00000008   0x000C             MOVS     R4,R1
     93          	unsigned int r, i, j, w, f;
     94          	unsigned long v;
     95          	char s[16], c, d, *p;
     96          
     97          
     98          	for (;;) {
     99          		c = *fmt++;					/* Get a char */
   \                     ??xvprintf_0:
   \   0000000A   0x7838             LDRB     R0,[R7, #+0]
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000010   0x1C7F             ADDS     R7,R7,#+1
    100          		if (!c) break;				/* End of format? */
   \   00000012   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xF000 0x8114      BEQ.W    ??xvprintf_1
    101          		if (c != '%') {				/* Pass through it if not a % sequense */
   \                     ??xvprintf_2:
   \   0000001C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000020   0x2825             CMP      R0,#+37
   \   00000022   0xD004             BEQ.N    ??xvprintf_3
    102          			xputc(c); continue;
   \   00000024   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000028   0x.... 0x....      BL       xputc
   \   0000002C   0xE7ED             B.N      ??xvprintf_0
    103          		}
    104          		f = 0;
   \                     ??xvprintf_3:
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x0006             MOVS     R6,R0
    105          		c = *fmt++;					/* Get first char of the sequense */
   \   00000032   0x7838             LDRB     R0,[R7, #+0]
   \   00000034   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000038   0x1C7F             ADDS     R7,R7,#+1
    106          		if (c == '0') {				/* Flag: '0' padded */
   \   0000003A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003E   0x2830             CMP      R0,#+48
   \   00000040   0xD106             BNE.N    ??xvprintf_4
    107          			f = 1; c = *fmt++;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x0006             MOVS     R6,R0
   \   00000046   0x7838             LDRB     R0,[R7, #+0]
   \   00000048   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000004C   0x1C7F             ADDS     R7,R7,#+1
   \   0000004E   0xE009             B.N      ??xvprintf_5
    108          		} else {
    109          			if (c == '-') {			/* Flag: left justified */
   \                     ??xvprintf_4:
   \   00000050   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000054   0x282D             CMP      R0,#+45
   \   00000056   0xD105             BNE.N    ??xvprintf_5
    110          				f = 2; c = *fmt++;
   \   00000058   0x2002             MOVS     R0,#+2
   \   0000005A   0x0006             MOVS     R6,R0
   \   0000005C   0x7838             LDRB     R0,[R7, #+0]
   \   0000005E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000062   0x1C7F             ADDS     R7,R7,#+1
    111          			}
    112          		}
    113          		for (w = 0; c >= '0' && c <= '9'; c = *fmt++)	/* Minimum width */
   \                     ??xvprintf_5:
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x4680             MOV      R8,R0
   \                     ??xvprintf_6:
   \   00000068   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000006C   0x2830             CMP      R0,#+48
   \   0000006E   0xD30F             BCC.N    ??xvprintf_7
   \   00000070   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000074   0x283A             CMP      R0,#+58
   \   00000076   0xD20B             BCS.N    ??xvprintf_7
    114          			w = w * 10 + c - '0';
   \   00000078   0x200A             MOVS     R0,#+10
   \   0000007A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000007E   0xFB00 0x1008      MLA      R0,R0,R8,R1
   \   00000082   0xF1B0 0x0830      SUBS     R8,R0,#+48
   \   00000086   0x7838             LDRB     R0,[R7, #+0]
   \   00000088   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000008C   0x1C7F             ADDS     R7,R7,#+1
   \   0000008E   0xE7EB             B.N      ??xvprintf_6
    115          		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
   \                     ??xvprintf_7:
   \   00000090   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000094   0x286C             CMP      R0,#+108
   \   00000096   0xD003             BEQ.N    ??xvprintf_8
   \   00000098   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000009C   0x284C             CMP      R0,#+76
   \   0000009E   0xD105             BNE.N    ??xvprintf_9
    116          			f |= 4; c = *fmt++;
   \                     ??xvprintf_8:
   \   000000A0   0xF056 0x0604      ORRS     R6,R6,#0x4
   \   000000A4   0x7838             LDRB     R0,[R7, #+0]
   \   000000A6   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   000000AA   0x1C7F             ADDS     R7,R7,#+1
    117          		}
    118          		if (!c) break;				/* End of format? */
   \                     ??xvprintf_9:
   \   000000AC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xF000 0x80C7      BEQ.W    ??xvprintf_1
    119          		d = c;
   \                     ??xvprintf_10:
   \   000000B6   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000BA   0x4682             MOV      R10,R0
    120          		if (d >= 'a') d -= 0x20;
   \   000000BC   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000C0   0xF1BA 0x0F61      CMP      R10,#+97
   \   000000C4   0xD301             BCC.N    ??xvprintf_11
   \   000000C6   0xF1BA 0x0A20      SUBS     R10,R10,#+32
    121          		switch (d) {				/* Type is... */
   \                     ??xvprintf_11:
   \   000000CA   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000CE   0x4650             MOV      R0,R10
   \   000000D0   0x2842             CMP      R0,#+66
   \   000000D2   0xD034             BEQ.N    ??xvprintf_12
   \   000000D4   0x2843             CMP      R0,#+67
   \   000000D6   0xD02B             BEQ.N    ??xvprintf_13
   \   000000D8   0x2844             CMP      R0,#+68
   \   000000DA   0xD036             BEQ.N    ??xvprintf_14
   \   000000DC   0x284F             CMP      R0,#+79
   \   000000DE   0xD031             BEQ.N    ??xvprintf_15
   \   000000E0   0x2853             CMP      R0,#+83
   \   000000E2   0xD004             BEQ.N    ??xvprintf_16
   \   000000E4   0x2855             CMP      R0,#+85
   \   000000E6   0xD030             BEQ.N    ??xvprintf_14
   \   000000E8   0x2858             CMP      R0,#+88
   \   000000EA   0xD031             BEQ.N    ??xvprintf_17
   \   000000EC   0xE033             B.N      ??xvprintf_18
    122          		case 'S' :					/* String */
    123          			p = va_arg(arp, char*);
   \                     ??xvprintf_16:
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0x9002             STR      R0,[SP, #+8]
   \   000000F2   0x1D24             ADDS     R4,R4,#+4
    124          			for (j = 0; p[j]; j++) ;
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0x0005             MOVS     R5,R0
   \                     ??xvprintf_19:
   \   000000F8   0x9802             LDR      R0,[SP, #+8]
   \   000000FA   0x5C28             LDRB     R0,[R5, R0]
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xD001             BEQ.N    ??xvprintf_20
   \   00000100   0x1C6D             ADDS     R5,R5,#+1
   \   00000102   0xE7F9             B.N      ??xvprintf_19
    125          			while (!(f & 2) && j++ < w) xputc(' ');
   \                     ??xvprintf_20:
   \   00000104   0x07B0             LSLS     R0,R6,#+30
   \   00000106   0xD407             BMI.N    ??xvprintf_21
   \   00000108   0x0028             MOVS     R0,R5
   \   0000010A   0x1C45             ADDS     R5,R0,#+1
   \   0000010C   0x4540             CMP      R0,R8
   \   0000010E   0xD203             BCS.N    ??xvprintf_21
   \   00000110   0x2020             MOVS     R0,#+32
   \   00000112   0x.... 0x....      BL       xputc
   \   00000116   0xE7F5             B.N      ??xvprintf_20
    126          			xputs(p);
   \                     ??xvprintf_21:
   \   00000118   0x9802             LDR      R0,[SP, #+8]
   \   0000011A   0x.... 0x....      BL       xputs
    127          			while (j++ < w) xputc(' ');
   \                     ??xvprintf_22:
   \   0000011E   0x0028             MOVS     R0,R5
   \   00000120   0x1C45             ADDS     R5,R0,#+1
   \   00000122   0x4540             CMP      R0,R8
   \   00000124   0xD203             BCS.N    ??xvprintf_23
   \   00000126   0x2020             MOVS     R0,#+32
   \   00000128   0x.... 0x....      BL       xputc
   \   0000012C   0xE7F7             B.N      ??xvprintf_22
    128          			continue;
   \                     ??xvprintf_23:
   \   0000012E   0xE76C             B.N      ??xvprintf_0
    129          		case 'C' :					/* Character */
    130          			xputc((char)va_arg(arp, int)); continue;
   \                     ??xvprintf_13:
   \   00000130   0x0020             MOVS     R0,R4
   \   00000132   0x1D04             ADDS     R4,R0,#+4
   \   00000134   0x6800             LDR      R0,[R0, #+0]
   \   00000136   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000138   0x.... 0x....      BL       xputc
   \   0000013C   0xE765             B.N      ??xvprintf_0
    131          		case 'B' :					/* Binary */
    132          			r = 2; break;
   \                     ??xvprintf_12:
   \   0000013E   0x2002             MOVS     R0,#+2
   \   00000140   0x9001             STR      R0,[SP, #+4]
   \   00000142   0xE00D             B.N      ??xvprintf_24
    133          		case 'O' :					/* Octal */
    134          			r = 8; break;
   \                     ??xvprintf_15:
   \   00000144   0x2008             MOVS     R0,#+8
   \   00000146   0x9001             STR      R0,[SP, #+4]
   \   00000148   0xE00A             B.N      ??xvprintf_24
    135          		case 'D' :					/* Signed decimal */
    136          		case 'U' :					/* Unsigned decimal */
    137          			r = 10; break;
   \                     ??xvprintf_14:
   \   0000014A   0x200A             MOVS     R0,#+10
   \   0000014C   0x9001             STR      R0,[SP, #+4]
   \   0000014E   0xE007             B.N      ??xvprintf_24
    138          		case 'X' :					/* Hexdecimal */
    139          			r = 16; break;
   \                     ??xvprintf_17:
   \   00000150   0x2010             MOVS     R0,#+16
   \   00000152   0x9001             STR      R0,[SP, #+4]
   \   00000154   0xE004             B.N      ??xvprintf_24
    140          		default:					/* Unknown type (passthrough) */
    141          			xputc(c); continue;
   \                     ??xvprintf_18:
   \   00000156   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000015A   0x.... 0x....      BL       xputc
   \   0000015E   0xE754             B.N      ??xvprintf_0
    142          		}
    143          
    144          		/* Get an argument and put it in numeral */
    145          		v = (f & 4) ? va_arg(arp, long) : ((d == 'D') ? (long)va_arg(arp, int) : (long)va_arg(arp, unsigned int));
   \                     ??xvprintf_24:
   \   00000160   0x0770             LSLS     R0,R6,#+29
   \   00000162   0xD503             BPL.N    ??xvprintf_25
   \   00000164   0xF8D4 0x9000      LDR      R9,[R4, #+0]
   \   00000168   0x1D24             ADDS     R4,R4,#+4
   \   0000016A   0xE00B             B.N      ??xvprintf_26
   \                     ??xvprintf_25:
   \   0000016C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000170   0xF1BA 0x0F44      CMP      R10,#+68
   \   00000174   0xD103             BNE.N    ??xvprintf_27
   \   00000176   0xF8D4 0x9000      LDR      R9,[R4, #+0]
   \   0000017A   0x1D24             ADDS     R4,R4,#+4
   \   0000017C   0xE002             B.N      ??xvprintf_28
   \                     ??xvprintf_27:
   \   0000017E   0xF8D4 0x9000      LDR      R9,[R4, #+0]
   \   00000182   0x1D24             ADDS     R4,R4,#+4
    146          		if (d == 'D' && (v & 0x80000000)) {
   \                     ??xvprintf_28:
   \                     ??xvprintf_26:
   \   00000184   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000188   0xF1BA 0x0F44      CMP      R10,#+68
   \   0000018C   0xD106             BNE.N    ??xvprintf_29
   \   0000018E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000192   0xD503             BPL.N    ??xvprintf_29
    147          			v = 0 - v;
   \   00000194   0xF1D9 0x0900      RSBS     R9,R9,#+0
    148          			f |= 8;
   \   00000198   0xF056 0x0608      ORRS     R6,R6,#0x8
    149          		}
    150          		i = 0;
   \                     ??xvprintf_29:
   \   0000019C   0x2000             MOVS     R0,#+0
   \   0000019E   0x4683             MOV      R11,R0
    151          		do {
    152          			d = (char)(v % r); v /= r;
   \                     ??xvprintf_30:
   \   000001A0   0x9801             LDR      R0,[SP, #+4]
   \   000001A2   0xFBB9 0xF1F0      UDIV     R1,R9,R0
   \   000001A6   0xFB00 0x9011      MLS      R0,R0,R1,R9
   \   000001AA   0x4682             MOV      R10,R0
   \   000001AC   0x9801             LDR      R0,[SP, #+4]
   \   000001AE   0xFBB9 0xF9F0      UDIV     R9,R9,R0
    153          			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
   \   000001B2   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001B6   0xF1BA 0x0F0A      CMP      R10,#+10
   \   000001BA   0xD308             BCC.N    ??xvprintf_31
   \   000001BC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000001C0   0x2878             CMP      R0,#+120
   \   000001C2   0xD101             BNE.N    ??xvprintf_32
   \   000001C4   0x2027             MOVS     R0,#+39
   \   000001C6   0xE000             B.N      ??xvprintf_33
   \                     ??xvprintf_32:
   \   000001C8   0x2007             MOVS     R0,#+7
   \                     ??xvprintf_33:
   \   000001CA   0xEB10 0x0A0A      ADDS     R10,R0,R10
    154          			s[i++] = d + '0';
   \                     ??xvprintf_31:
   \   000001CE   0xA803             ADD      R0,SP,#+12
   \   000001D0   0xF11A 0x0130      ADDS     R1,R10,#+48
   \   000001D4   0xF80B 0x1000      STRB     R1,[R11, R0]
   \   000001D8   0xF11B 0x0B01      ADDS     R11,R11,#+1
    155          		} while (v && i < sizeof(s));
   \   000001DC   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001E0   0xD002             BEQ.N    ??xvprintf_34
   \   000001E2   0xF1BB 0x0F10      CMP      R11,#+16
   \   000001E6   0xD3DB             BCC.N    ??xvprintf_30
    156          		if (f & 8) s[i++] = '-';
   \                     ??xvprintf_34:
   \   000001E8   0x0730             LSLS     R0,R6,#+28
   \   000001EA   0xD505             BPL.N    ??xvprintf_35
   \   000001EC   0xA803             ADD      R0,SP,#+12
   \   000001EE   0x212D             MOVS     R1,#+45
   \   000001F0   0xF80B 0x1000      STRB     R1,[R11, R0]
   \   000001F4   0xF11B 0x0B01      ADDS     R11,R11,#+1
    157          		j = i; d = (f & 1) ? '0' : ' ';
   \                     ??xvprintf_35:
   \   000001F8   0x465D             MOV      R5,R11
   \   000001FA   0x07F0             LSLS     R0,R6,#+31
   \   000001FC   0xD502             BPL.N    ??xvprintf_36
   \   000001FE   0xF05F 0x0A30      MOVS     R10,#+48
   \   00000202   0xE001             B.N      ??xvprintf_37
   \                     ??xvprintf_36:
   \   00000204   0xF05F 0x0A20      MOVS     R10,#+32
    158          		while (!(f & 2) && j++ < w) xputc(d);
   \                     ??xvprintf_37:
   \                     ??xvprintf_38:
   \   00000208   0x07B0             LSLS     R0,R6,#+30
   \   0000020A   0xD408             BMI.N    ??xvprintf_39
   \   0000020C   0x0028             MOVS     R0,R5
   \   0000020E   0x1C45             ADDS     R5,R0,#+1
   \   00000210   0x4540             CMP      R0,R8
   \   00000212   0xD204             BCS.N    ??xvprintf_39
   \   00000214   0x4650             MOV      R0,R10
   \   00000216   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000218   0x.... 0x....      BL       xputc
   \   0000021C   0xE7F4             B.N      ??xvprintf_38
    159          		do xputc(s[--i]); while(i);
   \                     ??xvprintf_39:
   \   0000021E   0xF1BB 0x0B01      SUBS     R11,R11,#+1
   \   00000222   0xA803             ADD      R0,SP,#+12
   \   00000224   0xF81B 0x0000      LDRB     R0,[R11, R0]
   \   00000228   0x.... 0x....      BL       xputc
   \   0000022C   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000230   0xD1F5             BNE.N    ??xvprintf_39
    160          		while (j++ < w) xputc(' ');
   \                     ??xvprintf_40:
   \   00000232   0x0028             MOVS     R0,R5
   \   00000234   0x1C45             ADDS     R5,R0,#+1
   \   00000236   0x4540             CMP      R0,R8
   \   00000238   0xF4BF 0xAEE7      BCS.W    ??xvprintf_0
   \   0000023C   0x2020             MOVS     R0,#+32
   \   0000023E   0x.... 0x....      BL       xputc
   \   00000242   0xE7F6             B.N      ??xvprintf_40
    161          	}
    162          }
   \                     ??xvprintf_1:
   \   00000244   0xB007             ADD      SP,SP,#+28
   \   00000246   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    163          
    164          

   \                                 In section .text, align 2, keep-with-next
    165          void xprintf (			/* Put a formatted string to the default device */
    166          	const char*	fmt,	/* Pointer to the format string */
    167          	...					/* Optional arguments */
    168          )
    169          {
   \                     xprintf:
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB530             PUSH     {R4,R5,LR}
   \   00000004   0x0004             MOVS     R4,R0
    170          	va_list arp;
    171          
    172          
    173          	va_start(arp, fmt);
   \   00000006   0xA803             ADD      R0,SP,#+12
   \   00000008   0x0005             MOVS     R5,R0
    174          	xvprintf(fmt, arp);
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       xvprintf
    175          	va_end(arp);
    176          }
   \   00000012   0xBC30             POP      {R4,R5}
   \   00000014   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
    177          
    178          

   \                                 In section .text, align 2, keep-with-next
    179          void xsprintf (			/* Put a formatted string to the memory */
    180          	char* buff,			/* Pointer to the output buffer */
    181          	const char*	fmt,	/* Pointer to the format string */
    182          	...					/* Optional arguments */
    183          )
    184          {
   \                     xsprintf:
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB570             PUSH     {R4-R6,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    185          	va_list arp;
    186          
    187          
    188          	outptr = buff;		/* Switch destination for memory */
   \   00000008   0x....             LDR.N    R0,??DataTable6
   \   0000000A   0x6004             STR      R4,[R0, #+0]
    189          
    190          	va_start(arp, fmt);
   \   0000000C   0xA804             ADD      R0,SP,#+16
   \   0000000E   0x0006             MOVS     R6,R0
    191          	xvprintf(fmt, arp);
   \   00000010   0x0031             MOVS     R1,R6
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0x.... 0x....      BL       xvprintf
    192          	va_end(arp);
    193          
    194          	*outptr = 0;		/* Terminate output string with a \0 */
   \   00000018   0x....             LDR.N    R0,??DataTable6
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x7001             STRB     R1,[R0, #+0]
    195          	outptr = 0;			/* Switch destination for device */
   \   00000020   0x....             LDR.N    R0,??DataTable6
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x6001             STR      R1,[R0, #+0]
    196          }
   \   00000026   0xBC70             POP      {R4-R6}
   \   00000028   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
    197          
    198          

   \                                 In section .text, align 2, keep-with-next
    199          void xfprintf (					/* Put a formatted string to the specified device */
    200          	void(*func)(unsigned char),	/* Pointer to the output function */
    201          	const char*	fmt,			/* Pointer to the format string */
    202          	...							/* Optional arguments */
    203          )
    204          {
   \                     xfprintf:
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB5F8             PUSH     {R3-R7,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    205          	va_list arp;
    206          	void (*pf)(unsigned char);
    207          
    208          
    209          	pf = xfunc_out;		/* Save current output device */
   \   00000008   0x....             LDR.N    R0,??DataTable6_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0007             MOVS     R7,R0
    210          	xfunc_out = func;	/* Switch output to specified device */
   \   0000000E   0x....             LDR.N    R0,??DataTable6_1
   \   00000010   0x6004             STR      R4,[R0, #+0]
    211          
    212          	va_start(arp, fmt);
   \   00000012   0xA806             ADD      R0,SP,#+24
   \   00000014   0x0006             MOVS     R6,R0
    213          	xvprintf(fmt, arp);
   \   00000016   0x0031             MOVS     R1,R6
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       xvprintf
    214          	va_end(arp);
    215          
    216          	xfunc_out = pf;		/* Restore output device */
   \   0000001E   0x....             LDR.N    R0,??DataTable6_1
   \   00000020   0x6007             STR      R7,[R0, #+0]
    217          }
   \   00000022   0xBCF1             POP      {R0,R4-R7}
   \   00000024   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
    218          
    219          
    220          
    221          /*----------------------------------------------*/
    222          /* Dump a line of binary dump                   */
    223          /*----------------------------------------------*/
    224          

   \                                 In section .text, align 2, keep-with-next
    225          void put_dump (
    226          	const void* buff,		/* Pointer to the array to be dumped */
    227          	unsigned long addr,		/* Heading address value */
    228          	int len,				/* Number of items to be dumped */
    229          	int width				/* Size of the items (DF_CHAR, DF_SHORT, DF_LONG) */
    230          )
    231          {
   \                     put_dump:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x469B             MOV      R11,R3
    232          	int i;
    233          	const unsigned char *bp;
    234          	const unsigned short *sp;
    235          	const unsigned long *lp;
    236          
    237          
    238          	xprintf("%08lX ", addr);		/* address */
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0x....             LDR.N    R0,??DataTable6_2
   \   00000010   0x.... 0x....      BL       xprintf
    239          
    240          	switch (width) {
   \   00000014   0x4658             MOV      R0,R11
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD004             BEQ.N    ??put_dump_0
   \   0000001A   0x2802             CMP      R0,#+2
   \   0000001C   0xD027             BEQ.N    ??put_dump_1
   \   0000001E   0x2804             CMP      R0,#+4
   \   00000020   0xD031             BEQ.N    ??put_dump_2
   \   00000022   0xE03B             B.N      ??put_dump_3
    241          	case DW_CHAR:
    242          		bp = buff;
   \                     ??put_dump_0:
   \   00000024   0x46A0             MOV      R8,R4
    243          		for (i = 0; i < len; i++)		/* Hexdecimal dump */
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x0007             MOVS     R7,R0
   \                     ??put_dump_4:
   \   0000002A   0x42B7             CMP      R7,R6
   \   0000002C   0xDA06             BGE.N    ??put_dump_5
    244          			xprintf(" %02X", bp[i]);
   \   0000002E   0xF817 0x1008      LDRB     R1,[R7, R8]
   \   00000032   0x....             LDR.N    R0,??DataTable6_3
   \   00000034   0x.... 0x....      BL       xprintf
   \   00000038   0x1C7F             ADDS     R7,R7,#+1
   \   0000003A   0xE7F6             B.N      ??put_dump_4
    245          		xputc(' ');
   \                     ??put_dump_5:
   \   0000003C   0x2020             MOVS     R0,#+32
   \   0000003E   0x.... 0x....      BL       xputc
    246          		for (i = 0; i < len; i++)		/* ASCII dump */
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x0007             MOVS     R7,R0
   \                     ??put_dump_6:
   \   00000046   0x42B7             CMP      R7,R6
   \   00000048   0xDA10             BGE.N    ??put_dump_7
    247          			xputc((bp[i] >= ' ' && bp[i] <= '~') ? bp[i] : '.');
   \   0000004A   0xF817 0x0008      LDRB     R0,[R7, R8]
   \   0000004E   0x2820             CMP      R0,#+32
   \   00000050   0xD306             BCC.N    ??put_dump_8
   \   00000052   0xF817 0x0008      LDRB     R0,[R7, R8]
   \   00000056   0x287F             CMP      R0,#+127
   \   00000058   0xD202             BCS.N    ??put_dump_8
   \   0000005A   0xF817 0x0008      LDRB     R0,[R7, R8]
   \   0000005E   0xE000             B.N      ??put_dump_9
   \                     ??put_dump_8:
   \   00000060   0x202E             MOVS     R0,#+46
   \                     ??put_dump_9:
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0x.... 0x....      BL       xputc
   \   00000068   0x1C7F             ADDS     R7,R7,#+1
   \   0000006A   0xE7EC             B.N      ??put_dump_6
    248          		break;
   \                     ??put_dump_7:
   \   0000006C   0xE016             B.N      ??put_dump_3
    249          	case DW_SHORT:
    250          		sp = buff;
   \                     ??put_dump_1:
   \   0000006E   0x46A1             MOV      R9,R4
    251          		do								/* Hexdecimal dump */
    252          			xprintf(" %04X", *sp++);
   \                     ??put_dump_10:
   \   00000070   0xF8B9 0x1000      LDRH     R1,[R9, #+0]
   \   00000074   0x....             LDR.N    R0,??DataTable6_4
   \   00000076   0x.... 0x....      BL       xprintf
   \   0000007A   0xF119 0x0902      ADDS     R9,R9,#+2
    253          		while (--len);
   \   0000007E   0x1E76             SUBS     R6,R6,#+1
   \   00000080   0x2E00             CMP      R6,#+0
   \   00000082   0xD1F5             BNE.N    ??put_dump_10
    254          		break;
   \   00000084   0xE00A             B.N      ??put_dump_3
    255          	case DW_LONG:
    256          		lp = buff;
   \                     ??put_dump_2:
   \   00000086   0x46A2             MOV      R10,R4
    257          		do								/* Hexdecimal dump */
    258          			xprintf(" %08LX", *lp++);
   \                     ??put_dump_11:
   \   00000088   0xF8DA 0x1000      LDR      R1,[R10, #+0]
   \   0000008C   0x....             LDR.N    R0,??DataTable6_5
   \   0000008E   0x.... 0x....      BL       xprintf
   \   00000092   0xF11A 0x0A04      ADDS     R10,R10,#+4
    259          		while (--len);
   \   00000096   0x1E76             SUBS     R6,R6,#+1
   \   00000098   0x2E00             CMP      R6,#+0
   \   0000009A   0xD1F5             BNE.N    ??put_dump_11
    260          		break;
    261          	}
    262          
    263          	xputc('\n');
   \                     ??put_dump_3:
   \   0000009C   0x200A             MOVS     R0,#+10
   \   0000009E   0x.... 0x....      BL       xputc
    264          }
   \   000000A2   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    265          
    266          #endif /* _USE_XFUNC_OUT */
    267          
    268          
    269          
    270          #if _USE_XFUNC_IN

   \                                 In section .bss, align 4
    271          unsigned char (*xfunc_in)(void);	/* Pointer to the input stream */
   \                     xfunc_in:
   \   00000000                      DS8 4
    272          
    273          /*----------------------------------------------*/
    274          /* Get a line from the input                    */
    275          /*----------------------------------------------*/
    276          

   \                                 In section .text, align 2, keep-with-next
    277          int xgets (		/* 0:End of stream, 1:A line arrived */
    278          	char* buff,	/* Pointer to the buffer */
    279          	int len		/* Buffer length */
    280          )
    281          {
   \                     xgets:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    282          	int c, i;
    283          
    284          
    285          	if (!xfunc_in) return 0;		/* No input function specified */
   \   00000006   0x....             LDR.N    R0,??DataTable6_6
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??xgets_0
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE028             B.N      ??xgets_1
    286          
    287          	i = 0;
   \                     ??xgets_0:
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x0007             MOVS     R7,R0
    288          	for (;;) {
    289          		c = xfunc_in();				/* Get a char from the incoming stream */
   \                     ??xgets_2:
   \   00000016   0x....             LDR.N    R0,??DataTable6_6
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x4780             BLX      R0
   \   0000001C   0x0006             MOVS     R6,R0
    290          		if (!c) return 0;			/* End of stream? */
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD101             BNE.N    ??xgets_3
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE01E             B.N      ??xgets_1
    291          		if (c == '\r') break;		/* End of line? */
   \                     ??xgets_3:
   \   00000026   0x2E0D             CMP      R6,#+13
   \   00000028   0xD106             BNE.N    ??xgets_4
    292          		if (c == '\b' && i) {		/* Back space? */
    293          			i--;
    294          			if (_LINE_ECHO) xputc(c);
    295          			continue;
    296          		}
    297          		if (c >= ' ' && i < len - 1) {	/* Visible chars */
    298          			buff[i++] = c;
    299          			if (_LINE_ECHO) xputc(c);
    300          		}
    301          	}
    302          	buff[i] = 0;	/* Terminate with a \0 */
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x5538             STRB     R0,[R7, R4]
    303          	if (_LINE_ECHO) xputc('\n');
   \   0000002E   0x200A             MOVS     R0,#+10
   \   00000030   0x.... 0x....      BL       xputc
    304          	return 1;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xE015             B.N      ??xgets_1
   \                     ??xgets_4:
   \   00000038   0x2E08             CMP      R6,#+8
   \   0000003A   0xD107             BNE.N    ??xgets_5
   \   0000003C   0x2F00             CMP      R7,#+0
   \   0000003E   0xD005             BEQ.N    ??xgets_5
   \   00000040   0x1E7F             SUBS     R7,R7,#+1
   \   00000042   0x0030             MOVS     R0,R6
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x.... 0x....      BL       xputc
   \   0000004A   0xE7E4             B.N      ??xgets_2
   \                     ??xgets_5:
   \   0000004C   0x2E20             CMP      R6,#+32
   \   0000004E   0xDBE2             BLT.N    ??xgets_2
   \   00000050   0x1E68             SUBS     R0,R5,#+1
   \   00000052   0x4287             CMP      R7,R0
   \   00000054   0xDADF             BGE.N    ??xgets_2
   \   00000056   0x553E             STRB     R6,[R7, R4]
   \   00000058   0x1C7F             ADDS     R7,R7,#+1
   \   0000005A   0x0030             MOVS     R0,R6
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0x.... 0x....      BL       xputc
   \   00000062   0xE7D8             B.N      ??xgets_2
   \                     ??xgets_1:
   \   00000064   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    305          }
    306          
    307          

   \                                 In section .text, align 2, keep-with-next
    308          int xfgets (	/* 0:End of stream, 1:A line arrived */
    309          	unsigned char (*func)(void),	/* Pointer to the input stream function */
    310          	char* buff,	/* Pointer to the buffer */
    311          	int len		/* Buffer length */
    312          )
    313          {
   \                     xfgets:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    314          	unsigned char (*pf)(void);
    315          	int n;
    316          
    317          
    318          	pf = xfunc_in;			/* Save current input device */
   \   0000000A   0x....             LDR.N    R0,??DataTable6_6
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0007             MOVS     R7,R0
    319          	xfunc_in = func;		/* Switch input to specified device */
   \   00000010   0x....             LDR.N    R0,??DataTable6_6
   \   00000012   0x6004             STR      R4,[R0, #+0]
    320          	n = xgets(buff, len);	/* Get a line */
   \   00000014   0x0031             MOVS     R1,R6
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0x.... 0x....      BL       xgets
   \   0000001C   0x4680             MOV      R8,R0
    321          	xfunc_in = pf;			/* Restore input device */
   \   0000001E   0x....             LDR.N    R0,??DataTable6_6
   \   00000020   0x6007             STR      R7,[R0, #+0]
    322          
    323          	return n;
   \   00000022   0x4640             MOV      R0,R8
   \   00000024   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    324          }
    325          
    326          
    327          /*----------------------------------------------*/
    328          /* Get a value of the string                    */
    329          /*----------------------------------------------*/
    330          /*	"123 -5   0x3ff 0b1111 0377  w "
    331          	    ^                           1st call returns 123 and next ptr
    332          	       ^                        2nd call returns -5 and next ptr
    333                             ^                3rd call returns 1023 and next ptr
    334                                    ^         4th call returns 15 and next ptr
    335                                         ^    5th call returns 255 and next ptr
    336                                            ^ 6th call fails and returns 0
    337          */
    338          

   \                                 In section .text, align 2, keep-with-next
    339          int xatoi (			/* 0:Failed, 1:Successful */
    340          	char **str,		/* Pointer to pointer to the string */
    341          	long *res		/* Pointer to the valiable to store the value */
    342          )
    343          {
   \                     xatoi:
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0002             MOVS     R2,R0
    344          	unsigned long val;
    345          	unsigned char c, r, s = 0;
   \   00000004   0x2600             MOVS     R6,#+0
    346          
    347          
    348          	*res = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x6008             STR      R0,[R1, #+0]
    349          
    350          	while ((c = **str) == ' ') (*str)++;	/* Skip leading spaces */
   \                     ??xatoi_0:
   \   0000000A   0x6810             LDR      R0,[R2, #+0]
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x0004             MOVS     R4,R0
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x2820             CMP      R0,#+32
   \   00000014   0xD103             BNE.N    ??xatoi_1
   \   00000016   0x6810             LDR      R0,[R2, #+0]
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \   0000001A   0x6010             STR      R0,[R2, #+0]
   \   0000001C   0xE7F5             B.N      ??xatoi_0
    351          
    352          	if (c == '-') {		/* negative? */
   \                     ??xatoi_1:
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2C2D             CMP      R4,#+45
   \   00000022   0xD106             BNE.N    ??xatoi_2
    353          		s = 1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x0006             MOVS     R6,R0
    354          		c = *(++(*str));
   \   00000028   0x6810             LDR      R0,[R2, #+0]
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \   0000002C   0x6010             STR      R0,[R2, #+0]
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x0004             MOVS     R4,R0
    355          	}
    356          
    357          	if (c == '0') {
   \                     ??xatoi_2:
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0x2C30             CMP      R4,#+48
   \   00000036   0xD12A             BNE.N    ??xatoi_3
    358          		c = *(++(*str));
   \   00000038   0x6810             LDR      R0,[R2, #+0]
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \   0000003C   0x6010             STR      R0,[R2, #+0]
   \   0000003E   0x7800             LDRB     R0,[R0, #+0]
   \   00000040   0x0004             MOVS     R4,R0
    359          		switch (c) {
   \   00000042   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x2862             CMP      R0,#+98
   \   00000048   0xD009             BEQ.N    ??xatoi_4
   \   0000004A   0x2878             CMP      R0,#+120
   \   0000004C   0xD10F             BNE.N    ??xatoi_5
    360          		case 'x':		/* hexdecimal */
    361          			r = 16; c = *(++(*str));
   \                     ??xatoi_6:
   \   0000004E   0x2010             MOVS     R0,#+16
   \   00000050   0x0005             MOVS     R5,R0
   \   00000052   0x6810             LDR      R0,[R2, #+0]
   \   00000054   0x1C40             ADDS     R0,R0,#+1
   \   00000056   0x6010             STR      R0,[R2, #+0]
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x0004             MOVS     R4,R0
    362          			break;
   \   0000005C   0xE021             B.N      ??xatoi_7
    363          		case 'b':		/* binary */
    364          			r = 2; c = *(++(*str));
   \                     ??xatoi_4:
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0x0005             MOVS     R5,R0
   \   00000062   0x6810             LDR      R0,[R2, #+0]
   \   00000064   0x1C40             ADDS     R0,R0,#+1
   \   00000066   0x6010             STR      R0,[R2, #+0]
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0x0004             MOVS     R4,R0
    365          			break;
   \   0000006C   0xE019             B.N      ??xatoi_7
    366          		default:
    367          			if (c <= ' ') return 1;	/* single zero */
   \                     ??xatoi_5:
   \   0000006E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000070   0x2C21             CMP      R4,#+33
   \   00000072   0xD201             BCS.N    ??xatoi_8
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xE03D             B.N      ??xatoi_9
    368          			if (c < '0' || c > '9') return 0;	/* invalid char */
   \                     ??xatoi_8:
   \   00000078   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007A   0x2C30             CMP      R4,#+48
   \   0000007C   0xD302             BCC.N    ??xatoi_10
   \   0000007E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000080   0x2C3A             CMP      R4,#+58
   \   00000082   0xD301             BCC.N    ??xatoi_11
   \                     ??xatoi_10:
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xE035             B.N      ??xatoi_9
    369          			r = 8;		/* octal */
   \                     ??xatoi_11:
   \   00000088   0x2008             MOVS     R0,#+8
   \   0000008A   0x0005             MOVS     R5,R0
   \   0000008C   0xE009             B.N      ??xatoi_7
    370          		}
    371          	} else {
    372          		if (c < '0' || c > '9') return 0;	/* EOL or invalid char */
   \                     ??xatoi_3:
   \   0000008E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000090   0x2C30             CMP      R4,#+48
   \   00000092   0xD302             BCC.N    ??xatoi_12
   \   00000094   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000096   0x2C3A             CMP      R4,#+58
   \   00000098   0xD301             BCC.N    ??xatoi_13
   \                     ??xatoi_12:
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xE02A             B.N      ??xatoi_9
    373          		r = 10;			/* decimal */
   \                     ??xatoi_13:
   \   0000009E   0x200A             MOVS     R0,#+10
   \   000000A0   0x0005             MOVS     R5,R0
    374          	}
    375          
    376          	val = 0;
   \                     ??xatoi_7:
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x0003             MOVS     R3,R0
    377          	while (c > ' ') {
   \                     ??xatoi_14:
   \   000000A6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A8   0x2C21             CMP      R4,#+33
   \   000000AA   0xD31D             BCC.N    ??xatoi_15
    378          		if (c >= 'a') c -= 0x20;
   \   000000AC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000AE   0x2C61             CMP      R4,#+97
   \   000000B0   0xD300             BCC.N    ??xatoi_16
   \   000000B2   0x3C20             SUBS     R4,R4,#+32
    379          		c -= '0';
   \                     ??xatoi_16:
   \   000000B4   0x3C30             SUBS     R4,R4,#+48
    380          		if (c >= 17) {
   \   000000B6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B8   0x2C11             CMP      R4,#+17
   \   000000BA   0xD305             BCC.N    ??xatoi_17
    381          			c -= 7;
   \   000000BC   0x1FE4             SUBS     R4,R4,#+7
    382          			if (c <= 9) return 0;	/* invalid char */
   \   000000BE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C0   0x2C0A             CMP      R4,#+10
   \   000000C2   0xD201             BCS.N    ??xatoi_17
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0xE015             B.N      ??xatoi_9
    383          		}
    384          		if (c >= r) return 0;		/* invalid char for current radix */
   \                     ??xatoi_17:
   \   000000C8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000CC   0x42AC             CMP      R4,R5
   \   000000CE   0xD301             BCC.N    ??xatoi_18
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0xE00F             B.N      ??xatoi_9
    385          		val = val * r + c;
   \                     ??xatoi_18:
   \   000000D4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000D8   0xFB05 0x4303      MLA      R3,R5,R3,R4
    386          		c = *(++(*str));
   \   000000DC   0x6810             LDR      R0,[R2, #+0]
   \   000000DE   0x1C40             ADDS     R0,R0,#+1
   \   000000E0   0x6010             STR      R0,[R2, #+0]
   \   000000E2   0x7800             LDRB     R0,[R0, #+0]
   \   000000E4   0x0004             MOVS     R4,R0
   \   000000E6   0xE7DE             B.N      ??xatoi_14
    387          	}
    388          	if (s) val = 0 - val;			/* apply sign if needed */
   \                     ??xatoi_15:
   \   000000E8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000EA   0x2E00             CMP      R6,#+0
   \   000000EC   0xD000             BEQ.N    ??xatoi_19
   \   000000EE   0x425B             RSBS     R3,R3,#+0
    389          
    390          	*res = val;
   \                     ??xatoi_19:
   \   000000F0   0x600B             STR      R3,[R1, #+0]
    391          	return 1;
   \   000000F2   0x2001             MOVS     R0,#+1
   \                     ??xatoi_9:
   \   000000F4   0xBC70             POP      {R4-R6}
   \   000000F6   0x4770             BX       LR               ;; return
    392          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     outptr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     xfunc_out

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     `?<Constant "%08lX ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     `?<Constant " %02X">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     `?<Constant " %04X">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     `?<Constant " %08LX">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     xfunc_in

   \                                 In section .rodata, align 4
   \                     `?<Constant "%08lX ">`:
   \   00000000   0x25 0x30          DC8 "%08lX "
   \              0x38 0x6C    
   \              0x58 0x20    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant " %02X">`:
   \   00000000   0x20 0x25          DC8 " %02X"
   \              0x30 0x32    
   \              0x58 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant " %04X">`:
   \   00000000   0x20 0x25          DC8 " %04X"
   \              0x30 0x34    
   \              0x58 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant " %08LX">`:
   \   00000000   0x20 0x25          DC8 " %08LX"
   \              0x30 0x38    
   \              0x4C 0x58    
   \              0x00         
   \   00000007   0x00               DC8 0
    393          
    394          #endif /* _USE_XFUNC_IN */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       40  put_dump
             40 -> xprintf
             40 -> xputc
       12  xatoi
       24  xfgets
             24 -> xgets
       32  xfprintf
             32 -> xvprintf
       16  xfputs
             16 -> xputc
       24  xgets
             24 -- Indirect call
             24 -> xputc
       24  xprintf
             24 -> xvprintf
        8  xputc
              8 -- Indirect call
              8 -> xputc
        8  xputs
              8 -> xputc
       24  xsprintf
             24 -> xvprintf
       64  xvprintf
             64 -> xputc
             64 -> xputs


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant " %02X">
       8  ?<Constant " %04X">
       8  ?<Constant " %08LX">
       8  ?<Constant "%08lX ">
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  outptr
     166  put_dump
     248  xatoi
      40  xfgets
      40  xfprintf
      44  xfputs
       4  xfunc_in
       4  xfunc_out
     102  xgets
      24  xprintf
      74  xputc
      22  xputs
      44  xsprintf
     586  xvprintf

 
    12 bytes in section .bss
    32 bytes in section .rodata
 1 418 bytes in section .text
 
 1 418 bytes of CODE  memory
    32 bytes of CONST memory
    12 bytes of DATA  memory

Errors: none
Warnings: none
