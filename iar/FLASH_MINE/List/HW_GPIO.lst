###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     07/Aug/2014  15:34:31 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\source\lib\ #
#                    LPLD\HW\HW_GPIO.c                                        #
#    Command line =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\source\lib\ #
#                    LPLD\HW\HW_GPIO.c -D LPLD_K60 -lCN                       #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\FLASH_M #
#                    INE\List\ -lB E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_ #
#                    V3\iar\FLASH_MINE\List\ -o E:\ShawnDocuments\IAR_WorkSpa #
#                    ce\LPLD_Quad_V3\iar\FLASH_MINE\Obj\ --no_cse             #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\app\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\ #
#                    iar\..\source\app\Control\ -I                            #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\app\Others\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Q #
#                    uad_V3\iar\..\source\app\Communicate\ -I                 #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\app\Algorithm\ -I E:\ShawnDocuments\IAR_WorkSpace\LPL #
#                    D_Quad_V3\iar\..\source\app\SignalProcess\ -I            #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\module\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_ #
#                    V3\iar\..\source\module\anbt_dmp\ -I                     #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\module\eMPL\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_ #
#                    Quad_V3\iar\..\source\lib\CPU\ -I                        #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\common\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Q #
#                    uad_V3\iar\..\source\lib\LPLD\ -I                        #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\LPLD\HW\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_ #
#                    Quad_V3\iar\..\source\lib\LPLD\DEV\ -I                   #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\uCOS-II\Ports\ -I E:\ShawnDocuments\IAR_WorkSpace #
#                    \LPLD_Quad_V3\iar\..\source\lib\uCOS-II\Source\ -I       #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\FatFs\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Qu #
#                    ad_V3\iar\..\source\lib\FatFs\option\ -I                 #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\USB\common\ -I E:\ShawnDocuments\IAR_WorkSpace\LP #
#                    LD_Quad_V3\iar\..\source\lib\USB\driver\ -I              #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\USB\descriptor\ -I E:\ShawnDocuments\IAR_WorkSpac #
#                    e\LPLD_Quad_V3\iar\..\source\lib\USB\class\ -I           #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\..\sour #
#                    ce\lib\MyLib\ -On -I "D:\Program Files\IAR               #
#                    Systems\Embedded Workbench 6.4\arm\CMSIS\Include\" -D    #
#                    ARM_MATH_CM4                                             #
#    List file    =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\FLASH_M #
#                    INE\List\HW_GPIO.lst                                     #
#    Object file  =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\iar\FLASH_M #
#                    INE\Obj\HW_GPIO.o                                        #
#                                                                             #
#                                                                             #
###############################################################################

E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V3\source\lib\LPLD\HW\HW_GPIO.c
      1          /**
      2           * @file HW_GPIO.c
      3           * @version 3.03[By LPLD]
      4           * @date 2014-2-10
      5           * @brief GPIO底层模块相关函数
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * 版权所有:北京拉普兰德电子技术有限公司
     10           * http://www.lpld.cn
     11           * mail:support@lpld.cn
     12           *
     13           * @par
     14           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     15           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     16           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     17           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     18           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     19           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     20           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     21           */
     22          #include "common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000004   0x0941             LSRS     R1,R0,#+5
   \   00000006   0x....             LDR.N    R2,??DataTable9  ;; 0xe000e100
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0xF010 0x041F      ANDS     R4,R0,#0x1F
   \   0000000E   0x40A3             LSLS     R3,R3,R4
   \   00000010   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000004   0x0941             LSRS     R1,R0,#+5
   \   00000006   0x....             LDR.N    R2,??DataTable9_1  ;; 0xe000e180
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0xF010 0x041F      ANDS     R4,R0,#0x1F
   \   0000000E   0x40A3             LSLS     R3,R3,R4
   \   00000010   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return
     23          #include "HW_GPIO.h"
     24          
     25          
     26          //用户自定义中断服务函数数组

   \                                 In section .bss, align 4
     27          GPIO_ISR_CALLBACK GPIO_ISR[5];
   \                     GPIO_ISR:
   \   00000000                      DS8 20
     28          
     29          /*
     30           * LPLD_GPIO_Init
     31           * GPIO通用初始化函数
     32           * 
     33           * 参数:
     34           *    gpio_init_structure--GPIO初始化结构体，
     35           *                        具体定义见GPIO_InitTypeDef
     36           *
     37           * 输出:
     38           *    0--配置错误
     39           *    1--配置成功
     40           */

   \                                 In section .text, align 2, keep-with-next
     41          uint8 LPLD_GPIO_Init(GPIO_InitTypeDef gpio_init_structure)
     42          {
   \                     LPLD_GPIO_Init:
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB5F0             PUSH     {R4-R7,LR}
     43            uint8 i;
     44            PORT_Type *portx;
     45            uint32 pcr = PORT_PCR_MUX(1)| gpio_init_structure.GPIO_PinControl; 
   \   00000004   0x9807             LDR      R0,[SP, #+28]
   \   00000006   0xF450 0x7380      ORRS     R3,R0,#0x100
     46            GPIO_Type *ptx = gpio_init_structure.GPIO_PTx;
   \   0000000A   0x9C05             LDR      R4,[SP, #+20]
     47            uint32 pins = gpio_init_structure.GPIO_Pins;
   \   0000000C   0x9D06             LDR      R5,[SP, #+24]
     48            uint8 dir = gpio_init_structure.GPIO_Dir;
   \   0000000E   0xF89D 0x6020      LDRB     R6,[SP, #+32]
     49            uint8 output = gpio_init_structure.GPIO_Output;
   \   00000012   0xF89D 0x7021      LDRB     R7,[SP, #+33]
     50            GPIO_ISR_CALLBACK isr_func = gpio_init_structure.GPIO_Isr;
   \   00000016   0xF8DD 0xC024      LDR      R12,[SP, #+36]
     51            
     52            //参数检查
     53            ASSERT( ptx <= PTE);                  //判断端口
     54            ASSERT( dir <= 1 );                   //判断方向
     55            ASSERT( output <= 1 );                //判断输出电平状态
     56            
     57            if(ptx == PTA)
   \   0000001A   0x....             LDR.N    R0,??DataTable9_2  ;; 0x400ff000
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD104             BNE.N    ??LPLD_GPIO_Init_0
     58            {
     59              portx = PORTA;  
   \   00000020   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40049000
   \   00000022   0x0002             MOVS     R2,R0
     60              i = 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x0001             MOVS     R1,R0
   \   00000028   0xE021             B.N      ??LPLD_GPIO_Init_1
     61            }
     62            else if(ptx == PTB) 
   \                     ??LPLD_GPIO_Init_0:
   \   0000002A   0x....             LDR.N    R0,??DataTable9_4  ;; 0x400ff040
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD104             BNE.N    ??LPLD_GPIO_Init_2
     63            {
     64              portx = PORTB;
   \   00000030   0x....             LDR.N    R0,??DataTable9_5  ;; 0x4004a000
   \   00000032   0x0002             MOVS     R2,R0
     65              i = 1;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x0001             MOVS     R1,R0
   \   00000038   0xE019             B.N      ??LPLD_GPIO_Init_1
     66            }
     67            else if(ptx == PTC) 
   \                     ??LPLD_GPIO_Init_2:
   \   0000003A   0x....             LDR.N    R0,??DataTable9_6  ;; 0x400ff080
   \   0000003C   0x4284             CMP      R4,R0
   \   0000003E   0xD104             BNE.N    ??LPLD_GPIO_Init_3
     68            {
     69              portx = PORTC;
   \   00000040   0x....             LDR.N    R0,??DataTable9_7  ;; 0x4004b000
   \   00000042   0x0002             MOVS     R2,R0
     70              i = 2;
   \   00000044   0x2002             MOVS     R0,#+2
   \   00000046   0x0001             MOVS     R1,R0
   \   00000048   0xE011             B.N      ??LPLD_GPIO_Init_1
     71            }
     72            else if(ptx == PTD) 
   \                     ??LPLD_GPIO_Init_3:
   \   0000004A   0x....             LDR.N    R0,??DataTable9_8  ;; 0x400ff0c0
   \   0000004C   0x4284             CMP      R4,R0
   \   0000004E   0xD104             BNE.N    ??LPLD_GPIO_Init_4
     73            {
     74              portx = PORTD;
   \   00000050   0x....             LDR.N    R0,??DataTable9_9  ;; 0x4004c000
   \   00000052   0x0002             MOVS     R2,R0
     75              i = 3; 
   \   00000054   0x2003             MOVS     R0,#+3
   \   00000056   0x0001             MOVS     R1,R0
   \   00000058   0xE009             B.N      ??LPLD_GPIO_Init_1
     76            }
     77            else if(ptx == PTE) 
   \                     ??LPLD_GPIO_Init_4:
   \   0000005A   0x....             LDR.N    R0,??DataTable9_10  ;; 0x400ff100
   \   0000005C   0x4284             CMP      R4,R0
   \   0000005E   0xD104             BNE.N    ??LPLD_GPIO_Init_5
     78            {
     79              portx = PORTE;
   \   00000060   0x....             LDR.N    R0,??DataTable9_11  ;; 0x4004d000
   \   00000062   0x0002             MOVS     R2,R0
     80              i = 4;
   \   00000064   0x2004             MOVS     R0,#+4
   \   00000066   0x0001             MOVS     R1,R0
   \   00000068   0xE001             B.N      ??LPLD_GPIO_Init_1
     81            }
     82            else
     83              return 0;
   \                     ??LPLD_GPIO_Init_5:
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xE027             B.N      ??LPLD_GPIO_Init_6
     84            
     85            //输入或输出设置
     86            if(dir==DIR_OUTPUT)
   \                     ??LPLD_GPIO_Init_1:
   \   0000006E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000070   0x2E01             CMP      R6,#+1
   \   00000072   0xD109             BNE.N    ??LPLD_GPIO_Init_7
     87            {
     88              ptx->PDDR |= pins;
   \   00000074   0x6960             LDR      R0,[R4, #+20]
   \   00000076   0x4328             ORRS     R0,R5,R0
   \   00000078   0x6160             STR      R0,[R4, #+20]
     89              //设置初始输出
     90              if(output==OUTPUT_H)
   \   0000007A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000007C   0x2F01             CMP      R7,#+1
   \   0000007E   0xD101             BNE.N    ??LPLD_GPIO_Init_8
     91              {
     92                ptx->PSOR = pins; 
   \   00000080   0x6065             STR      R5,[R4, #+4]
   \   00000082   0xE004             B.N      ??LPLD_GPIO_Init_9
     93              }
     94              else
     95              {
     96                ptx->PCOR = pins;
   \                     ??LPLD_GPIO_Init_8:
   \   00000084   0x60A5             STR      R5,[R4, #+8]
   \   00000086   0xE002             B.N      ??LPLD_GPIO_Init_9
     97              }
     98            }
     99            else
    100            { 
    101              ptx->PDDR &= ~(pins);
   \                     ??LPLD_GPIO_Init_7:
   \   00000088   0x6960             LDR      R0,[R4, #+20]
   \   0000008A   0x43A8             BICS     R0,R0,R5
   \   0000008C   0x6160             STR      R0,[R4, #+20]
    102            }
    103            
    104            //配置所选引脚的控制寄存器
    105            for(uint8 i=0; i<32; i++)
   \                     ??LPLD_GPIO_Init_9:
   \   0000008E   0x2000             MOVS     R0,#+0
   \                     ??LPLD_GPIO_Init_10:
   \   00000090   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000092   0x2820             CMP      R0,#+32
   \   00000094   0xD20B             BCS.N    ??LPLD_GPIO_Init_11
    106            {
    107              if(pins&(1ul<<i))
   \   00000096   0xF05F 0x0E01      MOVS     LR,#+1
   \   0000009A   0xFA1E 0xFE00      LSLS     LR,LR,R0
   \   0000009E   0xEA15 0x0F0E      TST      R5,LR
   \   000000A2   0xD002             BEQ.N    ??LPLD_GPIO_Init_12
    108              {
    109                portx->PCR[i] = pcr;
   \   000000A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A6   0xF842 0x3020      STR      R3,[R2, R0, LSL #+2]
    110              }
    111            }
   \                     ??LPLD_GPIO_Init_12:
   \   000000AA   0x1C40             ADDS     R0,R0,#+1
   \   000000AC   0xE7F0             B.N      ??LPLD_GPIO_Init_10
    112          
    113            if(isr_func!=NULL)
   \                     ??LPLD_GPIO_Init_11:
   \   000000AE   0x4660             MOV      R0,R12
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD003             BEQ.N    ??LPLD_GPIO_Init_13
    114              GPIO_ISR[i] = isr_func;
   \   000000B4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B6   0x....             LDR.N    R0,??DataTable9_12
   \   000000B8   0xF840 0xC021      STR      R12,[R0, R1, LSL #+2]
    115            
    116            return 1;
   \                     ??LPLD_GPIO_Init_13:
   \   000000BC   0x2001             MOVS     R0,#+1
   \                     ??LPLD_GPIO_Init_6:
   \   000000BE   0xBCF0             POP      {R4-R7}
   \   000000C0   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    117          }
    118          
    119          /*
    120           * LPLD_GPIO_EnableIrq
    121           * 使能GPIO外部中断
    122           * 
    123           * 参数:
    124           *    gpio_init_structure--GPIO初始化结构体，
    125           *                        具体定义见GPIO_InitTypeDef
    126           *
    127           * 输出:
    128           *    0--配置错误
    129           *    1--配置成功
    130           *
    131           */

   \                                 In section .text, align 2, keep-with-next
    132          uint8 LPLD_GPIO_EnableIrq(GPIO_InitTypeDef gpio_init_structure)
    133          {
   \                     LPLD_GPIO_EnableIrq:
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB538             PUSH     {R3-R5,LR}
    134            uint8 i;
    135            GPIO_Type *ptx = gpio_init_structure.GPIO_PTx;
   \   00000004   0x9D04             LDR      R5,[SP, #+16]
    136            
    137            //参数检查
    138            ASSERT( ptx <= PTE);                  //判断端口
    139            
    140            if(ptx == PTA)
   \   00000006   0x....             LDR.N    R0,??DataTable9_2  ;; 0x400ff000
   \   00000008   0x4285             CMP      R5,R0
   \   0000000A   0xD102             BNE.N    ??LPLD_GPIO_EnableIrq_0
    141              i = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0004             MOVS     R4,R0
   \   00000010   0xE013             B.N      ??LPLD_GPIO_EnableIrq_1
    142            else if(ptx == PTB) 
   \                     ??LPLD_GPIO_EnableIrq_0:
   \   00000012   0x....             LDR.N    R0,??DataTable9_4  ;; 0x400ff040
   \   00000014   0x4285             CMP      R5,R0
   \   00000016   0xD102             BNE.N    ??LPLD_GPIO_EnableIrq_2
    143              i = 1;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x0004             MOVS     R4,R0
   \   0000001C   0xE00D             B.N      ??LPLD_GPIO_EnableIrq_1
    144            else if(ptx == PTC) 
   \                     ??LPLD_GPIO_EnableIrq_2:
   \   0000001E   0x....             LDR.N    R0,??DataTable9_6  ;; 0x400ff080
   \   00000020   0x4285             CMP      R5,R0
   \   00000022   0xD102             BNE.N    ??LPLD_GPIO_EnableIrq_3
    145              i = 2;
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0x0004             MOVS     R4,R0
   \   00000028   0xE007             B.N      ??LPLD_GPIO_EnableIrq_1
    146            else if(ptx == PTD) 
   \                     ??LPLD_GPIO_EnableIrq_3:
   \   0000002A   0x....             LDR.N    R0,??DataTable9_8  ;; 0x400ff0c0
   \   0000002C   0x4285             CMP      R5,R0
   \   0000002E   0xD102             BNE.N    ??LPLD_GPIO_EnableIrq_4
    147              i = 3;
   \   00000030   0x2003             MOVS     R0,#+3
   \   00000032   0x0004             MOVS     R4,R0
   \   00000034   0xE001             B.N      ??LPLD_GPIO_EnableIrq_1
    148            else
    149              i = 4;
   \                     ??LPLD_GPIO_EnableIrq_4:
   \   00000036   0x2004             MOVS     R0,#+4
   \   00000038   0x0004             MOVS     R4,R0
    150          
    151            enable_irq((IRQn_Type)(i + PORTA_IRQn));
   \                     ??LPLD_GPIO_EnableIrq_1:
   \   0000003A   0xF114 0x0057      ADDS     R0,R4,#+87
   \   0000003E   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000040   0x.... 0x....      BL       NVIC_EnableIRQ
    152            
    153            return 1;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xBC32             POP      {R1,R4,R5}
   \   00000048   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    154          }
    155          
    156          /*
    157           * LPLD_GPIO_DisableIrq
    158           * 禁用GPIO外部中断
    159           * 
    160           * 参数:
    161           *    gpio_init_structure--GPIO初始化结构体，
    162           *                        具体定义见GPIO_InitTypeDef
    163           *
    164           * 输出:
    165           *    0--配置错误
    166           *    1--配置成功
    167           *
    168           */

   \                                 In section .text, align 2, keep-with-next
    169          uint8 LPLD_GPIO_DisableIrq(GPIO_InitTypeDef gpio_init_structure)
    170          {
   \                     LPLD_GPIO_DisableIrq:
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB538             PUSH     {R3-R5,LR}
    171            uint8 i;
    172            GPIO_Type *ptx = gpio_init_structure.GPIO_PTx;
   \   00000004   0x9D04             LDR      R5,[SP, #+16]
    173            
    174            //参数检查
    175            ASSERT( ptx <= PTE);                  //判断端口
    176            
    177            if(ptx == PTA)
   \   00000006   0x....             LDR.N    R0,??DataTable9_2  ;; 0x400ff000
   \   00000008   0x4285             CMP      R5,R0
   \   0000000A   0xD102             BNE.N    ??LPLD_GPIO_DisableIrq_0
    178              i = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0004             MOVS     R4,R0
   \   00000010   0xE013             B.N      ??LPLD_GPIO_DisableIrq_1
    179            else if(ptx == PTB) 
   \                     ??LPLD_GPIO_DisableIrq_0:
   \   00000012   0x....             LDR.N    R0,??DataTable9_4  ;; 0x400ff040
   \   00000014   0x4285             CMP      R5,R0
   \   00000016   0xD102             BNE.N    ??LPLD_GPIO_DisableIrq_2
    180              i = 1;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x0004             MOVS     R4,R0
   \   0000001C   0xE00D             B.N      ??LPLD_GPIO_DisableIrq_1
    181            else if(ptx == PTC) 
   \                     ??LPLD_GPIO_DisableIrq_2:
   \   0000001E   0x....             LDR.N    R0,??DataTable9_6  ;; 0x400ff080
   \   00000020   0x4285             CMP      R5,R0
   \   00000022   0xD102             BNE.N    ??LPLD_GPIO_DisableIrq_3
    182              i = 2;
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0x0004             MOVS     R4,R0
   \   00000028   0xE007             B.N      ??LPLD_GPIO_DisableIrq_1
    183            else if(ptx == PTD) 
   \                     ??LPLD_GPIO_DisableIrq_3:
   \   0000002A   0x....             LDR.N    R0,??DataTable9_8  ;; 0x400ff0c0
   \   0000002C   0x4285             CMP      R5,R0
   \   0000002E   0xD102             BNE.N    ??LPLD_GPIO_DisableIrq_4
    184              i = 3;
   \   00000030   0x2003             MOVS     R0,#+3
   \   00000032   0x0004             MOVS     R4,R0
   \   00000034   0xE001             B.N      ??LPLD_GPIO_DisableIrq_1
    185            else
    186              i = 4;
   \                     ??LPLD_GPIO_DisableIrq_4:
   \   00000036   0x2004             MOVS     R0,#+4
   \   00000038   0x0004             MOVS     R4,R0
    187            
    188            disable_irq((IRQn_Type)(i + PORTA_IRQn));
   \                     ??LPLD_GPIO_DisableIrq_1:
   \   0000003A   0xF114 0x0057      ADDS     R0,R4,#+87
   \   0000003E   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000040   0x.... 0x....      BL       NVIC_DisableIRQ
    189            
    190            return 1;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xBC32             POP      {R1,R4,R5}
   \   00000048   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    191          }
    192          
    193          /*
    194           * LPLD_GPIO_Ouptut
    195           * 设置GPIO端口0~31位的输出
    196           * 
    197           * 参数:
    198           *    ptx--端口号
    199           *      |__PTA        --Port A
    200           *      |__PTB        --Port B
    201           *      |__PTC        --Port C
    202           *      |__PTD        --Port D
    203           *      |__PTE        --Port E
    204           *    data32--输出数据
    205           *      |__0x00000000~0xFFFFFFFF--低到高代表GPIO口的第0~31位数据
    206           *
    207           * 输出:
    208           *
    209           */

   \                                 In section .text, align 2, keep-with-next
    210          __INLINE void LPLD_GPIO_Output(GPIO_Type *ptx, uint32 data32)
    211          { 
    212            ptx->PDOR = data32;
   \                     LPLD_GPIO_Output:
   \   00000000   0x6001             STR      R1,[R0, #+0]
    213          }
   \   00000002   0x4770             BX       LR               ;; return
    214          
    215          /*
    216           * LPLD_GPIO_Ouptut_b
    217           * 设置GPIO端口一位的输出
    218           * 
    219           * 参数:
    220           *    ptx--端口号
    221           *      |__PTA        --Port A
    222           *      |__PTB        --Port B
    223           *      |__PTC        --Port C
    224           *      |__PTD        --Port D
    225           *      |__PTE        --Port E
    226           *    lsb_num--端口引脚位数编号
    227           *      |__0~31       --GPIO口的第0~31位
    228           *    data1--输出数据
    229           *      |__0          --输出低电平
    230           *      |__1          --输出高电平
    231           *
    232           * 输出:
    233           *
    234           */

   \                                 In section .text, align 2, keep-with-next
    235          __INLINE void LPLD_GPIO_Output_b(GPIO_Type *ptx, uint32 lsb_num, uint8 data1)
    236          {
   \                     LPLD_GPIO_Output_b:
   \   00000000   0xB410             PUSH     {R4}
    237            ptx->PDOR = (ptx->PDOR & ~(0x01L<<lsb_num)) | (uint32)data1<<lsb_num;
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x2401             MOVS     R4,#+1
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0xFA12 0xF401      LSLS     R4,R2,R1
   \   00000010   0x4323             ORRS     R3,R4,R3
   \   00000012   0x6003             STR      R3,[R0, #+0]
    238          }
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return
    239          
    240          /*
    241           * LPLD_GPIO_Ouptut_8b
    242           * 设置GPIO端口8位的输出
    243           * 
    244           * 参数:
    245           *    ptx--端口号
    246           *      |__PTA        --Port A
    247           *      |__PTB        --Port B
    248           *      |__PTC        --Port C
    249           *      |__PTD        --Port D
    250           *      |__PTE        --Port E
    251           *    lsb_num--代表8个端口引脚的最低位数编号
    252           *      |__0~24       --GPIO口的第0~24位
    253           *    data8--输出数据
    254           *      |__0x00~0xFF--代表GPIO口输出的8位数据
    255           *
    256           * 输出:
    257           *
    258           */

   \                                 In section .text, align 2, keep-with-next
    259          __INLINE void LPLD_GPIO_Output_8b(GPIO_Type *ptx, uint8 lsb_num, uint8 data8)
    260          {
   \                     LPLD_GPIO_Output_8b:
   \   00000000   0xB410             PUSH     {R4}
    261            ptx->PDOR = (ptx->PDOR & ~(0xFFL<<lsb_num)) | (uint32)data8<<lsb_num;
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x24FF             MOVS     R4,#+255
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0xFA12 0xF401      LSLS     R4,R2,R1
   \   00000010   0x4323             ORRS     R3,R4,R3
   \   00000012   0x6003             STR      R3,[R0, #+0]
    262          }
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return
    263          
    264          /*
    265           * LPLD_GPIO_Toggle
    266           * 设置GPIO端口0~31的电平翻转
    267           * 
    268           * 参数:
    269           *    ptx--端口号
    270           *      |__PTA        --Port A
    271           *      |__PTB        --Port B
    272           *      |__PTC        --Port C
    273           *      |__PTD        --Port D
    274           *      |__PTE        --Port E
    275           *    data32--翻转数据
    276           *      |__0x00000000~0xFFFFFFFF--低到高代表GPIO口的第0~31位的翻转，1为反转，0为保持不变。
    277           *
    278           * 输出:
    279           *
    280           */

   \                                 In section .text, align 2, keep-with-next
    281          __INLINE void LPLD_GPIO_Toggle(GPIO_Type *ptx, uint32 data32)
    282          {  
    283            ptx->PTOR = data32;
   \                     LPLD_GPIO_Toggle:
   \   00000000   0x60C1             STR      R1,[R0, #+12]
    284          }
   \   00000002   0x4770             BX       LR               ;; return
    285          
    286          /*
    287           * LPLD_GPIO_Toggle_b
    288           * 设置GPIO端口一位的翻转
    289           * 
    290           * 参数:
    291           *    ptx--端口号
    292           *      |__PTA        --Port A
    293           *      |__PTB        --Port B
    294           *      |__PTC        --Port C
    295           *      |__PTD        --Port D
    296           *      |__PTE        --Port E
    297           *    lsb_num--端口引脚位数编号
    298           *      |__0~31       --GPIO口的第0~31位
    299           *
    300           * 输出:
    301           *
    302           */

   \                                 In section .text, align 2, keep-with-next
    303          __INLINE void LPLD_GPIO_Toggle_b(GPIO_Type *ptx, uint8 lsb_num)
    304          {  
    305            ptx->PTOR = 0x01L<<lsb_num;
   \                     LPLD_GPIO_Toggle_b:
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0x408A             LSLS     R2,R2,R1
   \   00000004   0x60C2             STR      R2,[R0, #+12]
    306          }
   \   00000006   0x4770             BX       LR               ;; return
    307          
    308          /*
    309           * LPLD_GPIO_Toggle_8b
    310           * 设置GPIO端口8位的翻转
    311           * 
    312           * 参数:
    313           *    ptx--端口号
    314           *      |__PTA        --Port A
    315           *      |__PTB        --Port B
    316           *      |__PTC        --Port C
    317           *      |__PTD        --Port D
    318           *      |__PTE        --Port E
    319           *    lsb_num--代表8个端口引脚的最低位数编号
    320           *      |__0~24       --GPIO口的第0~24位
    321           *    data8--输出数据
    322           *      |__0x00~0xFF--代表GPIO口输出的8位数据
    323           *
    324           * 输出:
    325           *
    326           */

   \                                 In section .text, align 2, keep-with-next
    327          __INLINE void LPLD_GPIO_Toggle_8b(GPIO_Type *ptx, uint8 lsb_num, uint8 data8)
    328          {
    329            ptx->PTOR = (uint32)data8<<lsb_num;
   \                     LPLD_GPIO_Toggle_8b:
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0xFA12 0xF301      LSLS     R3,R2,R1
   \   00000006   0x60C3             STR      R3,[R0, #+12]
    330          }
   \   00000008   0x4770             BX       LR               ;; return
    331          
    332          /*
    333           * LPLD_GPIO_Input
    334           * 取得GPIO口0~31位的数据
    335           * 
    336           * 参数:
    337           *    ptx--端口号
    338           *      |__PTA        --Port A
    339           *      |__PTB        --Port B
    340           *      |__PTC        --Port C
    341           *      |__PTD        --Port D
    342           *      |__PTE        --Port E
    343           *
    344           * 输出:
    345           *    指定GPIO口的32位输入
    346           *
    347           */

   \                                 In section .text, align 2, keep-with-next
    348          __INLINE uint32 LPLD_GPIO_Input(GPIO_Type *ptx)
    349          {
    350            return ptx->PDIR;
   \                     LPLD_GPIO_Input:
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x4770             BX       LR               ;; return
    351          }
    352          
    353          /*
    354           * LPLD_GPIO_Input_b
    355           * 取得GPIO口某一位的数据
    356           * 
    357           * 参数:
    358           *    ptx--端口号
    359           *      |__PTA        --Port A
    360           *      |__PTB        --Port B
    361           *      |__PTC        --Port C
    362           *      |__PTD        --Port D
    363           *      |__PTE        --Port E
    364           *    lsb_num--端口引脚位数编号
    365           *      |__0~31       --GPIO口的第0~31位
    366           *
    367           * 输出:
    368           *    指定GPIO口的指定位数的电平
    369           *
    370           */

   \                                 In section .text, align 2, keep-with-next
    371          __INLINE uint8 LPLD_GPIO_Input_b(GPIO_Type *ptx, uint8 lsb_num)
    372          {  
    373            return (uint8)((ptx->PDIR>>lsb_num)&0x01L);
   \                     LPLD_GPIO_Input_b:
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x40C8             LSRS     R0,R0,R1
   \   00000004   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000008   0x4770             BX       LR               ;; return
    374          }
    375          
    376          /*
    377           * LPLD_GPIO_Input_8b
    378           * 取得GPIO端口8位数据的输入
    379           * 
    380           * 参数:
    381           *    ptx--端口号
    382           *      |__PTA        --Port A
    383           *      |__PTB        --Port B
    384           *      |__PTC        --Port C
    385           *      |__PTD        --Port D
    386           *      |__PTE        --Port E
    387           *    lsb_num--代表8个端口引脚的最低位数编号
    388           *      |__0~24       --GPIO口的第0~24位
    389           *
    390           * 输出:
    391           *    指定GPIO口的8位数据的电平
    392           *
    393           */

   \                                 In section .text, align 2, keep-with-next
    394          __INLINE uint8 LPLD_GPIO_Input_8b(GPIO_Type *ptx, uint8 lsb_num)
    395          {
    396            return (uint8)((ptx->PDIR>>lsb_num)&0xFFL);
   \                     LPLD_GPIO_Input_8b:
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x40C8             LSRS     R0,R0,R1
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x4770             BX       LR               ;; return
    397          }
    398          
    399          /*
    400           * PORTA--PORTE中断处理函数
    401           * 与启动文件startup_K60.s中的中断向量表关联
    402           * 用户无需修改，程序自动进入对应通道中断函数
    403           */

   \                                 In section .text, align 2, keep-with-next
    404          void PORTA_IRQHandler(void)
    405          {
   \                     PORTA_IRQHandler:
   \   00000000   0xB580             PUSH     {R7,LR}
    406          #if (UCOS_II > 0u)
    407            OS_CPU_SR  cpu_sr = 0u;
    408            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    409            OSIntEnter();
    410            OS_EXIT_CRITICAL();
    411          #endif
    412            
    413            //调用用户自定义中断服务
    414            GPIO_ISR[0](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    415            PORTA->ISFR =0xFFFFFFFF;
   \   00000008   0x....             LDR.N    R0,??DataTable9_13  ;; 0x400490a0
   \   0000000A   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    416            
    417          #if (UCOS_II > 0u)
    418            OSIntExit();          //告知系统此时即将离开中断服务子函数
    419          #endif
    420          }//           ;87:  PORT A interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    421          

   \                                 In section .text, align 2, keep-with-next
    422          void PORTB_IRQHandler(void)
    423          {
   \                     PORTB_IRQHandler:
   \   00000000   0xB580             PUSH     {R7,LR}
    424          #if (UCOS_II > 0u)
    425            OS_CPU_SR  cpu_sr = 0u;
    426            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    427            OSIntEnter();
    428            OS_EXIT_CRITICAL();
    429          #endif
    430            
    431            //调用用户自定义中断服务
    432            GPIO_ISR[1](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x6840             LDR      R0,[R0, #+4]
   \   00000006   0x4780             BLX      R0
    433            PORTB->ISFR =0xFFFFFFFF;
   \   00000008   0x....             LDR.N    R0,??DataTable9_14  ;; 0x4004a0a0
   \   0000000A   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    434            
    435          #if (UCOS_II > 0u)
    436            OSIntExit();          //告知系统此时即将离开中断服务子函数
    437          #endif
    438          }//           ;88:  PORT B interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    439          

   \                                 In section .text, align 2, keep-with-next
    440          void PORTC_IRQHandler(void)
    441          {
   \                     PORTC_IRQHandler:
   \   00000000   0xB580             PUSH     {R7,LR}
    442          #if (UCOS_II > 0u)
    443            OS_CPU_SR  cpu_sr = 0u;
    444            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    445            OSIntEnter();
    446            OS_EXIT_CRITICAL();
    447          #endif
    448            
    449            //调用用户自定义中断服务
    450            GPIO_ISR[2](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x6880             LDR      R0,[R0, #+8]
   \   00000006   0x4780             BLX      R0
    451            PORTC->ISFR =0xFFFFFFFF;
   \   00000008   0x....             LDR.N    R0,??DataTable9_15  ;; 0x4004b0a0
   \   0000000A   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    452            
    453          #if (UCOS_II > 0u)
    454            OSIntExit();          //告知系统此时即将离开中断服务子函数
    455          #endif
    456          }//           ;89:  PORT C interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    457          

   \                                 In section .text, align 2, keep-with-next
    458          void PORTD_IRQHandler(void)
    459          {
   \                     PORTD_IRQHandler:
   \   00000000   0xB580             PUSH     {R7,LR}
    460          #if (UCOS_II > 0u)
    461            OS_CPU_SR  cpu_sr = 0u;
    462            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    463            OSIntEnter();
    464            OS_EXIT_CRITICAL();
    465          #endif
    466            
    467            //调用用户自定义中断服务
    468            GPIO_ISR[3](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0x4780             BLX      R0
    469            PORTD->ISFR =0xFFFFFFFF;
   \   00000008   0x....             LDR.N    R0,??DataTable9_16  ;; 0x4004c0a0
   \   0000000A   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    470            
    471          #if (UCOS_II > 0u)
    472            OSIntExit();          //告知系统此时即将离开中断服务子函数
    473          #endif
    474          }//           ;90:  PORT D interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    475          

   \                                 In section .text, align 2, keep-with-next
    476          void PORTE_IRQHandler(void)
    477          {
   \                     PORTE_IRQHandler:
   \   00000000   0xB580             PUSH     {R7,LR}
    478          #if (UCOS_II > 0u)
    479            OS_CPU_SR  cpu_sr = 0u;
    480            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    481            OSIntEnter();
    482            OS_EXIT_CRITICAL();
    483          #endif
    484            
    485            //调用用户自定义中断服务
    486            GPIO_ISR[4](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x6900             LDR      R0,[R0, #+16]
   \   00000006   0x4780             BLX      R0
    487            PORTE->ISFR =0xFFFFFFFF;
   \   00000008   0x....             LDR.N    R0,??DataTable9_17  ;; 0x4004d0a0
   \   0000000A   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    488            
    489          #if (UCOS_II > 0u)
    490            OSIntExit();          //告知系统此时即将离开中断服务子函数
    491          #endif
    492          }//           ;91:  PORT E interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x400FF000         DC32     0x400ff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x40049000         DC32     0x40049000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x400FF040         DC32     0x400ff040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x4004A000         DC32     0x4004a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x400FF080         DC32     0x400ff080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x4004B000         DC32     0x4004b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x400FF0C0         DC32     0x400ff0c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x4004C000         DC32     0x4004c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x400FF100         DC32     0x400ff100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x4004D000         DC32     0x4004d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x........         DC32     GPIO_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x400490A0         DC32     0x400490a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x4004A0A0         DC32     0x4004a0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0x4004B0A0         DC32     0x4004b0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   0x4004C0A0         DC32     0x4004c0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   0x4004D0A0         DC32     0x4004d0a0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       32  LPLD_GPIO_DisableIrq
             32 -> NVIC_DisableIRQ
       32  LPLD_GPIO_EnableIrq
             32 -> NVIC_EnableIRQ
       36  LPLD_GPIO_Init
        0  LPLD_GPIO_Input
        0  LPLD_GPIO_Input_8b
        0  LPLD_GPIO_Input_b
        0  LPLD_GPIO_Output
        4  LPLD_GPIO_Output_8b
        4  LPLD_GPIO_Output_b
        0  LPLD_GPIO_Toggle
        0  LPLD_GPIO_Toggle_8b
        0  LPLD_GPIO_Toggle_b
        4  NVIC_DisableIRQ
        4  NVIC_EnableIRQ
        8  PORTA_IRQHandler
              8 -- Indirect call
        8  PORTB_IRQHandler
              8 -- Indirect call
        8  PORTC_IRQHandler
              8 -- Indirect call
        8  PORTD_IRQHandler
              8 -- Indirect call
        8  PORTE_IRQHandler
              8 -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      20  GPIO_ISR
      76  LPLD_GPIO_DisableIrq
      76  LPLD_GPIO_EnableIrq
     196  LPLD_GPIO_Init
       4  LPLD_GPIO_Input
       8  LPLD_GPIO_Input_8b
      10  LPLD_GPIO_Input_b
       4  LPLD_GPIO_Output
      24  LPLD_GPIO_Output_8b
      24  LPLD_GPIO_Output_b
       4  LPLD_GPIO_Toggle
      10  LPLD_GPIO_Toggle_8b
       8  LPLD_GPIO_Toggle_b
      24  NVIC_DisableIRQ
      24  NVIC_EnableIRQ
      18  PORTA_IRQHandler
      18  PORTB_IRQHandler
      18  PORTC_IRQHandler
      18  PORTD_IRQHandler
      18  PORTE_IRQHandler

 
  20 bytes in section .bss
 654 bytes in section .text
 
 654 bytes of CODE memory
  20 bytes of DATA memory

Errors: none
Warnings: none
