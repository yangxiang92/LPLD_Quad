###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     19/Mar/2014  22:08:34 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\lib\FatFs\f #
#                    f.c                                                      #
#    Command line =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\lib\FatFs\f #
#                    f.c -D LPLD_K60 -lCN E:\ShawnDocuments\IAR_WorkSpace\LPL #
#                    D_Quad_V2\iar\RAM\List\ -lB                              #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\RAM\Lis #
#                    t\ -o E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\R #
#                    AM\Obj\ --no_cse --no_unroll --no_inline                 #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "D:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.4\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\i #
#                    ar\..\app\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_ #
#                    V2\iar\..\lib\CPU\ -I E:\ShawnDocuments\IAR_WorkSpace\LP #
#                    LD_Quad_V2\iar\..\lib\common\ -I                         #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\lib\ #
#                    LPLD\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\ia #
#                    r\..\lib\LPLD\HW\ -I E:\ShawnDocuments\IAR_WorkSpace\LPL #
#                    D_Quad_V2\iar\..\lib\LPLD\DEV\ -I                        #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\lib\ #
#                    uCOS-II\Ports\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Q #
#                    uad_V2\iar\..\lib\uCOS-II\Source\ -I                     #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\lib\ #
#                    FatFs\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\i #
#                    ar\..\lib\FatFs\option\ -I E:\ShawnDocuments\IAR_WorkSpa #
#                    ce\LPLD_Quad_V2\iar\..\lib\USB\common\ -I                #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\lib\ #
#                    USB\driver\ -I E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad #
#                    _V2\iar\..\lib\USB\descriptor\ -I                        #
#                    E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\..\lib\ #
#                    USB\class\ -Ol -I "D:\Program Files\IAR                  #
#                    Systems\Embedded Workbench 6.4\arm\CMSIS\Include\" -D    #
#                    ARM_MATH_CM4                                             #
#    List file    =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\RAM\Lis #
#                    t\ff.lst                                                 #
#    Object file  =  E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\iar\RAM\Obj #
#                    \ff.o                                                    #
#                                                                             #
#                                                                             #
###############################################################################

E:\ShawnDocuments\IAR_WorkSpace\LPLD_Quad_V2\lib\FatFs\ff.c
      1          /*----------------------------------------------------------------------------/
      2          /  FatFs - FAT file system module  R0.09b                 (C)ChaN, 2013
      3          /-----------------------------------------------------------------------------/
      4          / FatFs module is a generic FAT file system module for small embedded systems.
      5          / This is a free software that opened for education, research and commercial
      6          / developments under license policy of following terms.
      7          /
      8          /  Copyright (C) 2013, ChaN, all right reserved.
      9          /
     10          / * The FatFs module is a free software and there is NO WARRANTY.
     11          / * No restriction on use. You can use, modify and redistribute it for
     12          /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
     13          / * Redistributions of source code must retain the above copyright notice.
     14          /
     15          /-----------------------------------------------------------------------------/
     16          / Feb 26,'06 R0.00  Prototype.
     17          /
     18          / Apr 29,'06 R0.01  First stable version.
     19          /
     20          / Jun 01,'06 R0.02  Added FAT12 support.
     21          /                   Removed unbuffered mode.
     22          /                   Fixed a problem on small (<32M) partition.
     23          / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
     24          /
     25          / Sep 22,'06 R0.03  Added f_rename().
     26          /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
     27          / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
     28          /                   Fixed f_mkdir() creates incorrect directory on FAT32.
     29          /
     30          / Feb 04,'07 R0.04  Supported multiple drive system.
     31          /                   Changed some interfaces for multiple drive system.
     32          /                   Changed f_mountdrv() to f_mount().
     33          /                   Added f_mkfs().
     34          / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
     35          /                   Added a capability of extending file size to f_lseek().
     36          /                   Added minimization level 3.
     37          /                   Fixed an endian sensitive code in f_mkfs().
     38          / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
     39          /                   Added FSInfo support.
     40          /                   Fixed DBCS name can result FR_INVALID_NAME.
     41          /                   Fixed short seek (<= csize) collapses the file object.
     42          /
     43          / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
     44          /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
     45          /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
     46          / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
     47          /                   Fixed off by one error at FAT sub-type determination.
     48          /                   Fixed btr in f_read() can be mistruncated.
     49          /                   Fixed cached sector is not flushed when create and close without write.
     50          /
     51          / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
     52          /                   Improved performance of f_lseek() on moving to the same or following cluster.
     53          /
     54          / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
     55          /                   Added long file name feature.
     56          /                   Added multiple code page feature.
     57          /                   Added re-entrancy for multitask operation.
     58          /                   Added auto cluster size selection to f_mkfs().
     59          /                   Added rewind option to f_readdir().
     60          /                   Changed result code of critical errors.
     61          /                   Renamed string functions to avoid name collision.
     62          / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
     63          /                   Added multiple sector size feature.
     64          / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
     65          /                   Fixed wrong cache control in f_lseek().
     66          /                   Added relative path feature.
     67          /                   Added f_chdir() and f_chdrive().
     68          /                   Added proper case conversion to extended char.
     69          / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
     70          /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
     71          /                   Fixed name matching error on the 13 char boundary.
     72          /                   Added a configuration option, _LFN_UNICODE.
     73          /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
     74          /
     75          / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
     76          /                   Added file lock feature. (_FS_SHARE)
     77          /                   Added fast seek feature. (_USE_FASTSEEK)
     78          /                   Changed some types on the API, XCHAR->TCHAR.
     79          /                   Changed fname member in the FILINFO structure on Unicode cfg.
     80          /                   String functions support UTF-8 encoding files on Unicode cfg.
     81          / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
     82          /                   Added sector erase feature. (_USE_ERASE)
     83          /                   Moved file lock semaphore table from fs object to the bss.
     84          /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
     85          /                   Fixed f_mkfs() creates wrong FAT32 volume.
     86          / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
     87          /                   f_lseek() reports required table size on creating CLMP.
     88          /                   Extended format syntax of f_printf function.
     89          /                   Ignores duplicated directory separators in given path name.
     90          /
     91          / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
     92          /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
     93          / Aug 27,'12 R0.09a Fixed assertion failure due to OS/2 EA on FAT12/16 volume.
     94          /                   Changed f_open() and f_opendir reject null object pointer to avoid crash.
     95          /                   Changed option name _FS_SHARE to _FS_LOCK.
     96          / Jan 24,'13 R0.09b Added f_setlabel() and f_getlabel(). (_USE_LABEL = 1)
     97          /---------------------------------------------------------------------------*/
     98          
     99          #include "ff.h"			/* FatFs configurations and declarations */
    100          #include "diskio.h"		/* Declarations of low level disk I/O functions */
    101          
    102          
    103          /*--------------------------------------------------------------------------
    104          
    105             Module Private Definitions
    106          
    107          ---------------------------------------------------------------------------*/
    108          
    109          #if _FATFS != 82786	/* Revision ID */
    110          #error Wrong include file (ff.h).
    111          #endif
    112          
    113          
    114          /* Definitions on sector size */
    115          #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
    116          #error Wrong sector size.
    117          #endif
    118          #if _MAX_SS != 512
    119          #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
    120          #else
    121          #define	SS(fs)	512U			/* Fixed sector size */
    122          #endif
    123          
    124          
    125          /* Reentrancy related */
    126          #if _FS_REENTRANT
    127          #if _USE_LFN == 1
    128          #error Static LFN work area must not be used in re-entrant configuration.
    129          #endif
    130          #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
    131          #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
    132          #else
    133          #define	ENTER_FF(fs)
    134          #define LEAVE_FF(fs, res)	return res
    135          #endif
    136          
    137          #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
    138          
    139          
    140          /* File access control feature */
    141          #if _FS_LOCK
    142          #if _FS_READONLY
    143          #error _FS_LOCK must be 0 on read-only cfg.
    144          #endif
    145          typedef struct {
    146          	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
    147          	DWORD clu;				/* File ID 2, directory */
    148          	WORD idx;				/* File ID 3, directory index */
    149          	WORD ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
    150          } FILESEM;
    151          #endif
    152          
    153          
    154          
    155          /* DBCS code ranges and SBCS extend char conversion table */
    156          
    157          #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
    158          #define _DF1S	0x81	/* DBC 1st byte range 1 start */
    159          #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
    160          #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
    161          #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
    162          #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
    163          #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
    164          #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
    165          #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
    166          
    167          #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
    168          #define _DF1S	0x81
    169          #define _DF1E	0xFE
    170          #define _DS1S	0x40
    171          #define _DS1E	0x7E
    172          #define _DS2S	0x80
    173          #define _DS2E	0xFE
    174          
    175          #elif _CODE_PAGE == 949	/* Korean */
    176          #define _DF1S	0x81
    177          #define _DF1E	0xFE
    178          #define _DS1S	0x41
    179          #define _DS1E	0x5A
    180          #define _DS2S	0x61
    181          #define _DS2E	0x7A
    182          #define _DS3S	0x81
    183          #define _DS3E	0xFE
    184          
    185          #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
    186          #define _DF1S	0x81
    187          #define _DF1E	0xFE
    188          #define _DS1S	0x40
    189          #define _DS1E	0x7E
    190          #define _DS2S	0xA1
    191          #define _DS2E	0xFE
    192          
    193          #elif _CODE_PAGE == 437	/* U.S. (OEM) */
    194          #define _DF1S	0
    195          #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    196          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    197          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    198          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    199          
    200          #elif _CODE_PAGE == 720	/* Arabic (OEM) */
    201          #define _DF1S	0
    202          #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    203          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    204          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    205          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    206          
    207          #elif _CODE_PAGE == 737	/* Greek (OEM) */
    208          #define _DF1S	0
    209          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
    210          				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    211          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    212          				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    213          
    214          #elif _CODE_PAGE == 775	/* Baltic (OEM) */
    215          #define _DF1S	0
    216          #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    217          				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    218          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    219          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    220          
    221          #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
    222          #define _DF1S	0
    223          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    224          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    225          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    226          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    227          
    228          #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
    229          #define _DF1S	0
    230          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
    231          				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
    232          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    233          				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
    234          
    235          #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
    236          #define _DF1S	0
    237          #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
    238          				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
    239          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
    240          				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
    241          
    242          #elif _CODE_PAGE == 857	/* Turkish (OEM) */
    243          #define _DF1S	0
    244          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
    245          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    246          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    247          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    248          
    249          #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
    250          #define _DF1S	0
    251          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    252          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    253          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    254          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    255          
    256          #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
    257          #define _DF1S	0
    258          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    259          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    260          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    261          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    262          
    263          #elif _CODE_PAGE == 866	/* Russian (OEM) */
    264          #define _DF1S	0
    265          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    266          				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    267          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    268          				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    269          
    270          #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
    271          #define _DF1S	0
    272          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    273          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    274          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    275          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    276          
    277          #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
    278          #define _DF1S	0
    279          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
    280          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
    281          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    282          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
    283          
    284          #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
    285          #define _DF1S	0
    286          #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
    287          				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
    288          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    289          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
    290          
    291          #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
    292          #define _DF1S	0
    293          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
    294          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    295          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    296          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
    297          
    298          #elif _CODE_PAGE == 1253 /* Greek (Windows) */
    299          #define _DF1S	0
    300          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    301          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    302          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
    303          				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
    304          
    305          #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
    306          #define _DF1S	0
    307          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
    308          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    309          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    310          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
    311          
    312          #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
    313          #define _DF1S	0
    314          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    315          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    316          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    317          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    318          
    319          #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
    320          #define _DF1S	0
    321          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
    322          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    323          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    324          				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
    325          
    326          #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
    327          #define _DF1S	0
    328          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    329          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
    330          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    331          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
    332          
    333          #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
    334          #define _DF1S	0
    335          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
    336          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    337          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    338          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
    339          
    340          #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
    341          #if _USE_LFN
    342          #error Cannot use LFN feature without valid code page.
    343          #endif
    344          #define _DF1S	0
    345          
    346          #else
    347          #error Unknown code page
    348          
    349          #endif
    350          
    351          
    352          /* Character code support macros */
    353          #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
    354          #define IsLower(c)	(((c)>='a')&&((c)<='z'))
    355          #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
    356          
    357          #if _DF1S		/* Code page is DBCS */
    358          
    359          #ifdef _DF2S	/* Two 1st byte areas */
    360          #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
    361          #else			/* One 1st byte area */
    362          #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
    363          #endif
    364          
    365          #ifdef _DS3S	/* Three 2nd byte areas */
    366          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
    367          #else			/* Two 2nd byte areas */
    368          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
    369          #endif
    370          
    371          #else			/* Code page is SBCS */
    372          
    373          #define IsDBCS1(c)	0
    374          #define IsDBCS2(c)	0
    375          
    376          #endif /* _DF1S */
    377          
    378          
    379          /* Name status flags */
    380          #define NS			11		/* Index of name status byte in fn[] */
    381          #define NS_LOSS		0x01	/* Out of 8.3 format */
    382          #define NS_LFN		0x02	/* Force to create LFN entry */
    383          #define NS_LAST		0x04	/* Last segment */
    384          #define NS_BODY		0x08	/* Lower case flag (body) */
    385          #define NS_EXT		0x10	/* Lower case flag (ext) */
    386          #define NS_DOT		0x20	/* Dot entry */
    387          
    388          
    389          /* FAT sub-type boundaries */
    390          /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
    391          #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
    392          #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
    393          
    394          
    395          /* FatFs refers the members in the FAT structures as byte array instead of
    396          / structure member because the structure is not binary compatible between
    397          / different platforms */
    398          
    399          #define BS_jmpBoot			0	/* Jump instruction (3) */
    400          #define BS_OEMName			3	/* OEM name (8) */
    401          #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
    402          #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
    403          #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
    404          #define BPB_NumFATs			16	/* Number of FAT copies (1) */
    405          #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
    406          #define BPB_TotSec16		19	/* Volume size [sector] (2) */
    407          #define BPB_Media			21	/* Media descriptor (1) */
    408          #define BPB_FATSz16			22	/* FAT size [sector] (2) */
    409          #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
    410          #define BPB_NumHeads		26	/* Number of heads (2) */
    411          #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
    412          #define BPB_TotSec32		32	/* Volume size [sector] (4) */
    413          #define BS_DrvNum			36	/* Physical drive number (2) */
    414          #define BS_BootSig			38	/* Extended boot signature (1) */
    415          #define BS_VolID			39	/* Volume serial number (4) */
    416          #define BS_VolLab			43	/* Volume label (8) */
    417          #define BS_FilSysType		54	/* File system type (1) */
    418          #define BPB_FATSz32			36	/* FAT size [sector] (4) */
    419          #define BPB_ExtFlags		40	/* Extended flags (2) */
    420          #define BPB_FSVer			42	/* File system version (2) */
    421          #define BPB_RootClus		44	/* Root dir first cluster (4) */
    422          #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
    423          #define BPB_BkBootSec		50	/* Offset of backup boot sector (2) */
    424          #define BS_DrvNum32			64	/* Physical drive number (2) */
    425          #define BS_BootSig32		66	/* Extended boot signature (1) */
    426          #define BS_VolID32			67	/* Volume serial number (4) */
    427          #define BS_VolLab32			71	/* Volume label (8) */
    428          #define BS_FilSysType32		82	/* File system type (1) */
    429          #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
    430          #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
    431          #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
    432          #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
    433          #define MBR_Table			446	/* MBR: Partition table offset (2) */
    434          #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
    435          #define BS_55AA				510	/* Boot sector signature (2) */
    436          
    437          #define	DIR_Name			0	/* Short file name (11) */
    438          #define	DIR_Attr			11	/* Attribute (1) */
    439          #define	DIR_NTres			12	/* NT flag (1) */
    440          #define DIR_CrtTimeTenth	13	/* Created time sub-second (1) */
    441          #define	DIR_CrtTime			14	/* Created time (2) */
    442          #define	DIR_CrtDate			16	/* Created date (2) */
    443          #define DIR_LstAccDate		18	/* Last accessed date (2) */
    444          #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
    445          #define	DIR_WrtTime			22	/* Modified time (2) */
    446          #define	DIR_WrtDate			24	/* Modified date (2) */
    447          #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
    448          #define	DIR_FileSize		28	/* File size (4) */
    449          #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
    450          #define	LDIR_Attr			11	/* LFN attribute (1) */
    451          #define	LDIR_Type			12	/* LFN type (1) */
    452          #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
    453          #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
    454          #define	SZ_DIR				32		/* Size of a directory entry */
    455          #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
    456          #define	DDE					0xE5	/* Deleted directory entry mark in DIR_Name[0] */
    457          #define	NDDE				0x05	/* Replacement of the character collides with DDE */
    458          
    459          
    460          /*------------------------------------------------------------*/
    461          /* Module private work area                                   */
    462          /*------------------------------------------------------------*/
    463          /* Note that uninitialized variables with static duration are
    464          /  zeroed/nulled at start-up. If not, the compiler or start-up
    465          /  routine is out of ANSI-C standard.
    466          */
    467          
    468          #if _VOLUMES
    469          static

   \                                 In section .bss, align 4
    470          FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
   \                     FatFs:
   \   00000000                      DS8 4
    471          #else
    472          #error Number of volumes must not be 0.
    473          #endif
    474          
    475          static

   \                                 In section .bss, align 2
    476          WORD Fsid;				/* File system mount ID */
   \                     Fsid:
   \   00000000                      DS8 2
    477          
    478          #if _FS_RPATH
    479          static

   \                                 In section .bss, align 1
    480          BYTE CurrVol;			/* Current drive */
   \                     CurrVol:
   \   00000000                      DS8 1
    481          #endif
    482          
    483          #if _FS_LOCK
    484          static

   \                                 In section .bss, align 4
    485          FILESEM	Files[_FS_LOCK];	/* File lock semaphores */
   \                     Files:
   \   00000000                      DS8 96
    486          #endif
    487          
    488          #if _USE_LFN == 0			/* No LFN feature */
    489          #define	DEF_NAMEBUF			BYTE sfn[12]
    490          #define INIT_BUF(dobj)		(dobj).fn = sfn
    491          #define	FREE_BUF()
    492          
    493          #elif _USE_LFN == 1			/* LFN feature with static working buffer */
    494          static WCHAR LfnBuf[_MAX_LFN+1];
    495          #define	DEF_NAMEBUF			BYTE sfn[12]
    496          #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
    497          #define	FREE_BUF()
    498          
    499          #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
    500          #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
    501          #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
    502          #define	FREE_BUF()
    503          
    504          #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
    505          #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
    506          #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
    507          							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
    508          							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
    509          #define	FREE_BUF()			ff_memfree(lfn)
    510          
    511          #else
    512          #error Wrong LFN configuration.
    513          #endif
    514          
    515          
    516          #ifdef _EXCVT
    517          static

   \                                 In section .rodata, align 4
    518          const BYTE ExCvt[] = _EXCVT;	/* Upper conversion table for extended chars */
   \                     ExCvt:
   \   00000000   0x80 0x81          DC8 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140
   \              0x82 0x83    
   \              0x84 0x85    
   \              0x86 0x87    
   \              0x88 0x89    
   \              0x8A 0x8B    
   \              0x8C         
   \   0000000D   0x8D 0x8E          DC8 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153
   \              0x8F 0x90    
   \              0x91 0x92    
   \              0x93 0x94    
   \              0x95 0x96    
   \              0x97 0x98    
   \              0x99         
   \   0000001A   0x8A 0x9B          DC8 138, 155, 140, 141, 142, 143, 160, 161, 162, 163, 164, 165, 166
   \              0x8C 0x8D    
   \              0x8E 0x8F    
   \              0xA0 0xA1    
   \              0xA2 0xA3    
   \              0xA4 0xA5    
   \              0xA6         
   \   00000027   0xA7 0xA8          DC8 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 163
   \              0xA9 0xAA    
   \              0xAB 0xAC    
   \              0xAD 0xAE    
   \              0xAF 0xB0    
   \              0xB1 0xB2    
   \              0xA3         
   \   00000034   0xB4 0xB5          DC8 180, 181, 182, 183, 184, 165, 170, 187, 188, 189, 188, 175, 192
   \              0xB6 0xB7    
   \              0xB8 0xA5    
   \              0xAA 0xBB    
   \              0xBC 0xBD    
   \              0xBC 0xAF    
   \              0xC0         
   \   00000041   0xC1 0xC2          DC8 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205
   \              0xC3 0xC4    
   \              0xC5 0xC6    
   \              0xC7 0xC8    
   \              0xC9 0xCA    
   \              0xCB 0xCC    
   \              0xCD         
   \   0000004E   0xCE 0xCF          DC8 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218
   \              0xD0 0xD1    
   \              0xD2 0xD3    
   \              0xD4 0xD5    
   \              0xD6 0xD7    
   \              0xD8 0xD9    
   \              0xDA         
   \   0000005B   0xDB 0xDC          DC8 219, 220, 221, 222, 223, 192, 193, 194, 195, 196, 197, 198, 199
   \              0xDD 0xDE    
   \              0xDF 0xC0    
   \              0xC1 0xC2    
   \              0xC3 0xC4    
   \              0xC5 0xC6    
   \              0xC7         
   \   00000068   0xC8 0xC9          DC8 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212
   \              0xCA 0xCB    
   \              0xCC 0xCD    
   \              0xCE 0xCF    
   \              0xD0 0xD1    
   \              0xD2 0xD3    
   \              0xD4         
   \   00000075   0xD5 0xD6          DC8 213, 214, 247, 216, 217, 218, 219, 220, 221, 222, 255
   \              0xF7 0xD8    
   \              0xD9 0xDA    
   \              0xDB 0xDC    
   \              0xDD 0xDE    
   \              0xFF         
    519          #endif
    520          
    521          
    522          
    523          
    524          
    525          
    526          /*--------------------------------------------------------------------------
    527          
    528             Module Private Functions
    529          
    530          ---------------------------------------------------------------------------*/
    531          
    532          
    533          /*-----------------------------------------------------------------------*/
    534          /* String functions                                                      */
    535          /*-----------------------------------------------------------------------*/
    536          
    537          /* Copy memory to memory */

   \                                 In section .text, align 2, keep-with-next
    538          static
    539          void mem_cpy (void* dst, const void* src, UINT cnt) {
    540          	BYTE *d = (BYTE*)dst;
    541          	const BYTE *s = (const BYTE*)src;
   \                     mem_cpy:
   \   00000000   0xE003             B.N      ??mem_cpy_0
    542          
    543          #if _WORD_ACCESS == 1
    544          	while (cnt >= sizeof (int)) {
    545          		*(int*)d = *(int*)s;
    546          		d += sizeof (int); s += sizeof (int);
    547          		cnt -= sizeof (int);
    548          	}
    549          #endif
    550          	while (cnt--)
    551          		*d++ = *s++;
   \                     ??mem_cpy_1:
   \   00000002   0x780B             LDRB     R3,[R1, #+0]
   \   00000004   0x7003             STRB     R3,[R0, #+0]
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   \                     ??mem_cpy_0:
   \   0000000A   0x0013             MOVS     R3,R2
   \   0000000C   0x1E5A             SUBS     R2,R3,#+1
   \   0000000E   0x2B00             CMP      R3,#+0
   \   00000010   0xD1F7             BNE.N    ??mem_cpy_1
    552          }
   \   00000012   0x4770             BX       LR               ;; return
    553          
    554          /* Fill memory */

   \                                 In section .text, align 2, keep-with-next
    555          static
    556          void mem_set (void* dst, int val, UINT cnt) {
    557          	BYTE *d = (BYTE*)dst;
   \                     mem_set:
   \   00000000   0xE001             B.N      ??mem_set_0
    558          
    559          	while (cnt--)
    560          		*d++ = (BYTE)val;
   \                     ??mem_set_1:
   \   00000002   0x7001             STRB     R1,[R0, #+0]
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \                     ??mem_set_0:
   \   00000006   0x0013             MOVS     R3,R2
   \   00000008   0x1E5A             SUBS     R2,R3,#+1
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0xD1F9             BNE.N    ??mem_set_1
    561          }
   \   0000000E   0x4770             BX       LR               ;; return
    562          
    563          /* Compare memory to memory */

   \                                 In section .text, align 2, keep-with-next
    564          static
    565          int mem_cmp (const void* dst, const void* src, UINT cnt) {
   \                     mem_cmp:
   \   00000000   0xB410             PUSH     {R4}
    566          	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    567          	int r = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    568          
    569          	while (cnt-- && (r = *d++ - *s++) == 0) ;
   \                     ??mem_cmp_0:
   \   00000004   0x0014             MOVS     R4,R2
   \   00000006   0x1E62             SUBS     R2,R4,#+1
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD006             BEQ.N    ??mem_cmp_1
   \   0000000C   0x7803             LDRB     R3,[R0, #+0]
   \   0000000E   0x780C             LDRB     R4,[R1, #+0]
   \   00000010   0x1B1B             SUBS     R3,R3,R4
   \   00000012   0x1C49             ADDS     R1,R1,#+1
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x2B00             CMP      R3,#+0
   \   00000018   0xD0F4             BEQ.N    ??mem_cmp_0
    570          	return r;
   \                     ??mem_cmp_1:
   \   0000001A   0x0018             MOVS     R0,R3
   \   0000001C   0xBC10             POP      {R4}
   \   0000001E   0x4770             BX       LR               ;; return
    571          }
    572          
    573          /* Check if chr is contained in the string */

   \                                 In section .text, align 2, keep-with-next
    574          static
    575          int chk_chr (const char* str, int chr) {
   \                     chk_chr:
   \   00000000   0xE000             B.N      ??chk_chr_0
    576          	while (*str && *str != chr) str++;
   \                     ??chk_chr_1:
   \   00000002   0x1C40             ADDS     R0,R0,#+1
   \                     ??chk_chr_0:
   \   00000004   0x7802             LDRB     R2,[R0, #+0]
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD002             BEQ.N    ??chk_chr_2
   \   0000000A   0x7802             LDRB     R2,[R0, #+0]
   \   0000000C   0x428A             CMP      R2,R1
   \   0000000E   0xD1F8             BNE.N    ??chk_chr_1
    577          	return *str;
   \                     ??chk_chr_2:
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x4770             BX       LR               ;; return
    578          }
    579          
    580          
    581          
    582          /*-----------------------------------------------------------------------*/
    583          /* Request/Release grant to access the volume                            */
    584          /*-----------------------------------------------------------------------*/
    585          #if _FS_REENTRANT
    586          
    587          static
    588          int lock_fs (
    589          	FATFS *fs		/* File system object */
    590          )
    591          {
    592          	return ff_req_grant(fs->sobj);
    593          }
    594          
    595          
    596          static
    597          void unlock_fs (
    598          	FATFS *fs,		/* File system object */
    599          	FRESULT res		/* Result code to be returned */
    600          )
    601          {
    602          	if (fs &&
    603          		res != FR_NOT_ENABLED &&
    604          		res != FR_INVALID_DRIVE &&
    605          		res != FR_INVALID_OBJECT &&
    606          		res != FR_TIMEOUT) {
    607          		ff_rel_grant(fs->sobj);
    608          	}
    609          }
    610          #endif
    611          
    612          
    613          
    614          /*-----------------------------------------------------------------------*/
    615          /* File lock control functions                                           */
    616          /*-----------------------------------------------------------------------*/
    617          #if _FS_LOCK
    618          

   \                                 In section .text, align 2, keep-with-next
    619          static
    620          FRESULT chk_lock (	/* Check if the file can be accessed */
    621          	DIR* dj,		/* Directory object pointing the file to be checked */
    622          	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
    623          )
    624          {
   \                     chk_lock:
   \   00000000   0xB430             PUSH     {R4,R5}
    625          	UINT i, be;
    626          
    627          	/* Search file semaphore table */
    628          	for (i = be = 0; i < _FS_LOCK; i++) {
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x001A             MOVS     R2,R3
   \   00000006   0xE001             B.N      ??chk_lock_0
    629          		if (Files[i].fs) {	/* Existing entry */
    630          			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
    631          				Files[i].clu == dj->sclust &&
    632          				Files[i].idx == dj->index) break;
    633          		} else {			/* Blank entry */
    634          			be++;
   \                     ??chk_lock_1:
   \   00000008   0x1C52             ADDS     R2,R2,#+1
    635          		}
   \                     ??chk_lock_2:
   \   0000000A   0x1C5B             ADDS     R3,R3,#+1
   \                     ??chk_lock_0:
   \   0000000C   0x2B08             CMP      R3,#+8
   \   0000000E   0xD222             BCS.N    ??chk_lock_3
   \   00000010   0x240C             MOVS     R4,#+12
   \   00000012   0x.... 0x....      LDR.W    R5,??DataTable7
   \   00000016   0xFB04 0x5403      MLA      R4,R4,R3,R5
   \   0000001A   0x6824             LDR      R4,[R4, #+0]
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD0F3             BEQ.N    ??chk_lock_1
   \   00000020   0x240C             MOVS     R4,#+12
   \   00000022   0x.... 0x....      LDR.W    R5,??DataTable7
   \   00000026   0xFB04 0x5403      MLA      R4,R4,R3,R5
   \   0000002A   0x6824             LDR      R4,[R4, #+0]
   \   0000002C   0x6805             LDR      R5,[R0, #+0]
   \   0000002E   0x42AC             CMP      R4,R5
   \   00000030   0xD1EB             BNE.N    ??chk_lock_2
   \   00000032   0x240C             MOVS     R4,#+12
   \   00000034   0x.... 0x....      LDR.W    R5,??DataTable7
   \   00000038   0xFB04 0x5403      MLA      R4,R4,R3,R5
   \   0000003C   0x6864             LDR      R4,[R4, #+4]
   \   0000003E   0x6885             LDR      R5,[R0, #+8]
   \   00000040   0x42AC             CMP      R4,R5
   \   00000042   0xD1E2             BNE.N    ??chk_lock_2
   \   00000044   0x240C             MOVS     R4,#+12
   \   00000046   0x.... 0x....      LDR.W    R5,??DataTable7
   \   0000004A   0xFB04 0x5403      MLA      R4,R4,R3,R5
   \   0000004E   0x8924             LDRH     R4,[R4, #+8]
   \   00000050   0x88C5             LDRH     R5,[R0, #+6]
   \   00000052   0x42AC             CMP      R4,R5
   \   00000054   0xD1D9             BNE.N    ??chk_lock_2
    636          	}
    637          	if (i == _FS_LOCK)	/* The file is not opened */
   \                     ??chk_lock_3:
   \   00000056   0x2B08             CMP      R3,#+8
   \   00000058   0xD108             BNE.N    ??chk_lock_4
    638          		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
   \   0000005A   0x2A00             CMP      R2,#+0
   \   0000005C   0xD101             BNE.N    ??chk_lock_5
   \   0000005E   0x2902             CMP      R1,#+2
   \   00000060   0xD101             BNE.N    ??chk_lock_6
   \                     ??chk_lock_5:
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xE000             B.N      ??chk_lock_7
   \                     ??chk_lock_6:
   \   00000066   0x2012             MOVS     R0,#+18
   \                     ??chk_lock_7:
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0xE00E             B.N      ??chk_lock_8
    639          
    640          	/* The file has been opened. Reject any open against writing file and all write mode open */
    641          	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
   \                     ??chk_lock_4:
   \   0000006C   0x2900             CMP      R1,#+0
   \   0000006E   0xD108             BNE.N    ??chk_lock_9
   \   00000070   0x200C             MOVS     R0,#+12
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable7
   \   00000076   0xFB00 0x1003      MLA      R0,R0,R3,R1
   \   0000007A   0x8940             LDRH     R0,[R0, #+10]
   \   0000007C   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000080   0xD101             BNE.N    ??chk_lock_10
   \                     ??chk_lock_9:
   \   00000082   0x2010             MOVS     R0,#+16
   \   00000084   0xE000             B.N      ??chk_lock_11
   \                     ??chk_lock_10:
   \   00000086   0x2000             MOVS     R0,#+0
   \                     ??chk_lock_11:
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??chk_lock_8:
   \   0000008A   0xBC30             POP      {R4,R5}
   \   0000008C   0x4770             BX       LR               ;; return
    642          }
    643          
    644          

   \                                 In section .text, align 2, keep-with-next
    645          static
    646          int enq_lock (void)	/* Check if an entry is available for a new file */
    647          {
    648          	UINT i;
    649          
    650          	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
   \                     enq_lock:
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xE000             B.N      ??enq_lock_0
   \                     ??enq_lock_1:
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \                     ??enq_lock_0:
   \   00000006   0x2808             CMP      R0,#+8
   \   00000008   0xD207             BCS.N    ??enq_lock_2
   \   0000000A   0x210C             MOVS     R1,#+12
   \   0000000C   0x.... 0x....      LDR.W    R2,??DataTable7
   \   00000010   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD1F4             BNE.N    ??enq_lock_1
    651          	return (i == _FS_LOCK) ? 0 : 1;
   \                     ??enq_lock_2:
   \   0000001A   0x2808             CMP      R0,#+8
   \   0000001C   0xD101             BNE.N    ??enq_lock_3
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE000             B.N      ??enq_lock_4
   \                     ??enq_lock_3:
   \   00000022   0x2001             MOVS     R0,#+1
   \                     ??enq_lock_4:
   \   00000024   0x4770             BX       LR               ;; return
    652          }
    653          
    654          

   \                                 In section .text, align 2, keep-with-next
    655          static
    656          UINT inc_lock (	/* Increment file open counter and returns its index (0:int error) */
    657          	DIR* dj,	/* Directory object pointing the file to register or increment */
    658          	int acc		/* Desired access mode (0:Read, !0:Write) */
    659          )
    660          {
   \                     inc_lock:
   \   00000000   0xB410             PUSH     {R4}
    661          	UINT i;
    662          
    663          
    664          	for (i = 0; i < _FS_LOCK; i++) {	/* Find the file */
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0xE000             B.N      ??inc_lock_0
   \                     ??inc_lock_1:
   \   00000006   0x1C52             ADDS     R2,R2,#+1
   \                     ??inc_lock_0:
   \   00000008   0x2A08             CMP      R2,#+8
   \   0000000A   0xD21A             BCS.N    ??inc_lock_2
    665          		if (Files[i].fs == dj->fs &&
    666          			Files[i].clu == dj->sclust &&
    667          			Files[i].idx == dj->index) break;
   \   0000000C   0x230C             MOVS     R3,#+12
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable7
   \   00000012   0xFB03 0x4302      MLA      R3,R3,R2,R4
   \   00000016   0x681B             LDR      R3,[R3, #+0]
   \   00000018   0x6804             LDR      R4,[R0, #+0]
   \   0000001A   0x42A3             CMP      R3,R4
   \   0000001C   0xD1F3             BNE.N    ??inc_lock_1
   \   0000001E   0x230C             MOVS     R3,#+12
   \   00000020   0x.... 0x....      LDR.W    R4,??DataTable7
   \   00000024   0xFB03 0x4302      MLA      R3,R3,R2,R4
   \   00000028   0x685B             LDR      R3,[R3, #+4]
   \   0000002A   0x6884             LDR      R4,[R0, #+8]
   \   0000002C   0x42A3             CMP      R3,R4
   \   0000002E   0xD1EA             BNE.N    ??inc_lock_1
   \   00000030   0x230C             MOVS     R3,#+12
   \   00000032   0x.... 0x....      LDR.W    R4,??DataTable7
   \   00000036   0xFB03 0x4302      MLA      R3,R3,R2,R4
   \   0000003A   0x891B             LDRH     R3,[R3, #+8]
   \   0000003C   0x88C4             LDRH     R4,[R0, #+6]
   \   0000003E   0x42A3             CMP      R3,R4
   \   00000040   0xD1E1             BNE.N    ??inc_lock_1
    668          	}
    669          
    670          	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
   \                     ??inc_lock_2:
   \   00000042   0x2A08             CMP      R2,#+8
   \   00000044   0xD12C             BNE.N    ??inc_lock_3
    671          		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
   \   00000046   0x2200             MOVS     R2,#+0
   \   00000048   0xE000             B.N      ??inc_lock_4
   \                     ??inc_lock_5:
   \   0000004A   0x1C52             ADDS     R2,R2,#+1
   \                     ??inc_lock_4:
   \   0000004C   0x2A08             CMP      R2,#+8
   \   0000004E   0xD207             BCS.N    ??inc_lock_6
   \   00000050   0x230C             MOVS     R3,#+12
   \   00000052   0x.... 0x....      LDR.W    R4,??DataTable7
   \   00000056   0xFB03 0x4302      MLA      R3,R3,R2,R4
   \   0000005A   0x681B             LDR      R3,[R3, #+0]
   \   0000005C   0x2B00             CMP      R3,#+0
   \   0000005E   0xD1F4             BNE.N    ??inc_lock_5
    672          		if (i == _FS_LOCK) return 0;	/* No space to register (int err) */
   \                     ??inc_lock_6:
   \   00000060   0x2A08             CMP      R2,#+8
   \   00000062   0xD101             BNE.N    ??inc_lock_7
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xE03A             B.N      ??inc_lock_8
    673          		Files[i].fs = dj->fs;
   \                     ??inc_lock_7:
   \   00000068   0x230C             MOVS     R3,#+12
   \   0000006A   0x.... 0x....      LDR.W    R4,??DataTable7
   \   0000006E   0xFB03 0x4302      MLA      R3,R3,R2,R4
   \   00000072   0x6804             LDR      R4,[R0, #+0]
   \   00000074   0x601C             STR      R4,[R3, #+0]
    674          		Files[i].clu = dj->sclust;
   \   00000076   0x230C             MOVS     R3,#+12
   \   00000078   0x.... 0x....      LDR.W    R4,??DataTable7
   \   0000007C   0xFB03 0x4302      MLA      R3,R3,R2,R4
   \   00000080   0x6884             LDR      R4,[R0, #+8]
   \   00000082   0x605C             STR      R4,[R3, #+4]
    675          		Files[i].idx = dj->index;
   \   00000084   0x230C             MOVS     R3,#+12
   \   00000086   0x.... 0x....      LDR.W    R4,??DataTable7
   \   0000008A   0xFB03 0x4302      MLA      R3,R3,R2,R4
   \   0000008E   0x88C0             LDRH     R0,[R0, #+6]
   \   00000090   0x8118             STRH     R0,[R3, #+8]
    676          		Files[i].ctr = 0;
   \   00000092   0x200C             MOVS     R0,#+12
   \   00000094   0x.... 0x....      LDR.W    R3,??DataTable7
   \   00000098   0xFB00 0x3002      MLA      R0,R0,R2,R3
   \   0000009C   0x2300             MOVS     R3,#+0
   \   0000009E   0x8143             STRH     R3,[R0, #+10]
    677          	}
    678          
    679          	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
   \                     ??inc_lock_3:
   \   000000A0   0x2900             CMP      R1,#+0
   \   000000A2   0xD009             BEQ.N    ??inc_lock_9
   \   000000A4   0x200C             MOVS     R0,#+12
   \   000000A6   0x.... 0x....      LDR.W    R3,??DataTable7
   \   000000AA   0xFB00 0x3002      MLA      R0,R0,R2,R3
   \   000000AE   0x8940             LDRH     R0,[R0, #+10]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD001             BEQ.N    ??inc_lock_9
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0xE012             B.N      ??inc_lock_8
    680          
    681          	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
   \                     ??inc_lock_9:
   \   000000B8   0x2900             CMP      R1,#+0
   \   000000BA   0xD002             BEQ.N    ??inc_lock_10
   \   000000BC   0xF44F 0x7080      MOV      R0,#+256
   \   000000C0   0xE006             B.N      ??inc_lock_11
   \                     ??inc_lock_10:
   \   000000C2   0x200C             MOVS     R0,#+12
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable7
   \   000000C8   0xFB00 0x1002      MLA      R0,R0,R2,R1
   \   000000CC   0x8940             LDRH     R0,[R0, #+10]
   \   000000CE   0x1C40             ADDS     R0,R0,#+1
   \                     ??inc_lock_11:
   \   000000D0   0x210C             MOVS     R1,#+12
   \   000000D2   0x.... 0x....      LDR.W    R3,??DataTable7
   \   000000D6   0xFB01 0x3102      MLA      R1,R1,R2,R3
   \   000000DA   0x8148             STRH     R0,[R1, #+10]
    682          
    683          	return i + 1;
   \   000000DC   0x1C50             ADDS     R0,R2,#+1
   \                     ??inc_lock_8:
   \   000000DE   0xBC10             POP      {R4}
   \   000000E0   0x4770             BX       LR               ;; return
    684          }
    685          
    686          

   \                                 In section .text, align 2, keep-with-next
    687          static
    688          FRESULT dec_lock (	/* Decrement file open counter */
    689          	UINT i			/* Semaphore index */
    690          )
    691          {
    692          	WORD n;
    693          	FRESULT res;
    694          
    695          
    696          	if (--i < _FS_LOCK) {
   \                     dec_lock:
   \   00000000   0x1E40             SUBS     R0,R0,#+1
   \   00000002   0x2808             CMP      R0,#+8
   \   00000004   0xD220             BCS.N    ??dec_lock_0
    697          		n = Files[i].ctr;
   \   00000006   0x210C             MOVS     R1,#+12
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable7
   \   0000000C   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   00000010   0x8949             LDRH     R1,[R1, #+10]
    698          		if (n == 0x100) n = 0;
   \   00000012   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000014   0xF5B1 0x7F80      CMP      R1,#+256
   \   00000018   0xD100             BNE.N    ??dec_lock_1
   \   0000001A   0x2100             MOVS     R1,#+0
    699          		if (n) n--;
   \                     ??dec_lock_1:
   \   0000001C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD000             BEQ.N    ??dec_lock_2
   \   00000022   0x1E49             SUBS     R1,R1,#+1
    700          		Files[i].ctr = n;
   \                     ??dec_lock_2:
   \   00000024   0x220C             MOVS     R2,#+12
   \   00000026   0x.... 0x....      LDR.W    R3,??DataTable7
   \   0000002A   0xFB02 0x3200      MLA      R2,R2,R0,R3
   \   0000002E   0x8151             STRH     R1,[R2, #+10]
    701          		if (!n) Files[i].fs = 0;
   \   00000030   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD106             BNE.N    ??dec_lock_3
   \   00000036   0x210C             MOVS     R1,#+12
   \   00000038   0x.... 0x....      LDR.W    R2,??DataTable7
   \   0000003C   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x6001             STR      R1,[R0, #+0]
    702          		res = FR_OK;
   \                     ??dec_lock_3:
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE000             B.N      ??dec_lock_4
    703          	} else {
    704          		res = FR_INT_ERR;
   \                     ??dec_lock_0:
   \   00000048   0x2002             MOVS     R0,#+2
    705          	}
    706          	return res;
   \                     ??dec_lock_4:
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0x4770             BX       LR               ;; return
    707          }
    708          
    709          

   \                                 In section .text, align 2, keep-with-next
    710          static
    711          void clear_lock (	/* Clear lock entries of the volume */
    712          	FATFS *fs
    713          )
    714          {
    715          	UINT i;
    716          
    717          	for (i = 0; i < _FS_LOCK; i++) {
   \                     clear_lock:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xE00F             B.N      ??clear_lock_0
    718          		if (Files[i].fs == fs) Files[i].fs = 0;
   \                     ??clear_lock_1:
   \   00000004   0x220C             MOVS     R2,#+12
   \   00000006   0x.... 0x....      LDR.W    R3,??DataTable7
   \   0000000A   0xFB02 0x3201      MLA      R2,R2,R1,R3
   \   0000000E   0x6812             LDR      R2,[R2, #+0]
   \   00000010   0x4282             CMP      R2,R0
   \   00000012   0xD106             BNE.N    ??clear_lock_2
   \   00000014   0x220C             MOVS     R2,#+12
   \   00000016   0x.... 0x....      LDR.W    R3,??DataTable7
   \   0000001A   0xFB02 0x3201      MLA      R2,R2,R1,R3
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x6013             STR      R3,[R2, #+0]
    719          	}
   \                     ??clear_lock_2:
   \   00000022   0x1C49             ADDS     R1,R1,#+1
   \                     ??clear_lock_0:
   \   00000024   0x2908             CMP      R1,#+8
   \   00000026   0xD3ED             BCC.N    ??clear_lock_1
    720          }
   \   00000028   0x4770             BX       LR               ;; return
    721          #endif
    722          
    723          
    724          
    725          /*-----------------------------------------------------------------------*/
    726          /* Move/Flush disk access window                                         */
    727          /*-----------------------------------------------------------------------*/
    728          
    729          
    730          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    731          static
    732          FRESULT sync_window (
    733          	FATFS *fs		/* File system object */
    734          )
    735          {
   \                     sync_window:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    736          	DWORD wsect;
    737          	UINT nf;
    738          
    739          	
    740          	if (fs->wflag) {	/* Write back the sector if it is dirty */
   \   00000004   0x7920             LDRB     R0,[R4, #+4]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD023             BEQ.N    ??sync_window_0
    741          		wsect = fs->winsect;	/* Current sector number */
   \   0000000A   0x6B65             LDR      R5,[R4, #+52]
    742          		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
   \   0000000C   0x2301             MOVS     R3,#+1
   \   0000000E   0x002A             MOVS     R2,R5
   \   00000010   0xF114 0x0138      ADDS     R1,R4,#+56
   \   00000014   0x7860             LDRB     R0,[R4, #+1]
   \   00000016   0x.... 0x....      BL       disk_write
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??sync_window_1
    743          			return FR_DISK_ERR;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE018             B.N      ??sync_window_2
    744          		fs->wflag = 0;
   \                     ??sync_window_1:
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x7120             STRB     R0,[R4, #+4]
    745          		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
   \   00000026   0x6AA0             LDR      R0,[R4, #+40]
   \   00000028   0x4285             CMP      R5,R0
   \   0000002A   0xD312             BCC.N    ??sync_window_0
   \   0000002C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000002E   0x6A21             LDR      R1,[R4, #+32]
   \   00000030   0x1808             ADDS     R0,R1,R0
   \   00000032   0x4285             CMP      R5,R0
   \   00000034   0xD20D             BCS.N    ??sync_window_0
    746          			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
   \   00000036   0x78E6             LDRB     R6,[R4, #+3]
   \   00000038   0xE009             B.N      ??sync_window_3
    747          				wsect += fs->fsize;
   \                     ??sync_window_4:
   \   0000003A   0x6A20             LDR      R0,[R4, #+32]
   \   0000003C   0x1945             ADDS     R5,R0,R5
    748          				disk_write(fs->drv, fs->win, wsect, 1);
   \   0000003E   0x2301             MOVS     R3,#+1
   \   00000040   0x002A             MOVS     R2,R5
   \   00000042   0xF114 0x0138      ADDS     R1,R4,#+56
   \   00000046   0x7860             LDRB     R0,[R4, #+1]
   \   00000048   0x.... 0x....      BL       disk_write
    749          			}
   \   0000004C   0x1E76             SUBS     R6,R6,#+1
   \                     ??sync_window_3:
   \   0000004E   0x2E02             CMP      R6,#+2
   \   00000050   0xD2F3             BCS.N    ??sync_window_4
    750          		}
    751          	}
    752          	return FR_OK;
   \                     ??sync_window_0:
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??sync_window_2:
   \   00000054   0xBD70             POP      {R4-R6,PC}       ;; return
    753          }
    754          #endif
    755          
    756          

   \                                 In section .text, align 2, keep-with-next
    757          static
    758          FRESULT move_window (
    759          	FATFS *fs,		/* File system object */
    760          	DWORD sector	/* Sector number to make appearance in the fs->win[] */
    761          )
    762          {
   \                     move_window:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    763          	if (sector != fs->winsect) {	/* Changed current window */
   \   00000006   0x6B60             LDR      R0,[R4, #+52]
   \   00000008   0x4285             CMP      R5,R0
   \   0000000A   0xD012             BEQ.N    ??move_window_0
    764          #if !_FS_READONLY
    765          		if (sync_window(fs) != FR_OK)
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       sync_window
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD001             BEQ.N    ??move_window_1
    766          			return FR_DISK_ERR;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE00C             B.N      ??move_window_2
    767          #endif
    768          		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
   \                     ??move_window_1:
   \   0000001A   0x2301             MOVS     R3,#+1
   \   0000001C   0x002A             MOVS     R2,R5
   \   0000001E   0xF114 0x0138      ADDS     R1,R4,#+56
   \   00000022   0x7860             LDRB     R0,[R4, #+1]
   \   00000024   0x.... 0x....      BL       disk_read
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD001             BEQ.N    ??move_window_3
    769          			return FR_DISK_ERR;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE001             B.N      ??move_window_2
    770          		fs->winsect = sector;
   \                     ??move_window_3:
   \   00000030   0x6365             STR      R5,[R4, #+52]
    771          	}
    772          
    773          	return FR_OK;
   \                     ??move_window_0:
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??move_window_2:
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    774          }
    775          
    776          
    777          
    778          
    779          /*-----------------------------------------------------------------------*/
    780          /* Synchronize file system and strage device                             */
    781          /*-----------------------------------------------------------------------*/
    782          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    783          static
    784          FRESULT sync_fs (	/* FR_OK: successful, FR_DISK_ERR: failed */
    785          	FATFS *fs		/* File system object */
    786          )
    787          {
   \                     sync_fs:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    788          	FRESULT res;
    789          
    790          
    791          	res = sync_window(fs);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       sync_window
   \   0000000A   0x0005             MOVS     R5,R0
    792          	if (res == FR_OK) {
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD15D             BNE.N    ??sync_fs_0
    793          		/* Update FSInfo sector if needed */
    794          		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0x2803             CMP      R0,#+3
   \   00000016   0xD152             BNE.N    ??sync_fs_1
   \   00000018   0x7960             LDRB     R0,[R4, #+5]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD04F             BEQ.N    ??sync_fs_1
    795          			fs->winsect = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6360             STR      R0,[R4, #+52]
    796          			/* Create FSInfo structure */
    797          			mem_set(fs->win, 0, 512);
   \   00000022   0xF44F 0x7200      MOV      R2,#+512
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xF114 0x0038      ADDS     R0,R4,#+56
   \   0000002C   0x.... 0x....      BL       mem_set
    798          			ST_WORD(fs->win+BS_55AA, 0xAA55);
   \   00000030   0x2055             MOVS     R0,#+85
   \   00000032   0xF884 0x0236      STRB     R0,[R4, #+566]
   \   00000036   0x20AA             MOVS     R0,#+170
   \   00000038   0xF884 0x0237      STRB     R0,[R4, #+567]
    799          			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
   \   0000003C   0x2052             MOVS     R0,#+82
   \   0000003E   0xF884 0x0038      STRB     R0,[R4, #+56]
   \   00000042   0x2052             MOVS     R0,#+82
   \   00000044   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000048   0x2061             MOVS     R0,#+97
   \   0000004A   0xF884 0x003A      STRB     R0,[R4, #+58]
   \   0000004E   0x2041             MOVS     R0,#+65
   \   00000050   0xF884 0x003B      STRB     R0,[R4, #+59]
    800          			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
   \   00000054   0x2072             MOVS     R0,#+114
   \   00000056   0xF884 0x021C      STRB     R0,[R4, #+540]
   \   0000005A   0x2072             MOVS     R0,#+114
   \   0000005C   0xF884 0x021D      STRB     R0,[R4, #+541]
   \   00000060   0x2041             MOVS     R0,#+65
   \   00000062   0xF884 0x021E      STRB     R0,[R4, #+542]
   \   00000066   0x2061             MOVS     R0,#+97
   \   00000068   0xF884 0x021F      STRB     R0,[R4, #+543]
    801          			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
   \   0000006C   0x6920             LDR      R0,[R4, #+16]
   \   0000006E   0xF884 0x0220      STRB     R0,[R4, #+544]
   \   00000072   0x6920             LDR      R0,[R4, #+16]
   \   00000074   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000076   0x0A00             LSRS     R0,R0,#+8
   \   00000078   0xF884 0x0221      STRB     R0,[R4, #+545]
   \   0000007C   0x6920             LDR      R0,[R4, #+16]
   \   0000007E   0x0C00             LSRS     R0,R0,#+16
   \   00000080   0xF884 0x0222      STRB     R0,[R4, #+546]
   \   00000084   0x6920             LDR      R0,[R4, #+16]
   \   00000086   0x0E00             LSRS     R0,R0,#+24
   \   00000088   0xF884 0x0223      STRB     R0,[R4, #+547]
    802          			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
   \   0000008C   0x68E0             LDR      R0,[R4, #+12]
   \   0000008E   0xF884 0x0224      STRB     R0,[R4, #+548]
   \   00000092   0x68E0             LDR      R0,[R4, #+12]
   \   00000094   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000096   0x0A00             LSRS     R0,R0,#+8
   \   00000098   0xF884 0x0225      STRB     R0,[R4, #+549]
   \   0000009C   0x68E0             LDR      R0,[R4, #+12]
   \   0000009E   0x0C00             LSRS     R0,R0,#+16
   \   000000A0   0xF884 0x0226      STRB     R0,[R4, #+550]
   \   000000A4   0x68E0             LDR      R0,[R4, #+12]
   \   000000A6   0x0E00             LSRS     R0,R0,#+24
   \   000000A8   0xF884 0x0227      STRB     R0,[R4, #+551]
    803          			/* Write it into the FSInfo sector */
    804          			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
   \   000000AC   0x2301             MOVS     R3,#+1
   \   000000AE   0x6962             LDR      R2,[R4, #+20]
   \   000000B0   0xF114 0x0138      ADDS     R1,R4,#+56
   \   000000B4   0x7860             LDRB     R0,[R4, #+1]
   \   000000B6   0x.... 0x....      BL       disk_write
    805          			fs->fsi_flag = 0;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x7160             STRB     R0,[R4, #+5]
    806          		}
    807          		/* Make sure that no pending write process in the physical drive */
    808          		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
   \                     ??sync_fs_1:
   \   000000BE   0x2200             MOVS     R2,#+0
   \   000000C0   0x2100             MOVS     R1,#+0
   \   000000C2   0x7860             LDRB     R0,[R4, #+1]
   \   000000C4   0x.... 0x....      BL       disk_ioctl
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD000             BEQ.N    ??sync_fs_0
    809          			res = FR_DISK_ERR;
   \   000000CC   0x2501             MOVS     R5,#+1
    810          	}
    811          
    812          	return res;
   \                     ??sync_fs_0:
   \   000000CE   0x0028             MOVS     R0,R5
   \   000000D0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D2   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    813          }
    814          #endif
    815          
    816          
    817          
    818          
    819          /*-----------------------------------------------------------------------*/
    820          /* Get sector# from cluster#                                             */
    821          /*-----------------------------------------------------------------------*/
    822          
    823          

   \                                 In section .text, align 2, keep-with-next
    824          DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
    825          	FATFS *fs,		/* File system object */
    826          	DWORD clst		/* Cluster# to be converted */
    827          )
    828          {
    829          	clst -= 2;
   \                     clust2sect:
   \   00000000   0x1E89             SUBS     R1,R1,#+2
    830          	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
   \   00000002   0x69C2             LDR      R2,[R0, #+28]
   \   00000004   0x1E92             SUBS     R2,R2,#+2
   \   00000006   0x4291             CMP      R1,R2
   \   00000008   0xD301             BCC.N    ??clust2sect_0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE003             B.N      ??clust2sect_1
    831          	return clst * fs->csize + fs->database;
   \                     ??clust2sect_0:
   \   0000000E   0x7882             LDRB     R2,[R0, #+2]
   \   00000010   0x6B00             LDR      R0,[R0, #+48]
   \   00000012   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \                     ??clust2sect_1:
   \   00000016   0x4770             BX       LR               ;; return
    832          }
    833          
    834          
    835          
    836          
    837          /*-----------------------------------------------------------------------*/
    838          /* FAT access - Read value of a FAT entry                                */
    839          /*-----------------------------------------------------------------------*/
    840          
    841          

   \                                 In section .text, align 2, keep-with-next
    842          DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
    843          	FATFS *fs,	/* File system object */
    844          	DWORD clst	/* Cluster# to get the link information */
    845          )
    846          {
   \                     get_fat:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    847          	UINT wc, bc;
    848          	BYTE *p;
    849          
    850          
    851          	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
   \   00000006   0x2D02             CMP      R5,#+2
   \   00000008   0xD302             BCC.N    ??get_fat_0
   \   0000000A   0x69E0             LDR      R0,[R4, #+28]
   \   0000000C   0x4285             CMP      R5,R0
   \   0000000E   0xD301             BCC.N    ??get_fat_1
    852          		return 1;
   \                     ??get_fat_0:
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE014             B.N      ??get_fat_2
    853          
    854          	switch (fs->fs_type) {
   \                     ??get_fat_1:
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD004             BEQ.N    ??get_fat_3
   \   0000001A   0xD30E             BCC.N    ??get_fat_4
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD04A             BEQ.N    ??get_fat_5
   \   00000020   0xD332             BCC.N    ??get_fat_6
   \   00000022   0xE00A             B.N      ??get_fat_4
    855          	case FS_FAT12 :
    856          		bc = (UINT)clst; bc += bc / 2;
   \                     ??get_fat_3:
   \   00000024   0x002E             MOVS     R6,R5
   \   00000026   0xEB16 0x0656      ADDS     R6,R6,R6, LSR #+1
    857          		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
   \   0000002A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000002C   0xEB10 0x2156      ADDS     R1,R0,R6, LSR #+9
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       move_window
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD002             BEQ.N    ??get_fat_7
    858          		wc = fs->win[bc % SS(fs)]; bc++;
    859          		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    860          		wc |= fs->win[bc % SS(fs)] << 8;
    861          		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    862          
    863          	case FS_FAT16 :
    864          		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    865          		p = &fs->win[clst * 2 % SS(fs)];
    866          		return LD_WORD(p);
    867          
    868          	case FS_FAT32 :
    869          		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    870          		p = &fs->win[clst * 4 % SS(fs)];
    871          		return LD_DWORD(p) & 0x0FFFFFFF;
    872          	}
    873          
    874          	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
   \                     ??get_fat_4:
   \   0000003A   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??get_fat_2:
   \   0000003E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??get_fat_7:
   \   00000040   0xF44F 0x7000      MOV      R0,#+512
   \   00000044   0xFBB6 0xF1F0      UDIV     R1,R6,R0
   \   00000048   0xFB01 0x6110      MLS      R1,R1,R0,R6
   \   0000004C   0x1908             ADDS     R0,R1,R4
   \   0000004E   0xF890 0x7038      LDRB     R7,[R0, #+56]
   \   00000052   0x1C76             ADDS     R6,R6,#+1
   \   00000054   0x6AA0             LDR      R0,[R4, #+40]
   \   00000056   0xEB10 0x2156      ADDS     R1,R0,R6, LSR #+9
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       move_window
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD1EA             BNE.N    ??get_fat_4
   \                     ??get_fat_8:
   \   00000064   0xF44F 0x7000      MOV      R0,#+512
   \   00000068   0xFBB6 0xF1F0      UDIV     R1,R6,R0
   \   0000006C   0xFB01 0x6110      MLS      R1,R1,R0,R6
   \   00000070   0x1908             ADDS     R0,R1,R4
   \   00000072   0xF890 0x0038      LDRB     R0,[R0, #+56]
   \   00000076   0xEA57 0x2700      ORRS     R7,R7,R0, LSL #+8
   \   0000007A   0x07E8             LSLS     R0,R5,#+31
   \   0000007C   0xD501             BPL.N    ??get_fat_9
   \   0000007E   0x0938             LSRS     R0,R7,#+4
   \   00000080   0xE001             B.N      ??get_fat_10
   \                     ??get_fat_9:
   \   00000082   0x0538             LSLS     R0,R7,#+20       ;; ZeroExtS R0,R7,#+20,#+20
   \   00000084   0x0D00             LSRS     R0,R0,#+20
   \                     ??get_fat_10:
   \   00000086   0xE7DA             B.N      ??get_fat_2
   \                     ??get_fat_6:
   \   00000088   0x6AA0             LDR      R0,[R4, #+40]
   \   0000008A   0xEB10 0x2115      ADDS     R1,R0,R5, LSR #+8
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0x.... 0x....      BL       move_window
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD1D0             BNE.N    ??get_fat_4
   \                     ??get_fat_11:
   \   00000098   0x0068             LSLS     R0,R5,#+1
   \   0000009A   0xF44F 0x7100      MOV      R1,#+512
   \   0000009E   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   000000A2   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   000000A6   0x1910             ADDS     R0,R2,R4
   \   000000A8   0x3038             ADDS     R0,R0,#+56
   \   000000AA   0x7841             LDRB     R1,[R0, #+1]
   \   000000AC   0x7800             LDRB     R0,[R0, #+0]
   \   000000AE   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000000B2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B4   0xE7C3             B.N      ??get_fat_2
   \                     ??get_fat_5:
   \   000000B6   0x6AA0             LDR      R0,[R4, #+40]
   \   000000B8   0xEB10 0x11D5      ADDS     R1,R0,R5, LSR #+7
   \   000000BC   0x0020             MOVS     R0,R4
   \   000000BE   0x.... 0x....      BL       move_window
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD1B9             BNE.N    ??get_fat_4
   \                     ??get_fat_12:
   \   000000C6   0x00A8             LSLS     R0,R5,#+2
   \   000000C8   0xF44F 0x7100      MOV      R1,#+512
   \   000000CC   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   000000D0   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   000000D4   0x1910             ADDS     R0,R2,R4
   \   000000D6   0x3038             ADDS     R0,R0,#+56
   \   000000D8   0x78C1             LDRB     R1,[R0, #+3]
   \   000000DA   0x7882             LDRB     R2,[R0, #+2]
   \   000000DC   0x0412             LSLS     R2,R2,#+16
   \   000000DE   0xEA52 0x6101      ORRS     R1,R2,R1, LSL #+24
   \   000000E2   0x7842             LDRB     R2,[R0, #+1]
   \   000000E4   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   000000E8   0x7800             LDRB     R0,[R0, #+0]
   \   000000EA   0x4308             ORRS     R0,R0,R1
   \   000000EC   0x0100             LSLS     R0,R0,#+4        ;; ZeroExtS R0,R0,#+4,#+4
   \   000000EE   0x0900             LSRS     R0,R0,#+4
   \   000000F0   0xE7A5             B.N      ??get_fat_2
    875          }
    876          
    877          
    878          
    879          
    880          /*-----------------------------------------------------------------------*/
    881          /* FAT access - Change value of a FAT entry                              */
    882          /*-----------------------------------------------------------------------*/
    883          #if !_FS_READONLY
    884          

   \                                 In section .text, align 2, keep-with-next
    885          FRESULT put_fat (
    886          	FATFS *fs,	/* File system object */
    887          	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
    888          	DWORD val	/* New value to mark the cluster */
    889          )
    890          {
   \                     put_fat:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    891          	UINT bc;
    892          	BYTE *p;
    893          	FRESULT res;
    894          
    895          
    896          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   \   00000008   0x2D02             CMP      R5,#+2
   \   0000000A   0xD302             BCC.N    ??put_fat_0
   \   0000000C   0x69E0             LDR      R0,[R4, #+28]
   \   0000000E   0x4285             CMP      R5,R0
   \   00000010   0xD301             BCC.N    ??put_fat_1
    897          		res = FR_INT_ERR;
   \                     ??put_fat_0:
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xE082             B.N      ??put_fat_2
    898          
    899          	} else {
    900          		switch (fs->fs_type) {
   \                     ??put_fat_1:
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD004             BEQ.N    ??put_fat_3
   \   0000001C   0xD37B             BCC.N    ??put_fat_4
   \   0000001E   0x2803             CMP      R0,#+3
   \   00000020   0xD058             BEQ.N    ??put_fat_5
   \   00000022   0xD340             BCC.N    ??put_fat_6
   \   00000024   0xE077             B.N      ??put_fat_4
    901          		case FS_FAT12 :
    902          			bc = (UINT)clst; bc += bc / 2;
   \                     ??put_fat_3:
   \   00000026   0x002F             MOVS     R7,R5
   \   00000028   0xEB17 0x0757      ADDS     R7,R7,R7, LSR #+1
    903          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   \   0000002C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000002E   0xEB10 0x2157      ADDS     R1,R0,R7, LSR #+9
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       move_window
    904          			if (res != FR_OK) break;
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD16C             BNE.N    ??put_fat_7
    905          			p = &fs->win[bc % SS(fs)];
   \                     ??put_fat_8:
   \   0000003E   0xF44F 0x7000      MOV      R0,#+512
   \   00000042   0xFBB7 0xF1F0      UDIV     R1,R7,R0
   \   00000046   0xFB01 0x7110      MLS      R1,R1,R0,R7
   \   0000004A   0x1908             ADDS     R0,R1,R4
   \   0000004C   0xF110 0x0138      ADDS     R1,R0,#+56
    906          			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
   \   00000050   0x07E8             LSLS     R0,R5,#+31
   \   00000052   0xD505             BPL.N    ??put_fat_9
   \   00000054   0x7808             LDRB     R0,[R1, #+0]
   \   00000056   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000005A   0xEA50 0x1006      ORRS     R0,R0,R6, LSL #+4
   \   0000005E   0xE000             B.N      ??put_fat_10
   \                     ??put_fat_9:
   \   00000060   0x0030             MOVS     R0,R6
   \                     ??put_fat_10:
   \   00000062   0x7008             STRB     R0,[R1, #+0]
    907          			bc++;
   \   00000064   0x1C7F             ADDS     R7,R7,#+1
    908          			fs->wflag = 1;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x7120             STRB     R0,[R4, #+4]
    909          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   \   0000006A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000006C   0xEB10 0x2157      ADDS     R1,R0,R7, LSR #+9
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0x.... 0x....      BL       move_window
    910          			if (res != FR_OK) break;
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD14D             BNE.N    ??put_fat_7
    911          			p = &fs->win[bc % SS(fs)];
   \                     ??put_fat_11:
   \   0000007C   0xF44F 0x7100      MOV      R1,#+512
   \   00000080   0xFBB7 0xF2F1      UDIV     R2,R7,R1
   \   00000084   0xFB02 0x7211      MLS      R2,R2,R1,R7
   \   00000088   0x1911             ADDS     R1,R2,R4
   \   0000008A   0x3138             ADDS     R1,R1,#+56
    912          			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   \   0000008C   0x07EA             LSLS     R2,R5,#+31
   \   0000008E   0xD501             BPL.N    ??put_fat_12
   \   00000090   0x0932             LSRS     R2,R6,#+4
   \   00000092   0xE006             B.N      ??put_fat_13
   \                     ??put_fat_12:
   \   00000094   0x780A             LDRB     R2,[R1, #+0]
   \   00000096   0xF012 0x02F0      ANDS     R2,R2,#0xF0
   \   0000009A   0x0A33             LSRS     R3,R6,#+8
   \   0000009C   0xF013 0x030F      ANDS     R3,R3,#0xF
   \   000000A0   0x431A             ORRS     R2,R3,R2
   \                     ??put_fat_13:
   \   000000A2   0x700A             STRB     R2,[R1, #+0]
    913          			break;
   \   000000A4   0xE038             B.N      ??put_fat_7
    914          
    915          		case FS_FAT16 :
    916          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
   \                     ??put_fat_6:
   \   000000A6   0x6AA0             LDR      R0,[R4, #+40]
   \   000000A8   0xEB10 0x2115      ADDS     R1,R0,R5, LSR #+8
   \   000000AC   0x0020             MOVS     R0,R4
   \   000000AE   0x.... 0x....      BL       move_window
    917          			if (res != FR_OK) break;
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD12F             BNE.N    ??put_fat_7
    918          			p = &fs->win[clst * 2 % SS(fs)];
   \                     ??put_fat_14:
   \   000000B8   0x0069             LSLS     R1,R5,#+1
   \   000000BA   0xF44F 0x7200      MOV      R2,#+512
   \   000000BE   0xFBB1 0xF3F2      UDIV     R3,R1,R2
   \   000000C2   0xFB03 0x1312      MLS      R3,R3,R2,R1
   \   000000C6   0x1919             ADDS     R1,R3,R4
   \   000000C8   0x3138             ADDS     R1,R1,#+56
    919          			ST_WORD(p, (WORD)val);
   \   000000CA   0x700E             STRB     R6,[R1, #+0]
   \   000000CC   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000CE   0x0A32             LSRS     R2,R6,#+8
   \   000000D0   0x704A             STRB     R2,[R1, #+1]
    920          			break;
   \   000000D2   0xE021             B.N      ??put_fat_7
    921          
    922          		case FS_FAT32 :
    923          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
   \                     ??put_fat_5:
   \   000000D4   0x6AA0             LDR      R0,[R4, #+40]
   \   000000D6   0xEB10 0x11D5      ADDS     R1,R0,R5, LSR #+7
   \   000000DA   0x0020             MOVS     R0,R4
   \   000000DC   0x.... 0x....      BL       move_window
    924          			if (res != FR_OK) break;
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD118             BNE.N    ??put_fat_7
    925          			p = &fs->win[clst * 4 % SS(fs)];
   \                     ??put_fat_15:
   \   000000E6   0x00A9             LSLS     R1,R5,#+2
   \   000000E8   0xF44F 0x7200      MOV      R2,#+512
   \   000000EC   0xFBB1 0xF3F2      UDIV     R3,R1,R2
   \   000000F0   0xFB03 0x1312      MLS      R3,R3,R2,R1
   \   000000F4   0x1919             ADDS     R1,R3,R4
   \   000000F6   0x3138             ADDS     R1,R1,#+56
    926          			val |= LD_DWORD(p) & 0xF0000000;
   \   000000F8   0x78CA             LDRB     R2,[R1, #+3]
   \   000000FA   0x0612             LSLS     R2,R2,#+24
   \   000000FC   0xF012 0x4270      ANDS     R2,R2,#0xF0000000
   \   00000100   0x4316             ORRS     R6,R2,R6
    927          			ST_DWORD(p, val);
   \   00000102   0x700E             STRB     R6,[R1, #+0]
   \   00000104   0x0032             MOVS     R2,R6
   \   00000106   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000108   0x0A12             LSRS     R2,R2,#+8
   \   0000010A   0x704A             STRB     R2,[R1, #+1]
   \   0000010C   0x0C32             LSRS     R2,R6,#+16
   \   0000010E   0x708A             STRB     R2,[R1, #+2]
   \   00000110   0x0E32             LSRS     R2,R6,#+24
   \   00000112   0x70CA             STRB     R2,[R1, #+3]
    928          			break;
   \   00000114   0xE000             B.N      ??put_fat_7
    929          
    930          		default :
    931          			res = FR_INT_ERR;
   \                     ??put_fat_4:
   \   00000116   0x2002             MOVS     R0,#+2
    932          		}
    933          		fs->wflag = 1;
   \                     ??put_fat_7:
   \   00000118   0x2101             MOVS     R1,#+1
   \   0000011A   0x7121             STRB     R1,[R4, #+4]
    934          	}
    935          
    936          	return res;
   \                     ??put_fat_2:
   \   0000011C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    937          }
    938          #endif /* !_FS_READONLY */
    939          
    940          
    941          
    942          
    943          /*-----------------------------------------------------------------------*/
    944          /* FAT handling - Remove a cluster chain                                 */
    945          /*-----------------------------------------------------------------------*/
    946          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    947          static
    948          FRESULT remove_chain (
    949          	FATFS *fs,			/* File system object */
    950          	DWORD clst			/* Cluster# to remove a chain from */
    951          )
    952          {
   \                     remove_chain:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
    953          	FRESULT res;
    954          	DWORD nxt;
    955          #if _USE_ERASE
    956          	DWORD scl = clst, ecl = clst, rt[2];
    957          #endif
    958          
    959          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   \   00000006   0x2E02             CMP      R6,#+2
   \   00000008   0xD302             BCC.N    ??remove_chain_0
   \   0000000A   0x69E0             LDR      R0,[R4, #+28]
   \   0000000C   0x4286             CMP      R6,R0
   \   0000000E   0xD301             BCC.N    ??remove_chain_1
    960          		res = FR_INT_ERR;
   \                     ??remove_chain_0:
   \   00000010   0x2502             MOVS     R5,#+2
   \   00000012   0xE027             B.N      ??remove_chain_2
    961          
    962          	} else {
    963          		res = FR_OK;
   \                     ??remove_chain_1:
   \   00000014   0x2500             MOVS     R5,#+0
   \   00000016   0xE009             B.N      ??remove_chain_3
    964          		while (clst < fs->n_fatent) {			/* Not a last link? */
    965          			nxt = get_fat(fs, clst);			/* Get cluster status */
    966          			if (nxt == 0) break;				/* Empty cluster? */
    967          			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    968          			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    969          			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    970          			if (res != FR_OK) break;
    971          			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
   \                     ??remove_chain_4:
   \   00000018   0x6920             LDR      R0,[R4, #+16]
   \   0000001A   0xF110 0x0F01      CMN      R0,#+1
   \   0000001E   0xD004             BEQ.N    ??remove_chain_5
    972          				fs->free_clust++;
   \   00000020   0x6920             LDR      R0,[R4, #+16]
   \   00000022   0x1C40             ADDS     R0,R0,#+1
   \   00000024   0x6120             STR      R0,[R4, #+16]
    973          				fs->fsi_flag = 1;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x7160             STRB     R0,[R4, #+5]
    974          			}
    975          #if _USE_ERASE
    976          			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
    977          				ecl = nxt;
    978          			} else {				/* End of contiguous clusters */ 
    979          				rt[0] = clust2sect(fs, scl);					/* Start sector */
    980          				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
    981          				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, rt);		/* Erase the block */
    982          				scl = ecl = nxt;
    983          			}
    984          #endif
    985          			clst = nxt;	/* Next cluster */
   \                     ??remove_chain_5:
   \   0000002A   0x003E             MOVS     R6,R7
   \                     ??remove_chain_3:
   \   0000002C   0x69E0             LDR      R0,[R4, #+28]
   \   0000002E   0x4286             CMP      R6,R0
   \   00000030   0xD218             BCS.N    ??remove_chain_2
   \   00000032   0x0031             MOVS     R1,R6
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       get_fat
   \   0000003A   0x0007             MOVS     R7,R0
   \   0000003C   0x2F00             CMP      R7,#+0
   \   0000003E   0xD011             BEQ.N    ??remove_chain_2
   \                     ??remove_chain_6:
   \   00000040   0x2F01             CMP      R7,#+1
   \   00000042   0xD101             BNE.N    ??remove_chain_7
   \   00000044   0x2502             MOVS     R5,#+2
   \   00000046   0xE00D             B.N      ??remove_chain_2
   \                     ??remove_chain_7:
   \   00000048   0xF117 0x0F01      CMN      R7,#+1
   \   0000004C   0xD101             BNE.N    ??remove_chain_8
   \   0000004E   0x2501             MOVS     R5,#+1
   \   00000050   0xE008             B.N      ??remove_chain_2
   \                     ??remove_chain_8:
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x0031             MOVS     R1,R6
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       put_fat
   \   0000005C   0x0005             MOVS     R5,R0
   \   0000005E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000060   0x2D00             CMP      R5,#+0
   \   00000062   0xD0D9             BEQ.N    ??remove_chain_4
    986          		}
    987          	}
    988          
    989          	return res;
   \                     ??remove_chain_2:
   \   00000064   0x0028             MOVS     R0,R5
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    990          }
    991          #endif
    992          
    993          
    994          
    995          
    996          /*-----------------------------------------------------------------------*/
    997          /* FAT handling - Stretch or Create a cluster chain                      */
    998          /*-----------------------------------------------------------------------*/
    999          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1000          static
   1001          DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
   1002          	FATFS *fs,			/* File system object */
   1003          	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
   1004          )
   1005          {
   \                     create_chain:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   1006          	DWORD cs, ncl, scl;
   1007          	FRESULT res;
   1008          
   1009          
   1010          	if (clst == 0) {		/* Create a new chain */
   \   00000006   0x2E00             CMP      R6,#+0
   \   00000008   0xD107             BNE.N    ??create_chain_0
   1011          		scl = fs->last_clust;			/* Get suggested start point */
   \   0000000A   0x68E7             LDR      R7,[R4, #+12]
   1012          		if (!scl || scl >= fs->n_fatent) scl = 1;
   \   0000000C   0x2F00             CMP      R7,#+0
   \   0000000E   0xD002             BEQ.N    ??create_chain_1
   \   00000010   0x69E0             LDR      R0,[R4, #+28]
   \   00000012   0x4287             CMP      R7,R0
   \   00000014   0xD30D             BCC.N    ??create_chain_2
   \                     ??create_chain_1:
   \   00000016   0x2701             MOVS     R7,#+1
   \   00000018   0xE00B             B.N      ??create_chain_2
   1013          	}
   1014          	else {					/* Stretch the current chain */
   1015          		cs = get_fat(fs, clst);			/* Check the cluster status */
   \                     ??create_chain_0:
   \   0000001A   0x0031             MOVS     R1,R6
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       get_fat
   1016          		if (cs < 2) return 1;			/* It is an invalid cluster */
   \   00000022   0x2802             CMP      R0,#+2
   \   00000024   0xD201             BCS.N    ??create_chain_3
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE043             B.N      ??create_chain_4
   1017          		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
   \                     ??create_chain_3:
   \   0000002A   0x69E1             LDR      R1,[R4, #+28]
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD340             BCC.N    ??create_chain_4
   1018          		scl = clst;
   \                     ??create_chain_5:
   \   00000030   0x0037             MOVS     R7,R6
   1019          	}
   1020          
   1021          	ncl = scl;				/* Start cluster */
   \                     ??create_chain_2:
   \   00000032   0x003D             MOVS     R5,R7
   1022          	for (;;) {
   1023          		ncl++;							/* Next cluster */
   \                     ??create_chain_6:
   \   00000034   0x1C6D             ADDS     R5,R5,#+1
   1024          		if (ncl >= fs->n_fatent) {		/* Wrap around */
   \   00000036   0x69E0             LDR      R0,[R4, #+28]
   \   00000038   0x4285             CMP      R5,R0
   \   0000003A   0xD304             BCC.N    ??create_chain_7
   1025          			ncl = 2;
   \   0000003C   0x2502             MOVS     R5,#+2
   1026          			if (ncl > scl) return 0;	/* No free cluster */
   \   0000003E   0x42AF             CMP      R7,R5
   \   00000040   0xD201             BCS.N    ??create_chain_7
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE035             B.N      ??create_chain_4
   1027          		}
   1028          		cs = get_fat(fs, ncl);			/* Get the cluster status */
   \                     ??create_chain_7:
   \   00000046   0x0029             MOVS     R1,R5
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       get_fat
   1029          		if (cs == 0) break;				/* Found a free cluster */
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD11D             BNE.N    ??create_chain_8
   1030          		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
   1031          			return cs;
   1032          		if (ncl == scl) return 0;		/* No free cluster */
   1033          	}
   1034          
   1035          	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
   \   00000052   0xF07F 0x4270      MVNS     R2,#-268435456
   \   00000056   0x0029             MOVS     R1,R5
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       put_fat
   1036          	if (res == FR_OK && clst != 0) {
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD106             BNE.N    ??create_chain_9
   \   00000064   0x2E00             CMP      R6,#+0
   \   00000066   0xD004             BEQ.N    ??create_chain_9
   1037          		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
   \   00000068   0x002A             MOVS     R2,R5
   \   0000006A   0x0031             MOVS     R1,R6
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       put_fat
   1038          	}
   1039          	if (res == FR_OK) {
   \                     ??create_chain_9:
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD114             BNE.N    ??create_chain_10
   1040          		fs->last_clust = ncl;			/* Update FSINFO */
   \   00000078   0x60E5             STR      R5,[R4, #+12]
   1041          		if (fs->free_clust != 0xFFFFFFFF) {
   \   0000007A   0x6920             LDR      R0,[R4, #+16]
   \   0000007C   0xF110 0x0F01      CMN      R0,#+1
   \   00000080   0xD016             BEQ.N    ??create_chain_11
   1042          			fs->free_clust--;
   \   00000082   0x6920             LDR      R0,[R4, #+16]
   \   00000084   0x1E40             SUBS     R0,R0,#+1
   \   00000086   0x6120             STR      R0,[R4, #+16]
   1043          			fs->fsi_flag = 1;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0x7160             STRB     R0,[R4, #+5]
   \   0000008C   0xE010             B.N      ??create_chain_11
   1044          		}
   1045          	} else {
   \                     ??create_chain_8:
   \   0000008E   0xF110 0x0F01      CMN      R0,#+1
   \   00000092   0xD001             BEQ.N    ??create_chain_12
   \   00000094   0x2801             CMP      R0,#+1
   \   00000096   0xD100             BNE.N    ??create_chain_13
   \                     ??create_chain_12:
   \   00000098   0xE00B             B.N      ??create_chain_4
   \                     ??create_chain_13:
   \   0000009A   0x42BD             CMP      R5,R7
   \   0000009C   0xD1CA             BNE.N    ??create_chain_6
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xE007             B.N      ??create_chain_4
   1046          		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
   \                     ??create_chain_10:
   \   000000A2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A4   0x2801             CMP      R0,#+1
   \   000000A6   0xD102             BNE.N    ??create_chain_14
   \   000000A8   0xF05F 0x35FF      MOVS     R5,#-1
   \   000000AC   0xE000             B.N      ??create_chain_11
   \                     ??create_chain_14:
   \   000000AE   0x2501             MOVS     R5,#+1
   1047          	}
   1048          
   1049          	return ncl;		/* Return new cluster number or error code */
   \                     ??create_chain_11:
   \   000000B0   0x0028             MOVS     R0,R5
   \                     ??create_chain_4:
   \   000000B2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1050          }
   1051          #endif /* !_FS_READONLY */
   1052          
   1053          
   1054          
   1055          /*-----------------------------------------------------------------------*/
   1056          /* FAT handling - Convert offset into cluster with link map table        */
   1057          /*-----------------------------------------------------------------------*/
   1058          
   1059          #if _USE_FASTSEEK

   \                                 In section .text, align 2, keep-with-next
   1060          static
   1061          DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
   1062          	FIL* fp,		/* Pointer to the file object */
   1063          	DWORD ofs		/* File offset to be converted to cluster# */
   1064          )
   1065          {
   1066          	DWORD cl, ncl, *tbl;
   1067          
   1068          
   1069          	tbl = fp->cltbl + 1;	/* Top of CLMT */
   \                     clmt_clust:
   \   00000000   0x6A42             LDR      R2,[R0, #+36]
   \   00000002   0x1D12             ADDS     R2,R2,#+4
   1070          	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
   \   00000004   0x0A49             LSRS     R1,R1,#+9
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x7880             LDRB     R0,[R0, #+2]
   \   0000000A   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \   0000000E   0xE001             B.N      ??clmt_clust_0
   1071          	for (;;) {
   1072          		ncl = *tbl++;			/* Number of cluters in the fragment */
   1073          		if (!ncl) return 0;		/* End of table? (error) */
   1074          		if (cl < ncl) break;	/* In this fragment? */
   1075          		cl -= ncl; tbl++;		/* Next fragment */
   \                     ??clmt_clust_1:
   \   00000010   0x1A40             SUBS     R0,R0,R1
   \   00000012   0x1D12             ADDS     R2,R2,#+4
   \                     ??clmt_clust_0:
   \   00000014   0x6811             LDR      R1,[R2, #+0]
   \   00000016   0x1D12             ADDS     R2,R2,#+4
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD101             BNE.N    ??clmt_clust_2
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE003             B.N      ??clmt_clust_3
   \                     ??clmt_clust_2:
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD2F5             BCS.N    ??clmt_clust_1
   1076          	}
   1077          	return cl + *tbl;	/* Return the cluster number */
   \   00000024   0x6811             LDR      R1,[R2, #+0]
   \   00000026   0x1808             ADDS     R0,R1,R0
   \                     ??clmt_clust_3:
   \   00000028   0x4770             BX       LR               ;; return
   1078          }
   1079          #endif	/* _USE_FASTSEEK */
   1080          
   1081          
   1082          
   1083          /*-----------------------------------------------------------------------*/
   1084          /* Directory handling - Set directory index                              */
   1085          /*-----------------------------------------------------------------------*/
   1086          

   \                                 In section .text, align 2, keep-with-next
   1087          static
   1088          FRESULT dir_sdi (
   1089          	DIR *dj,		/* Pointer to directory object */
   1090          	WORD idx		/* Index of directory table */
   1091          )
   1092          {
   \                     dir_sdi:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1093          	DWORD clst;
   1094          	WORD ic;
   1095          
   1096          
   1097          	dj->index = idx;
   \   00000006   0x80E5             STRH     R5,[R4, #+6]
   1098          	clst = dj->sclust;
   \   00000008   0x68A0             LDR      R0,[R4, #+8]
   1099          	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD003             BEQ.N    ??dir_sdi_0
   \   0000000E   0x6821             LDR      R1,[R4, #+0]
   \   00000010   0x69C9             LDR      R1,[R1, #+28]
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD301             BCC.N    ??dir_sdi_1
   1100          		return FR_INT_ERR;
   \                     ??dir_sdi_0:
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xE048             B.N      ??dir_sdi_2
   1101          	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
   \                     ??dir_sdi_1:
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD105             BNE.N    ??dir_sdi_3
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x7809             LDRB     R1,[R1, #+0]
   \   00000022   0x2903             CMP      R1,#+3
   \   00000024   0xD101             BNE.N    ??dir_sdi_3
   1102          		clst = dj->fs->dirbase;
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6AC0             LDR      R0,[R0, #+44]
   1103          
   1104          	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
   \                     ??dir_sdi_3:
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD10E             BNE.N    ??dir_sdi_4
   1105          		dj->clust = clst;
   \   0000002E   0x60E0             STR      R0,[R4, #+12]
   1106          		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x8900             LDRH     R0,[R0, #+8]
   \   00000034   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000036   0x4285             CMP      R5,R0
   \   00000038   0xD301             BCC.N    ??dir_sdi_5
   1107          			return FR_INT_ERR;
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0xE036             B.N      ??dir_sdi_2
   1108          		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
   \                     ??dir_sdi_5:
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6AC0             LDR      R0,[R0, #+44]
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0xEB10 0x1015      ADDS     R0,R0,R5, LSR #+4
   \   00000048   0x6120             STR      R0,[R4, #+16]
   \   0000004A   0xE023             B.N      ??dir_sdi_6
   1109          	}
   1110          	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
   1111          		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
   \                     ??dir_sdi_4:
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x7889             LDRB     R1,[R1, #+2]
   \   00000050   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000052   0x010E             LSLS     R6,R1,#+4
   \   00000054   0xE000             B.N      ??dir_sdi_7
   1112          		while (idx >= ic) {	/* Follow cluster chain */
   1113          			clst = get_fat(dj->fs, clst);				/* Get next cluster */
   1114          			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   1115          			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
   1116          				return FR_INT_ERR;
   1117          			idx -= ic;
   \                     ??dir_sdi_8:
   \   00000056   0x1BAD             SUBS     R5,R5,R6
   \                     ??dir_sdi_7:
   \   00000058   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000005C   0x42B5             CMP      R5,R6
   \   0000005E   0xD310             BCC.N    ??dir_sdi_9
   \   00000060   0x0001             MOVS     R1,R0
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x.... 0x....      BL       get_fat
   \   00000068   0xF110 0x0F01      CMN      R0,#+1
   \   0000006C   0xD101             BNE.N    ??dir_sdi_10
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0xE01C             B.N      ??dir_sdi_2
   \                     ??dir_sdi_10:
   \   00000072   0x2802             CMP      R0,#+2
   \   00000074   0xD303             BCC.N    ??dir_sdi_11
   \   00000076   0x6821             LDR      R1,[R4, #+0]
   \   00000078   0x69C9             LDR      R1,[R1, #+28]
   \   0000007A   0x4288             CMP      R0,R1
   \   0000007C   0xD3EB             BCC.N    ??dir_sdi_8
   \                     ??dir_sdi_11:
   \   0000007E   0x2002             MOVS     R0,#+2
   \   00000080   0xE014             B.N      ??dir_sdi_2
   1118          		}
   1119          		dj->clust = clst;
   \                     ??dir_sdi_9:
   \   00000082   0x60E0             STR      R0,[R4, #+12]
   1120          		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
   \   00000084   0x0001             MOVS     R1,R0
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x.... 0x....      BL       clust2sect
   \   0000008C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000008E   0xEB10 0x1015      ADDS     R0,R0,R5, LSR #+4
   \   00000092   0x6120             STR      R0,[R4, #+16]
   1121          	}
   1122          
   1123          	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
   \                     ??dir_sdi_6:
   \   00000094   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000096   0x2010             MOVS     R0,#+16
   \   00000098   0xFBB5 0xF1F0      UDIV     R1,R5,R0
   \   0000009C   0xFB01 0x5110      MLS      R1,R1,R0,R5
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0xEB10 0x1041      ADDS     R0,R0,R1, LSL #+5
   \   000000A6   0x3038             ADDS     R0,R0,#+56
   \   000000A8   0x6160             STR      R0,[R4, #+20]
   1124          
   1125          	return FR_OK;	/* Seek succeeded */
   \   000000AA   0x2000             MOVS     R0,#+0
   \                     ??dir_sdi_2:
   \   000000AC   0xBD70             POP      {R4-R6,PC}       ;; return
   1126          }
   1127          
   1128          
   1129          
   1130          
   1131          /*-----------------------------------------------------------------------*/
   1132          /* Directory handling - Move directory table index next                  */
   1133          /*-----------------------------------------------------------------------*/
   1134          

   \                                 In section .text, align 2, keep-with-next
   1135          static
   1136          FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
   1137          	DIR *dj,		/* Pointer to the directory object */
   1138          	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
   1139          )
   1140          {
   \                     dir_next:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1141          	DWORD clst;
   1142          	WORD i;
   1143          
   1144          
   1145          	stretch = stretch;		/* To suppress warning on read-only cfg. */
   1146          	i = dj->index + 1;
   \   00000006   0x88E0             LDRH     R0,[R4, #+6]
   \   00000008   0x1C46             ADDS     R6,R0,#+1
   1147          	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
   \   0000000A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000000C   0x2E00             CMP      R6,#+0
   \   0000000E   0xD002             BEQ.N    ??dir_next_0
   \   00000010   0x6920             LDR      R0,[R4, #+16]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD101             BNE.N    ??dir_next_1
   1148          		return FR_NO_FILE;
   \                     ??dir_next_0:
   \   00000016   0x2004             MOVS     R0,#+4
   \   00000018   0xE087             B.N      ??dir_next_2
   1149          
   1150          	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
   \                     ??dir_next_1:
   \   0000001A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001C   0x2010             MOVS     R0,#+16
   \   0000001E   0xFBB6 0xF1F0      UDIV     R1,R6,R0
   \   00000022   0xFB01 0x6110      MLS      R1,R1,R0,R6
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD172             BNE.N    ??dir_next_3
   1151          		dj->sect++;					/* Next sector */
   \   0000002A   0x6920             LDR      R0,[R4, #+16]
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0x6120             STR      R0,[R4, #+16]
   1152          
   1153          		if (dj->clust == 0) {	/* Static table */
   \   00000030   0x68E0             LDR      R0,[R4, #+12]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD106             BNE.N    ??dir_next_4
   1154          			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x8900             LDRH     R0,[R0, #+8]
   \   0000003A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000003C   0x4286             CMP      R6,R0
   \   0000003E   0xD367             BCC.N    ??dir_next_3
   1155          				return FR_NO_FILE;
   \   00000040   0x2004             MOVS     R0,#+4
   \   00000042   0xE072             B.N      ??dir_next_2
   1156          		}
   1157          		else {					/* Dynamic table */
   1158          			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
   \                     ??dir_next_4:
   \   00000044   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x7880             LDRB     R0,[R0, #+2]
   \   0000004A   0x1E40             SUBS     R0,R0,#+1
   \   0000004C   0xEA10 0x1F16      TST      R0,R6, LSR #+4
   \   00000050   0xD15E             BNE.N    ??dir_next_3
   1159          				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
   \   00000052   0x68E1             LDR      R1,[R4, #+12]
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x.... 0x....      BL       get_fat
   \   0000005A   0x0007             MOVS     R7,R0
   1160          				if (clst <= 1) return FR_INT_ERR;
   \   0000005C   0x2F02             CMP      R7,#+2
   \   0000005E   0xD201             BCS.N    ??dir_next_5
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0xE062             B.N      ??dir_next_2
   1161          				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \                     ??dir_next_5:
   \   00000064   0xF117 0x0F01      CMN      R7,#+1
   \   00000068   0xD101             BNE.N    ??dir_next_6
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0xE05D             B.N      ??dir_next_2
   1162          				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
   \                     ??dir_next_6:
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x69C0             LDR      R0,[R0, #+28]
   \   00000072   0x4287             CMP      R7,R0
   \   00000074   0xD346             BCC.N    ??dir_next_7
   1163          #if !_FS_READONLY
   1164          					BYTE c;
   1165          					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
   \   00000076   0x2D00             CMP      R5,#+0
   \   00000078   0xD101             BNE.N    ??dir_next_8
   \   0000007A   0x2004             MOVS     R0,#+4
   \   0000007C   0xE055             B.N      ??dir_next_2
   1166          					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
   \                     ??dir_next_8:
   \   0000007E   0x68E1             LDR      R1,[R4, #+12]
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x.... 0x....      BL       create_chain
   \   00000086   0x0007             MOVS     R7,R0
   1167          					if (clst == 0) return FR_DENIED;			/* No free cluster */
   \   00000088   0x2F00             CMP      R7,#+0
   \   0000008A   0xD101             BNE.N    ??dir_next_9
   \   0000008C   0x2007             MOVS     R0,#+7
   \   0000008E   0xE04C             B.N      ??dir_next_2
   1168          					if (clst == 1) return FR_INT_ERR;
   \                     ??dir_next_9:
   \   00000090   0x2F01             CMP      R7,#+1
   \   00000092   0xD101             BNE.N    ??dir_next_10
   \   00000094   0x2002             MOVS     R0,#+2
   \   00000096   0xE048             B.N      ??dir_next_2
   1169          					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \                     ??dir_next_10:
   \   00000098   0xF117 0x0F01      CMN      R7,#+1
   \   0000009C   0xD101             BNE.N    ??dir_next_11
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0xE043             B.N      ??dir_next_2
   1170          					/* Clean-up stretched table */
   1171          					if (sync_window(dj->fs)) return FR_DISK_ERR;	/* Flush active window */
   \                     ??dir_next_11:
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x.... 0x....      BL       sync_window
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD001             BEQ.N    ??dir_next_12
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0xE03C             B.N      ??dir_next_2
   1172          					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
   \                     ??dir_next_12:
   \   000000B0   0xF44F 0x7200      MOV      R2,#+512
   \   000000B4   0x2100             MOVS     R1,#+0
   \   000000B6   0x6820             LDR      R0,[R4, #+0]
   \   000000B8   0x3038             ADDS     R0,R0,#+56
   \   000000BA   0x.... 0x....      BL       mem_set
   1173          					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
   \   000000BE   0x0039             MOVS     R1,R7
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0x.... 0x....      BL       clust2sect
   \   000000C6   0x6821             LDR      R1,[R4, #+0]
   \   000000C8   0x6348             STR      R0,[R1, #+52]
   1174          					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
   \   000000CA   0x2500             MOVS     R5,#+0
   \   000000CC   0xE005             B.N      ??dir_next_13
   1175          						dj->fs->wflag = 1;
   1176          						if (sync_window(dj->fs)) return FR_DISK_ERR;
   1177          						dj->fs->winsect++;
   \                     ??dir_next_14:
   \   000000CE   0x6820             LDR      R0,[R4, #+0]
   \   000000D0   0x6B40             LDR      R0,[R0, #+52]
   \   000000D2   0x1C40             ADDS     R0,R0,#+1
   \   000000D4   0x6821             LDR      R1,[R4, #+0]
   \   000000D6   0x6348             STR      R0,[R1, #+52]
   \   000000D8   0x1C6D             ADDS     R5,R5,#+1
   \                     ??dir_next_13:
   \   000000DA   0x6820             LDR      R0,[R4, #+0]
   \   000000DC   0x7880             LDRB     R0,[R0, #+2]
   \   000000DE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E0   0x4285             CMP      R5,R0
   \   000000E2   0xD209             BCS.N    ??dir_next_15
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0x2101             MOVS     R1,#+1
   \   000000E8   0x7101             STRB     R1,[R0, #+4]
   \   000000EA   0x6820             LDR      R0,[R4, #+0]
   \   000000EC   0x.... 0x....      BL       sync_window
   \   000000F0   0x2800             CMP      R0,#+0
   \   000000F2   0xD0EC             BEQ.N    ??dir_next_14
   \   000000F4   0x2001             MOVS     R0,#+1
   \   000000F6   0xE018             B.N      ??dir_next_2
   1178          					}
   1179          					dj->fs->winsect -= c;						/* Rewind window address */
   \                     ??dir_next_15:
   \   000000F8   0x6820             LDR      R0,[R4, #+0]
   \   000000FA   0x6B40             LDR      R0,[R0, #+52]
   \   000000FC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FE   0x1B40             SUBS     R0,R0,R5
   \   00000100   0x6821             LDR      R1,[R4, #+0]
   \   00000102   0x6348             STR      R0,[R1, #+52]
   1180          #else
   1181          					return FR_NO_FILE;			/* Report EOT */
   1182          #endif
   1183          				}
   1184          				dj->clust = clst;				/* Initialize data for new cluster */
   \                     ??dir_next_7:
   \   00000104   0x60E7             STR      R7,[R4, #+12]
   1185          				dj->sect = clust2sect(dj->fs, clst);
   \   00000106   0x0039             MOVS     R1,R7
   \   00000108   0x6820             LDR      R0,[R4, #+0]
   \   0000010A   0x.... 0x....      BL       clust2sect
   \   0000010E   0x6120             STR      R0,[R4, #+16]
   1186          			}
   1187          		}
   1188          	}
   1189          
   1190          	dj->index = i;
   \                     ??dir_next_3:
   \   00000110   0x80E6             STRH     R6,[R4, #+6]
   1191          	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
   \   00000112   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000114   0x2010             MOVS     R0,#+16
   \   00000116   0xFBB6 0xF1F0      UDIV     R1,R6,R0
   \   0000011A   0xFB01 0x6110      MLS      R1,R1,R0,R6
   \   0000011E   0x6820             LDR      R0,[R4, #+0]
   \   00000120   0xEB10 0x1041      ADDS     R0,R0,R1, LSL #+5
   \   00000124   0x3038             ADDS     R0,R0,#+56
   \   00000126   0x6160             STR      R0,[R4, #+20]
   1192          
   1193          	return FR_OK;
   \   00000128   0x2000             MOVS     R0,#+0
   \                     ??dir_next_2:
   \   0000012A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1194          }
   1195          
   1196          
   1197          
   1198          
   1199          /*-----------------------------------------------------------------------*/
   1200          /* Directory handling - Reserve directory entry                          */
   1201          /*-----------------------------------------------------------------------*/
   1202          
   1203          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1204          static
   1205          FRESULT dir_alloc (
   1206          	DIR* dj,	/* Pointer to the directory object */
   1207          	UINT nent	/* Number of contiguous entries to allocate (1-21) */
   1208          )
   1209          {
   \                     dir_alloc:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1210          	FRESULT res;
   1211          	UINT n;
   1212          
   1213          
   1214          	res = dir_sdi(dj, 0);
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       dir_sdi
   1215          	if (res == FR_OK) {
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD11B             BNE.N    ??dir_alloc_0
   1216          		n = 0;
   \   00000014   0x2600             MOVS     R6,#+0
   1217          		do {
   1218          			res = move_window(dj->fs, dj->sect);
   \                     ??dir_alloc_1:
   \   00000016   0x6921             LDR      R1,[R4, #+16]
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x.... 0x....      BL       move_window
   1219          			if (res != FR_OK) break;
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD113             BNE.N    ??dir_alloc_0
   1220          			if (dj->dir[0] == DDE || dj->dir[0] == 0) {	/* Is it a blank entry? */
   \                     ??dir_alloc_2:
   \   00000024   0x6961             LDR      R1,[R4, #+20]
   \   00000026   0x7809             LDRB     R1,[R1, #+0]
   \   00000028   0x29E5             CMP      R1,#+229
   \   0000002A   0xD003             BEQ.N    ??dir_alloc_3
   \   0000002C   0x6961             LDR      R1,[R4, #+20]
   \   0000002E   0x7809             LDRB     R1,[R1, #+0]
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xD103             BNE.N    ??dir_alloc_4
   1221          				if (++n == nent) break;	/* A block of contiguous entry is found */
   \                     ??dir_alloc_3:
   \   00000034   0x1C76             ADDS     R6,R6,#+1
   \   00000036   0x42AE             CMP      R6,R5
   \   00000038   0xD101             BNE.N    ??dir_alloc_5
   \   0000003A   0xE007             B.N      ??dir_alloc_0
   1222          			} else {
   1223          				n = 0;					/* Not a blank entry. Restart to search */
   \                     ??dir_alloc_4:
   \   0000003C   0x2600             MOVS     R6,#+0
   1224          			}
   1225          			res = dir_next(dj, 1);		/* Next entry with table stretch enabled */
   \                     ??dir_alloc_5:
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       dir_next
   1226          		} while (res == FR_OK);
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD0E4             BEQ.N    ??dir_alloc_1
   1227          	}
   1228          	return res;
   \                     ??dir_alloc_0:
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return
   1229          }
   1230          #endif
   1231          
   1232          
   1233          
   1234          /*-----------------------------------------------------------------------*/
   1235          /* Directory handling - Load/Store start cluster number                  */
   1236          /*-----------------------------------------------------------------------*/
   1237          

   \                                 In section .text, align 2, keep-with-next
   1238          static
   1239          DWORD ld_clust (
   1240          	FATFS *fs,	/* Pointer to the fs object */
   1241          	BYTE *dir	/* Pointer to the directory entry */
   1242          )
   1243          {
   1244          	DWORD cl;
   1245          
   1246          	cl = LD_WORD(dir+DIR_FstClusLO);
   \                     ld_clust:
   \   00000000   0x7ECA             LDRB     R2,[R1, #+27]
   \   00000002   0x7E8B             LDRB     R3,[R1, #+26]
   \   00000004   0xEA53 0x2202      ORRS     R2,R3,R2, LSL #+8
   \   00000008   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   1247          	if (fs->fs_type == FS_FAT32)
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2803             CMP      R0,#+3
   \   0000000E   0xD106             BNE.N    ??ld_clust_0
   1248          		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
   \   00000010   0x7D48             LDRB     R0,[R1, #+21]
   \   00000012   0x7D09             LDRB     R1,[R1, #+20]
   \   00000014   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000018   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001A   0xEA52 0x4200      ORRS     R2,R2,R0, LSL #+16
   1249          
   1250          	return cl;
   \                     ??ld_clust_0:
   \   0000001E   0x0010             MOVS     R0,R2
   \   00000020   0x4770             BX       LR               ;; return
   1251          }
   1252          
   1253          
   1254          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1255          static
   1256          void st_clust (
   1257          	BYTE *dir,	/* Pointer to the directory entry */
   1258          	DWORD cl	/* Value to be set */
   1259          )
   1260          {
   1261          	ST_WORD(dir+DIR_FstClusLO, cl);
   \                     st_clust:
   \   00000000   0x7681             STRB     R1,[R0, #+26]
   \   00000002   0x000A             MOVS     R2,R1
   \   00000004   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000006   0x0A12             LSRS     R2,R2,#+8
   \   00000008   0x76C2             STRB     R2,[R0, #+27]
   1262          	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   \   0000000A   0x0C0A             LSRS     R2,R1,#+16
   \   0000000C   0x7502             STRB     R2,[R0, #+20]
   \   0000000E   0x0C09             LSRS     R1,R1,#+16
   \   00000010   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000012   0x0A09             LSRS     R1,R1,#+8
   \   00000014   0x7541             STRB     R1,[R0, #+21]
   1263          }
   \   00000016   0x4770             BX       LR               ;; return
   1264          #endif
   1265          
   1266          
   1267          
   1268          /*-----------------------------------------------------------------------*/
   1269          /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
   1270          /*-----------------------------------------------------------------------*/
   1271          #if _USE_LFN
   1272          static

   \                                 In section .rodata, align 4
   1273          const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
   \                     LfnOfs:
   \   00000000   0x01 0x03          DC8 1, 3, 5, 7, 9, 14, 16, 18, 20, 22, 24, 28, 30, 0, 0, 0
   \              0x05 0x07    
   \              0x09 0x0E    
   \              0x10 0x12    
   \              0x14 0x16    
   \              0x18 0x1C    
   \              0x1E 0x00    
   \              0x00 0x00    
   1274          
   1275          

   \                                 In section .text, align 2, keep-with-next
   1276          static
   1277          int cmp_lfn (			/* 1:Matched, 0:Not matched */
   1278          	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
   1279          	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
   1280          )
   1281          {
   \                     cmp_lfn:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1282          	UINT i, s;
   1283          	WCHAR wc, uc;
   1284          
   1285          
   1286          	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x210D             MOVS     R1,#+13
   \   00000012   0xFB01 0xF600      MUL      R6,R1,R0
   1287          	s = 0; wc = 1;
   \   00000016   0x2700             MOVS     R7,#+0
   \   00000018   0xF05F 0x0801      MOVS     R8,#+1
   1288          	do {
   1289          		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
   \                     ??cmp_lfn_0:
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000020   0x5C38             LDRB     R0,[R7, R0]
   \   00000022   0x1940             ADDS     R0,R0,R5
   \   00000024   0x7840             LDRB     R0,[R0, #+1]
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable9
   \   0000002A   0x5C79             LDRB     R1,[R7, R1]
   \   0000002C   0x5D49             LDRB     R1,[R1, R5]
   \   0000002E   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   1290          		if (wc) {	/* Last char has not been processed */
   \   00000032   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000036   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000003A   0xD011             BEQ.N    ??cmp_lfn_1
   1291          			wc = ff_wtoupper(uc);		/* Convert it to upper case */
   \   0000003C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003E   0x.... 0x....      BL       ff_wtoupper
   \   00000042   0x4680             MOV      R8,R0
   1292          			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
   \   00000044   0x2E40             CMP      R6,#+64
   \   00000046   0xD209             BCS.N    ??cmp_lfn_2
   \   00000048   0xF834 0x0016      LDRH     R0,[R4, R6, LSL #+1]
   \   0000004C   0x.... 0x....      BL       ff_wtoupper
   \   00000050   0x1C76             ADDS     R6,R6,#+1
   \   00000052   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000056   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000058   0x4580             CMP      R8,R0
   \   0000005A   0xD008             BEQ.N    ??cmp_lfn_3
   1293          				return 0;				/* Not matched */
   \                     ??cmp_lfn_2:
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE018             B.N      ??cmp_lfn_4
   1294          		} else {
   1295          			if (uc != 0xFFFF) return 0;	/* Check filler */
   \                     ??cmp_lfn_1:
   \   00000060   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000064   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000066   0x4288             CMP      R0,R1
   \   00000068   0xD001             BEQ.N    ??cmp_lfn_3
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xE011             B.N      ??cmp_lfn_4
   1296          		}
   1297          	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
   \                     ??cmp_lfn_3:
   \   0000006E   0x1C7F             ADDS     R7,R7,#+1
   \   00000070   0x2F0D             CMP      R7,#+13
   \   00000072   0xD3D3             BCC.N    ??cmp_lfn_0
   1298          
   1299          	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
   \   00000074   0x7828             LDRB     R0,[R5, #+0]
   \   00000076   0x0640             LSLS     R0,R0,#+25
   \   00000078   0xD50A             BPL.N    ??cmp_lfn_5
   \   0000007A   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000007E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000082   0xD005             BEQ.N    ??cmp_lfn_5
   \   00000084   0xF834 0x0016      LDRH     R0,[R4, R6, LSL #+1]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD001             BEQ.N    ??cmp_lfn_5
   1300          		return 0;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xE000             B.N      ??cmp_lfn_4
   1301          
   1302          	return 1;						/* The part of LFN matched */
   \                     ??cmp_lfn_5:
   \   00000090   0x2001             MOVS     R0,#+1
   \                     ??cmp_lfn_4:
   \   00000092   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1303          }
   1304          
   1305          
   1306          

   \                                 In section .text, align 2, keep-with-next
   1307          static
   1308          int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
   1309          	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
   1310          	BYTE *dir			/* Pointer to the directory entry */
   1311          )
   1312          {
   \                     pick_lfn:
   \   00000000   0xB470             PUSH     {R4-R6}
   1313          	UINT i, s;
   1314          	WCHAR wc, uc;
   1315          
   1316          
   1317          	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
   \   00000002   0x780A             LDRB     R2,[R1, #+0]
   \   00000004   0xF012 0x023F      ANDS     R2,R2,#0x3F
   \   00000008   0x1E52             SUBS     R2,R2,#+1
   \   0000000A   0x230D             MOVS     R3,#+13
   \   0000000C   0x435A             MULS     R2,R3,R2
   1318          
   1319          	s = 0; wc = 1;
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x2401             MOVS     R4,#+1
   1320          	do {
   1321          		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
   \                     ??pick_lfn_0:
   \   00000012   0x.... 0x....      LDR.W    R5,??DataTable9
   \   00000016   0x5D5D             LDRB     R5,[R3, R5]
   \   00000018   0x186D             ADDS     R5,R5,R1
   \   0000001A   0x786D             LDRB     R5,[R5, #+1]
   \   0000001C   0x.... 0x....      LDR.W    R6,??DataTable9
   \   00000020   0x5D9E             LDRB     R6,[R3, R6]
   \   00000022   0x5C76             LDRB     R6,[R6, R1]
   \   00000024   0xEA56 0x2505      ORRS     R5,R6,R5, LSL #+8
   1322          		if (wc) {	/* Last char has not been processed */
   \   00000028   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD011             BEQ.N    ??pick_lfn_1
   1323          			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
   \   0000002E   0x2A40             CMP      R2,#+64
   \   00000030   0xD301             BCC.N    ??pick_lfn_2
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xE018             B.N      ??pick_lfn_3
   1324          			lfnbuf[i++] = wc = uc;			/* Store it */
   \                     ??pick_lfn_2:
   \   00000036   0x002C             MOVS     R4,R5
   \   00000038   0xF820 0x4012      STRH     R4,[R0, R2, LSL #+1]
   \   0000003C   0x1C52             ADDS     R2,R2,#+1
   1325          		} else {
   1326          			if (uc != 0xFFFF) return 0;		/* Check filler */
   1327          		}
   1328          	} while (++s < 13);						/* Read all character in the entry */
   \                     ??pick_lfn_4:
   \   0000003E   0x1C5B             ADDS     R3,R3,#+1
   \   00000040   0x2B0D             CMP      R3,#+13
   \   00000042   0xD3E6             BCC.N    ??pick_lfn_0
   1329          
   1330          	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
   \   00000044   0x7809             LDRB     R1,[R1, #+0]
   \   00000046   0x0649             LSLS     R1,R1,#+25
   \   00000048   0xD50D             BPL.N    ??pick_lfn_5
   1331          		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
   \   0000004A   0x2A40             CMP      R2,#+64
   \   0000004C   0xD308             BCC.N    ??pick_lfn_6
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE00A             B.N      ??pick_lfn_3
   \                     ??pick_lfn_1:
   \   00000052   0xF64F 0x76FF      MOVW     R6,#+65535
   \   00000056   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000058   0x42B5             CMP      R5,R6
   \   0000005A   0xD0F0             BEQ.N    ??pick_lfn_4
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE003             B.N      ??pick_lfn_3
   1332          		lfnbuf[i] = 0;
   \                     ??pick_lfn_6:
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0xF820 0x1012      STRH     R1,[R0, R2, LSL #+1]
   1333          	}
   1334          
   1335          	return 1;
   \                     ??pick_lfn_5:
   \   00000066   0x2001             MOVS     R0,#+1
   \                     ??pick_lfn_3:
   \   00000068   0xBC70             POP      {R4-R6}
   \   0000006A   0x4770             BX       LR               ;; return
   1336          }
   1337          
   1338          
   1339          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1340          static
   1341          void fit_lfn (
   1342          	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
   1343          	BYTE *dir,				/* Pointer to the directory entry */
   1344          	BYTE ord,				/* LFN order (1-20) */
   1345          	BYTE sum				/* SFN sum */
   1346          )
   1347          {
   \                     fit_lfn:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1348          	UINT i, s;
   1349          	WCHAR wc;
   1350          
   1351          
   1352          	dir[LDIR_Chksum] = sum;			/* Set check sum */
   \   00000002   0x734B             STRB     R3,[R1, #+13]
   1353          	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
   \   00000004   0x230F             MOVS     R3,#+15
   \   00000006   0x72CB             STRB     R3,[R1, #+11]
   1354          	dir[LDIR_Type] = 0;
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x730B             STRB     R3,[R1, #+12]
   1355          	ST_WORD(dir+LDIR_FstClusLO, 0);
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x768B             STRB     R3,[R1, #+26]
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x76CB             STRB     R3,[R1, #+27]
   1356          
   1357          	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
   \   00000014   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000016   0x1E53             SUBS     R3,R2,#+1
   \   00000018   0x240D             MOVS     R4,#+13
   \   0000001A   0x4363             MULS     R3,R4,R3
   1358          	s = wc = 0;
   \   0000001C   0x2400             MOVS     R4,#+0
   \   0000001E   0x0025             MOVS     R5,R4
   \   00000020   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   1359          	do {
   1360          		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
   \                     ??fit_lfn_0:
   \   00000022   0xF64F 0x76FF      MOVW     R6,#+65535
   \   00000026   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000028   0x42B5             CMP      R5,R6
   \   0000002A   0xD002             BEQ.N    ??fit_lfn_1
   \   0000002C   0xF830 0x5013      LDRH     R5,[R0, R3, LSL #+1]
   \   00000030   0x1C5B             ADDS     R3,R3,#+1
   1361          		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
   \                     ??fit_lfn_1:
   \   00000032   0x.... 0x....      LDR.W    R6,??DataTable9
   \   00000036   0x5DA6             LDRB     R6,[R4, R6]
   \   00000038   0x5475             STRB     R5,[R6, R1]
   \   0000003A   0x.... 0x....      LDR.W    R6,??DataTable9
   \   0000003E   0x5DA6             LDRB     R6,[R4, R6]
   \   00000040   0x1876             ADDS     R6,R6,R1
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0x0A2F             LSRS     R7,R5,#+8
   \   00000046   0x7077             STRB     R7,[R6, #+1]
   1362          		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
   \   00000048   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD101             BNE.N    ??fit_lfn_2
   \   0000004E   0xF64F 0x75FF      MOVW     R5,#+65535
   1363          	} while (++s < 13);
   \                     ??fit_lfn_2:
   \   00000052   0x1C64             ADDS     R4,R4,#+1
   \   00000054   0x2C0D             CMP      R4,#+13
   \   00000056   0xD3E4             BCC.N    ??fit_lfn_0
   1364          	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
   \   00000058   0xF64F 0x74FF      MOVW     R4,#+65535
   \   0000005C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005E   0x42A5             CMP      R5,R4
   \   00000060   0xD003             BEQ.N    ??fit_lfn_3
   \   00000062   0xF830 0x0013      LDRH     R0,[R0, R3, LSL #+1]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD101             BNE.N    ??fit_lfn_4
   \                     ??fit_lfn_3:
   \   0000006A   0xF052 0x0240      ORRS     R2,R2,#0x40
   1365          	dir[LDIR_Ord] = ord;			/* Set the LFN order */
   \                     ??fit_lfn_4:
   \   0000006E   0x700A             STRB     R2,[R1, #+0]
   1366          }
   \   00000070   0xBCF0             POP      {R4-R7}
   \   00000072   0x4770             BX       LR               ;; return
   1367          
   1368          #endif
   1369          #endif
   1370          
   1371          
   1372          
   1373          /*-----------------------------------------------------------------------*/
   1374          /* Create numbered name                                                  */
   1375          /*-----------------------------------------------------------------------*/
   1376          #if _USE_LFN

   \                                 In section .text, align 2, keep-with-next
   1377          void gen_numname (
   1378          	BYTE *dst,			/* Pointer to generated SFN */
   1379          	const BYTE *src,	/* Pointer to source SFN to be modified */
   1380          	const WCHAR *lfn,	/* Pointer to LFN */
   1381          	WORD seq			/* Sequence number */
   1382          )
   1383          {
   \                     gen_numname:
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0016             MOVS     R6,R2
   \   00000006   0x001D             MOVS     R5,R3
   1384          	BYTE ns[8], c;
   1385          	UINT i, j;
   1386          
   1387          
   1388          	mem_cpy(dst, src, 11);
   \   00000008   0x220B             MOVS     R2,#+11
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       mem_cpy
   1389          
   1390          	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
   \   00000010   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000012   0x2D06             CMP      R5,#+6
   \   00000014   0xD309             BCC.N    ??gen_numname_0
   1391          		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
   \                     ??gen_numname_1:
   \   00000016   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000018   0x03E8             LSLS     R0,R5,#+15
   \   0000001A   0xEB10 0x0055      ADDS     R0,R0,R5, LSR #+1
   \   0000001E   0x8831             LDRH     R1,[R6, #+0]
   \   00000020   0x180D             ADDS     R5,R1,R0
   \   00000022   0x1CB6             ADDS     R6,R6,#+2
   \   00000024   0x8830             LDRH     R0,[R6, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD1F5             BNE.N    ??gen_numname_1
   1392          	}
   1393          
   1394          	/* itoa (hexdecimal) */
   1395          	i = 7;
   \                     ??gen_numname_0:
   \   0000002A   0x2007             MOVS     R0,#+7
   1396          	do {
   1397          		c = (seq % 16) + '0';
   \                     ??gen_numname_2:
   \   0000002C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002E   0x2110             MOVS     R1,#+16
   \   00000030   0xFB95 0xF2F1      SDIV     R2,R5,R1
   \   00000034   0xFB02 0x5211      MLS      R2,R2,R1,R5
   \   00000038   0xF112 0x0130      ADDS     R1,R2,#+48
   1398          		if (c > '9') c += 7;
   \   0000003C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003E   0x293A             CMP      R1,#+58
   \   00000040   0xD300             BCC.N    ??gen_numname_3
   \   00000042   0x1DC9             ADDS     R1,R1,#+7
   1399          		ns[i--] = c;
   \                     ??gen_numname_3:
   \   00000044   0xAA00             ADD      R2,SP,#+0
   \   00000046   0x5481             STRB     R1,[R0, R2]
   \   00000048   0x1E40             SUBS     R0,R0,#+1
   1400          		seq /= 16;
   \   0000004A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004C   0x2110             MOVS     R1,#+16
   \   0000004E   0xFB95 0xF5F1      SDIV     R5,R5,R1
   1401          	} while (seq);
   \   00000052   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000054   0x2D00             CMP      R5,#+0
   \   00000056   0xD1E9             BNE.N    ??gen_numname_2
   1402          	ns[i] = '~';
   \   00000058   0xA900             ADD      R1,SP,#+0
   \   0000005A   0x227E             MOVS     R2,#+126
   \   0000005C   0x5442             STRB     R2,[R0, R1]
   1403          
   1404          	/* Append the number */
   1405          	for (j = 0; j < i && dst[j] != ' '; j++) {
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0xE000             B.N      ??gen_numname_4
   1406          		if (IsDBCS1(dst[j])) {
   \                     ??gen_numname_5:
   \   00000062   0x1C49             ADDS     R1,R1,#+1
   \                     ??gen_numname_4:
   \   00000064   0x4281             CMP      R1,R0
   \   00000066   0xD202             BCS.N    ??gen_numname_6
   \   00000068   0x5D0A             LDRB     R2,[R1, R4]
   \   0000006A   0x2A20             CMP      R2,#+32
   \   0000006C   0xD1F9             BNE.N    ??gen_numname_5
   1407          			if (j == i - 1) break;
   1408          			j++;
   1409          		}
   1410          	}
   1411          	do {
   1412          		dst[j++] = (i < 8) ? ns[i++] : ' ';
   \                     ??gen_numname_6:
   \   0000006E   0x000A             MOVS     R2,R1
   \   00000070   0x1C51             ADDS     R1,R2,#+1
   \   00000072   0x2808             CMP      R0,#+8
   \   00000074   0xD203             BCS.N    ??gen_numname_7
   \   00000076   0xAB00             ADD      R3,SP,#+0
   \   00000078   0x5CC3             LDRB     R3,[R0, R3]
   \   0000007A   0x1C40             ADDS     R0,R0,#+1
   \   0000007C   0xE000             B.N      ??gen_numname_8
   \                     ??gen_numname_7:
   \   0000007E   0x2320             MOVS     R3,#+32
   \                     ??gen_numname_8:
   \   00000080   0x5513             STRB     R3,[R2, R4]
   1413          	} while (j < 8);
   \   00000082   0x2908             CMP      R1,#+8
   \   00000084   0xD3F3             BCC.N    ??gen_numname_6
   1414          }
   \   00000086   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   1415          #endif
   1416          
   1417          
   1418          
   1419          
   1420          /*-----------------------------------------------------------------------*/
   1421          /* Calculate sum of an SFN                                               */
   1422          /*-----------------------------------------------------------------------*/
   1423          #if _USE_LFN

   \                                 In section .text, align 2, keep-with-next
   1424          static
   1425          BYTE sum_sfn (
   1426          	const BYTE *dir		/* Ptr to directory entry */
   1427          )
   1428          {
   1429          	BYTE sum = 0;
   \                     sum_sfn:
   \   00000000   0x2100             MOVS     R1,#+0
   1430          	UINT n = 11;
   \   00000002   0x220B             MOVS     R2,#+11
   1431          
   1432          	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
   \                     ??sum_sfn_0:
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x01CB             LSLS     R3,R1,#+7
   \   00000008   0xEB13 0x0151      ADDS     R1,R3,R1, LSR #+1
   \   0000000C   0x7803             LDRB     R3,[R0, #+0]
   \   0000000E   0x1859             ADDS     R1,R3,R1
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   \   00000012   0x1E52             SUBS     R2,R2,#+1
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD1F5             BNE.N    ??sum_sfn_0
   1433          	return sum;
   \   00000018   0x0008             MOVS     R0,R1
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x4770             BX       LR               ;; return
   1434          }
   1435          #endif
   1436          
   1437          
   1438          
   1439          
   1440          /*-----------------------------------------------------------------------*/
   1441          /* Directory handling - Find an object in the directory                  */
   1442          /*-----------------------------------------------------------------------*/
   1443          

   \                                 In section .text, align 2, keep-with-next
   1444          static
   1445          FRESULT dir_find (
   1446          	DIR *dj			/* Pointer to the directory object linked to the file name */
   1447          )
   1448          {
   \                     dir_find:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0005             MOVS     R5,R0
   1449          	FRESULT res;
   1450          	BYTE c, *dir;
   1451          #if _USE_LFN
   1452          	BYTE a, ord, sum;
   1453          #endif
   1454          
   1455          	res = dir_sdi(dj, 0);			/* Rewind directory object */
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0028             MOVS     R0,R5
   \   0000000A   0x.... 0x....      BL       dir_sdi
   \   0000000E   0x0004             MOVS     R4,R0
   1456          	if (res != FR_OK) return res;
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD002             BEQ.N    ??dir_find_0
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xE026             B.N      ??dir_find_1
   1457          
   1458          #if _USE_LFN
   1459          	ord = sum = 0xFF;
   \                     ??dir_find_0:
   \   0000001C   0x27FF             MOVS     R7,#+255
   \   0000001E   0x46B8             MOV      R8,R7
   1460          #endif
   1461          	do {
   1462          		res = move_window(dj->fs, dj->sect);
   \                     ??dir_find_2:
   \   00000020   0x6929             LDR      R1,[R5, #+16]
   \   00000022   0x6828             LDR      R0,[R5, #+0]
   \   00000024   0x.... 0x....      BL       move_window
   \   00000028   0x0004             MOVS     R4,R0
   1463          		if (res != FR_OK) break;
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD11A             BNE.N    ??dir_find_3
   1464          		dir = dj->dir;					/* Ptr to the directory entry of current index */
   \                     ??dir_find_4:
   \   00000030   0x696E             LDR      R6,[R5, #+20]
   1465          		c = dir[DIR_Name];
   \   00000032   0x7830             LDRB     R0,[R6, #+0]
   1466          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD101             BNE.N    ??dir_find_5
   \   0000003A   0x2404             MOVS     R4,#+4
   \   0000003C   0xE013             B.N      ??dir_find_3
   1467          #if _USE_LFN	/* LFN configuration */
   1468          		a = dir[DIR_Attr] & AM_MASK;
   \                     ??dir_find_5:
   \   0000003E   0x7AF1             LDRB     R1,[R6, #+11]
   \   00000040   0xF011 0x013F      ANDS     R1,R1,#0x3F
   1469          		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x28E5             CMP      R0,#+229
   \   00000048   0xD004             BEQ.N    ??dir_find_6
   \   0000004A   0x070A             LSLS     R2,R1,#+28
   \   0000004C   0xD50F             BPL.N    ??dir_find_7
   \   0000004E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000050   0x290F             CMP      R1,#+15
   \   00000052   0xD00C             BEQ.N    ??dir_find_7
   1470          			ord = 0xFF;
   \                     ??dir_find_6:
   \   00000054   0x27FF             MOVS     R7,#+255
   1471          		} else {
   1472          			if (a == AM_LFN) {			/* An LFN entry is found */
   1473          				if (dj->lfn) {
   1474          					if (c & LLE) {		/* Is it start of LFN sequence? */
   1475          						sum = dir[LDIR_Chksum];
   1476          						c &= ~LLE; ord = c;	/* LFN start order */
   1477          						dj->lfn_idx = dj->index;
   1478          					}
   1479          					/* Check validity of the LFN entry and compare it with given name */
   1480          					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   1481          				}
   1482          			} else {					/* An SFN entry is found */
   1483          				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
   1484          				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   1485          				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
   1486          			}
   1487          		}
   1488          #else		/* Non LFN configuration */
   1489          		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
   1490          			break;
   1491          #endif
   1492          		res = dir_next(dj, 0);		/* Next entry */
   \                     ??dir_find_8:
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x0028             MOVS     R0,R5
   \   0000005A   0x.... 0x....      BL       dir_next
   \   0000005E   0x0004             MOVS     R4,R0
   1493          	} while (res == FR_OK);
   \   00000060   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000062   0x2C00             CMP      R4,#+0
   \   00000064   0xD0DC             BEQ.N    ??dir_find_2
   1494          
   1495          	return res;
   \                     ??dir_find_3:
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??dir_find_1:
   \   0000006A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??dir_find_7:
   \   0000006E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000070   0x290F             CMP      R1,#+15
   \   00000072   0xD11E             BNE.N    ??dir_find_9
   \   00000074   0x69E9             LDR      R1,[R5, #+28]
   \   00000076   0x2900             CMP      R1,#+0
   \   00000078   0xD0ED             BEQ.N    ??dir_find_8
   \   0000007A   0x0641             LSLS     R1,R0,#+25
   \   0000007C   0xD506             BPL.N    ??dir_find_10
   \   0000007E   0xF896 0x800D      LDRB     R8,[R6, #+13]
   \   00000082   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   00000086   0x0007             MOVS     R7,R0
   \   00000088   0x88E9             LDRH     R1,[R5, #+6]
   \   0000008A   0x8429             STRH     R1,[R5, #+32]
   \                     ??dir_find_10:
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000090   0x42B8             CMP      R0,R7
   \   00000092   0xD10C             BNE.N    ??dir_find_11
   \   00000094   0x7B70             LDRB     R0,[R6, #+13]
   \   00000096   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000009A   0x4580             CMP      R8,R0
   \   0000009C   0xD107             BNE.N    ??dir_find_11
   \   0000009E   0x0031             MOVS     R1,R6
   \   000000A0   0x69E8             LDR      R0,[R5, #+28]
   \   000000A2   0x.... 0x....      BL       cmp_lfn
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD001             BEQ.N    ??dir_find_11
   \   000000AA   0x1E7F             SUBS     R7,R7,#+1
   \   000000AC   0xE000             B.N      ??dir_find_12
   \                     ??dir_find_11:
   \   000000AE   0x27FF             MOVS     R7,#+255
   \                     ??dir_find_12:
   \   000000B0   0xE7D1             B.N      ??dir_find_8
   \                     ??dir_find_9:
   \   000000B2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000B4   0x2F00             CMP      R7,#+0
   \   000000B6   0xD106             BNE.N    ??dir_find_13
   \   000000B8   0x0030             MOVS     R0,R6
   \   000000BA   0x.... 0x....      BL       sum_sfn
   \   000000BE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000C2   0x4580             CMP      R8,R0
   \   000000C4   0xD0CF             BEQ.N    ??dir_find_3
   \                     ??dir_find_13:
   \   000000C6   0x27FF             MOVS     R7,#+255
   \   000000C8   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000CC   0x8428             STRH     R0,[R5, #+32]
   \   000000CE   0x69A8             LDR      R0,[R5, #+24]
   \   000000D0   0x7AC0             LDRB     R0,[R0, #+11]
   \   000000D2   0x07C0             LSLS     R0,R0,#+31
   \   000000D4   0xD4BF             BMI.N    ??dir_find_8
   \   000000D6   0x220B             MOVS     R2,#+11
   \   000000D8   0x69A9             LDR      R1,[R5, #+24]
   \   000000DA   0x0030             MOVS     R0,R6
   \   000000DC   0x.... 0x....      BL       mem_cmp
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD1B8             BNE.N    ??dir_find_8
   \   000000E4   0xE7BF             B.N      ??dir_find_3
   1496          }
   1497          
   1498          
   1499          
   1500          
   1501          /*-----------------------------------------------------------------------*/
   1502          /* Read an object from the directory                                     */
   1503          /*-----------------------------------------------------------------------*/
   1504          #if _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2

   \                                 In section .text, align 2, keep-with-next
   1505          static
   1506          FRESULT dir_read (
   1507          	DIR *dj,		/* Pointer to the directory object */
   1508          	int vol			/* Filtered by 0:file/dir or 1:volume label */
   1509          )
   1510          {
   \                     dir_read:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1511          	FRESULT res;
   1512          	BYTE a, c, *dir;
   1513          #if _USE_LFN
   1514          	BYTE ord = 0xFF, sum = 0xFF;
   \   00000008   0x26FF             MOVS     R6,#+255
   \   0000000A   0x27FF             MOVS     R7,#+255
   1515          #endif
   1516          
   1517          	res = FR_NO_FILE;
   \   0000000C   0xF05F 0x0804      MOVS     R8,#+4
   1518          	while (dj->sect) {
   \                     ??dir_read_0:
   \   00000010   0x6920             LDR      R0,[R4, #+16]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD02B             BEQ.N    ??dir_read_1
   1519          		res = move_window(dj->fs, dj->sect);
   \   00000016   0x6921             LDR      R1,[R4, #+16]
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x.... 0x....      BL       move_window
   \   0000001E   0x4680             MOV      R8,R0
   1520          		if (res != FR_OK) break;
   \   00000020   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000024   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000028   0xD121             BNE.N    ??dir_read_1
   1521          		dir = dj->dir;					/* Ptr to the directory entry of current index */
   \                     ??dir_read_2:
   \   0000002A   0x6960             LDR      R0,[R4, #+20]
   1522          		c = dir[DIR_Name];
   \   0000002C   0x7802             LDRB     R2,[R0, #+0]
   1523          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   \   0000002E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000030   0x2A00             CMP      R2,#+0
   \   00000032   0xD102             BNE.N    ??dir_read_3
   \   00000034   0xF05F 0x0804      MOVS     R8,#+4
   \   00000038   0xE019             B.N      ??dir_read_1
   1524          		a = dir[DIR_Attr] & AM_MASK;
   \                     ??dir_read_3:
   \   0000003A   0x7AC1             LDRB     R1,[R0, #+11]
   \   0000003C   0xF011 0x013F      ANDS     R1,R1,#0x3F
   1525          #if _USE_LFN	/* LFN configuration */
   1526          		if (c == DDE || (!_FS_RPATH && c == '.') || (a == AM_VOL) != vol) {	/* An entry without valid data */
   \   00000040   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000042   0x2AE5             CMP      R2,#+229
   \   00000044   0xD008             BEQ.N    ??dir_read_4
   \   00000046   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000048   0x2908             CMP      R1,#+8
   \   0000004A   0xD101             BNE.N    ??dir_read_5
   \   0000004C   0x2301             MOVS     R3,#+1
   \   0000004E   0xE000             B.N      ??dir_read_6
   \                     ??dir_read_5:
   \   00000050   0x2300             MOVS     R3,#+0
   \                     ??dir_read_6:
   \   00000052   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000054   0x42AB             CMP      R3,R5
   \   00000056   0xD015             BEQ.N    ??dir_read_7
   1527          			ord = 0xFF;
   \                     ??dir_read_4:
   \   00000058   0x26FF             MOVS     R6,#+255
   1528          		} else {
   1529          			if (a == AM_LFN) {			/* An LFN entry is found */
   1530          				if (c & LLE) {			/* Is it start of LFN sequence? */
   1531          					sum = dir[LDIR_Chksum];
   1532          					c &= ~LLE; ord = c;
   1533          					dj->lfn_idx = dj->index;
   1534          				}
   1535          				/* Check LFN validity and capture it */
   1536          				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   1537          			} else {					/* An SFN entry is found */
   1538          				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
   1539          					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
   1540          				break;
   1541          			}
   1542          		}
   1543          #else		/* Non LFN configuration */
   1544          		if (c != DDE && (_FS_RPATH || c != '.') && a != AM_LFN && (a == AM_VOL) == vol)	/* Is it a valid entry? */
   1545          			break;
   1546          #endif
   1547          		res = dir_next(dj, 0);				/* Next entry */
   \                     ??dir_read_8:
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x.... 0x....      BL       dir_next
   \   00000062   0x4680             MOV      R8,R0
   1548          		if (res != FR_OK) break;
   \   00000064   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000068   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000006C   0xD0D0             BEQ.N    ??dir_read_0
   1549          	}
   1550          
   1551          	if (res != FR_OK) dj->sect = 0;
   \                     ??dir_read_1:
   \   0000006E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000072   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000076   0xD001             BEQ.N    ??dir_read_9
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x6120             STR      R0,[R4, #+16]
   1552          
   1553          	return res;
   \                     ??dir_read_9:
   \   0000007C   0x4640             MOV      R0,R8
   \   0000007E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000080   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??dir_read_7:
   \   00000084   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000086   0x290F             CMP      R1,#+15
   \   00000088   0xD119             BNE.N    ??dir_read_10
   \   0000008A   0x0651             LSLS     R1,R2,#+25
   \   0000008C   0xD505             BPL.N    ??dir_read_11
   \   0000008E   0x7B47             LDRB     R7,[R0, #+13]
   \   00000090   0xF012 0x02BF      ANDS     R2,R2,#0xBF
   \   00000094   0x0016             MOVS     R6,R2
   \   00000096   0x88E1             LDRH     R1,[R4, #+6]
   \   00000098   0x8421             STRH     R1,[R4, #+32]
   \                     ??dir_read_11:
   \   0000009A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000009C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009E   0x42B2             CMP      R2,R6
   \   000000A0   0xD10B             BNE.N    ??dir_read_12
   \   000000A2   0x7B41             LDRB     R1,[R0, #+13]
   \   000000A4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000A6   0x428F             CMP      R7,R1
   \   000000A8   0xD107             BNE.N    ??dir_read_12
   \   000000AA   0x0001             MOVS     R1,R0
   \   000000AC   0x69E0             LDR      R0,[R4, #+28]
   \   000000AE   0x.... 0x....      BL       pick_lfn
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD001             BEQ.N    ??dir_read_12
   \   000000B6   0x1E76             SUBS     R6,R6,#+1
   \   000000B8   0xE000             B.N      ??dir_read_13
   \                     ??dir_read_12:
   \   000000BA   0x26FF             MOVS     R6,#+255
   \                     ??dir_read_13:
   \   000000BC   0xE7CD             B.N      ??dir_read_8
   \                     ??dir_read_10:
   \   000000BE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000C0   0x2E00             CMP      R6,#+0
   \   000000C2   0xD104             BNE.N    ??dir_read_14
   \   000000C4   0x.... 0x....      BL       sum_sfn
   \   000000C8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000CA   0x4287             CMP      R7,R0
   \   000000CC   0xD002             BEQ.N    ??dir_read_15
   \                     ??dir_read_14:
   \   000000CE   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000D2   0x8420             STRH     R0,[R4, #+32]
   \                     ??dir_read_15:
   \   000000D4   0xE7CB             B.N      ??dir_read_1
   1554          }
   1555          #endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
   1556          
   1557          
   1558          
   1559          /*-----------------------------------------------------------------------*/
   1560          /* Register an object to the directory                                   */
   1561          /*-----------------------------------------------------------------------*/
   1562          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1563          static
   1564          FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
   1565          	DIR *dj				/* Target directory with object name to be created */
   1566          )
   1567          {
   \                     dir_register:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
   1568          	FRESULT res;
   1569          #if _USE_LFN	/* LFN configuration */
   1570          	WORD n, ne;
   1571          	BYTE sn[12], *fn, sum;
   1572          	WCHAR *lfn;
   1573          
   1574          
   1575          	fn = dj->fn; lfn = dj->lfn;
   \   00000008   0x69A6             LDR      R6,[R4, #+24]
   \   0000000A   0x69E7             LDR      R7,[R4, #+28]
   1576          	mem_cpy(sn, fn, 12);
   \   0000000C   0x220C             MOVS     R2,#+12
   \   0000000E   0x0031             MOVS     R1,R6
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x.... 0x....      BL       mem_cpy
   1577          
   1578          	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
   \   00000016   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   0000001A   0x0680             LSLS     R0,R0,#+26
   \   0000001C   0xD501             BPL.N    ??dir_register_0
   1579          		return FR_INVALID_NAME;
   \   0000001E   0x2006             MOVS     R0,#+6
   \   00000020   0xE0A4             B.N      ??dir_register_1
   1580          
   1581          	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
   \                     ??dir_register_0:
   \   00000022   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   00000026   0x07C0             LSLS     R0,R0,#+31
   \   00000028   0xD52C             BPL.N    ??dir_register_2
   1582          		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x72F0             STRB     R0,[R6, #+11]
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x61E0             STR      R0,[R4, #+28]
   1583          		for (n = 1; n < 100; n++) {
   \   00000032   0xF05F 0x0801      MOVS     R8,#+1
   \   00000036   0xE001             B.N      ??dir_register_3
   \                     ??dir_register_4:
   \   00000038   0xF118 0x0801      ADDS     R8,R8,#+1
   \                     ??dir_register_3:
   \   0000003C   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000040   0xF1B8 0x0F64      CMP      R8,#+100
   \   00000044   0xD20D             BCS.N    ??dir_register_5
   1584          			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
   \   00000046   0x4643             MOV      R3,R8
   \   00000048   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000004A   0x003A             MOVS     R2,R7
   \   0000004C   0xA900             ADD      R1,SP,#+0
   \   0000004E   0x0030             MOVS     R0,R6
   \   00000050   0x.... 0x....      BL       gen_numname
   1585          			res = dir_find(dj);				/* Check if the name collides with existing SFN */
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       dir_find
   \   0000005A   0x0005             MOVS     R5,R0
   1586          			if (res != FR_OK) break;
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0x2D00             CMP      R5,#+0
   \   00000060   0xD0EA             BEQ.N    ??dir_register_4
   1587          		}
   1588          		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
   \                     ??dir_register_5:
   \   00000062   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000066   0xF1B8 0x0F64      CMP      R8,#+100
   \   0000006A   0xD101             BNE.N    ??dir_register_6
   \   0000006C   0x2007             MOVS     R0,#+7
   \   0000006E   0xE07D             B.N      ??dir_register_1
   1589          		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
   \                     ??dir_register_6:
   \   00000070   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000072   0x2D04             CMP      R5,#+4
   \   00000074   0xD002             BEQ.N    ??dir_register_7
   \   00000076   0x0028             MOVS     R0,R5
   \   00000078   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007A   0xE077             B.N      ??dir_register_1
   1590          		fn[NS] = sn[NS]; dj->lfn = lfn;
   \                     ??dir_register_7:
   \   0000007C   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   00000080   0x72F0             STRB     R0,[R6, #+11]
   \   00000082   0x61E7             STR      R7,[R4, #+28]
   1591          	}
   1592          
   1593          	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
   \                     ??dir_register_2:
   \   00000084   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   00000088   0x0780             LSLS     R0,R0,#+30
   \   0000008A   0xD512             BPL.N    ??dir_register_8
   1594          		for (n = 0; lfn[n]; n++) ;
   \   0000008C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000090   0xE001             B.N      ??dir_register_9
   \                     ??dir_register_10:
   \   00000092   0xF118 0x0801      ADDS     R8,R8,#+1
   \                     ??dir_register_9:
   \   00000096   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000009A   0xF837 0x0018      LDRH     R0,[R7, R8, LSL #+1]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD1F7             BNE.N    ??dir_register_10
   1595          		ne = (n + 25) / 13;
   \   000000A2   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000A6   0xF118 0x0019      ADDS     R0,R8,#+25
   \   000000AA   0x210D             MOVS     R1,#+13
   \   000000AC   0xFB90 0xF6F1      SDIV     R6,R0,R1
   \   000000B0   0xE000             B.N      ??dir_register_11
   1596          	} else {						/* Otherwise allocate an entry for an SFN  */
   1597          		ne = 1;
   \                     ??dir_register_8:
   \   000000B2   0x2601             MOVS     R6,#+1
   1598          	}
   1599          	res = dir_alloc(dj, ne);		/* Allocate entries */
   \                     ??dir_register_11:
   \   000000B4   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000B6   0x0031             MOVS     R1,R6
   \   000000B8   0x0020             MOVS     R0,R4
   \   000000BA   0x.... 0x....      BL       dir_alloc
   \   000000BE   0x0005             MOVS     R5,R0
   1600          
   1601          	if (res == FR_OK && --ne) {		/* Set LFN entry if needed */
   \   000000C0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C2   0x2D00             CMP      R5,#+0
   \   000000C4   0xD132             BNE.N    ??dir_register_12
   \   000000C6   0x1E76             SUBS     R6,R6,#+1
   \   000000C8   0x0030             MOVS     R0,R6
   \   000000CA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD02D             BEQ.N    ??dir_register_12
   1602          		res = dir_sdi(dj, (WORD)(dj->index - ne));
   \   000000D0   0x88E0             LDRH     R0,[R4, #+6]
   \   000000D2   0x1B81             SUBS     R1,R0,R6
   \   000000D4   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000D6   0x0020             MOVS     R0,R4
   \   000000D8   0x.... 0x....      BL       dir_sdi
   \   000000DC   0x0005             MOVS     R5,R0
   1603          		if (res == FR_OK) {
   \   000000DE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E0   0x2D00             CMP      R5,#+0
   \   000000E2   0xD123             BNE.N    ??dir_register_12
   1604          			sum = sum_sfn(dj->fn);	/* Sum value of the SFN tied to the LFN */
   \   000000E4   0x69A0             LDR      R0,[R4, #+24]
   \   000000E6   0x.... 0x....      BL       sum_sfn
   \   000000EA   0x0007             MOVS     R7,R0
   1605          			do {					/* Store LFN entries in bottom first */
   1606          				res = move_window(dj->fs, dj->sect);
   \                     ??dir_register_13:
   \   000000EC   0x6921             LDR      R1,[R4, #+16]
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0x.... 0x....      BL       move_window
   \   000000F4   0x0005             MOVS     R5,R0
   1607          				if (res != FR_OK) break;
   \   000000F6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F8   0x2D00             CMP      R5,#+0
   \   000000FA   0xD117             BNE.N    ??dir_register_12
   1608          				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
   \                     ??dir_register_14:
   \   000000FC   0x003B             MOVS     R3,R7
   \   000000FE   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000100   0x0032             MOVS     R2,R6
   \   00000102   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000104   0x6961             LDR      R1,[R4, #+20]
   \   00000106   0x69E0             LDR      R0,[R4, #+28]
   \   00000108   0x.... 0x....      BL       fit_lfn
   1609          				dj->fs->wflag = 1;
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0x2101             MOVS     R1,#+1
   \   00000110   0x7101             STRB     R1,[R0, #+4]
   1610          				res = dir_next(dj, 0);	/* Next entry */
   \   00000112   0x2100             MOVS     R1,#+0
   \   00000114   0x0020             MOVS     R0,R4
   \   00000116   0x.... 0x....      BL       dir_next
   \   0000011A   0x0005             MOVS     R5,R0
   1611          			} while (res == FR_OK && --ne);
   \   0000011C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000011E   0x2D00             CMP      R5,#+0
   \   00000120   0xD104             BNE.N    ??dir_register_12
   \   00000122   0x1E76             SUBS     R6,R6,#+1
   \   00000124   0x0030             MOVS     R0,R6
   \   00000126   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000128   0x2800             CMP      R0,#+0
   \   0000012A   0xD1DF             BNE.N    ??dir_register_13
   1612          		}
   1613          	}
   1614          #else	/* Non LFN configuration */
   1615          	res = dir_alloc(dj, 1);		/* Allocate an entry for SFN */
   1616          #endif
   1617          
   1618          	if (res == FR_OK) {				/* Set SFN entry */
   \                     ??dir_register_12:
   \   0000012C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000012E   0x2D00             CMP      R5,#+0
   \   00000130   0xD11A             BNE.N    ??dir_register_15
   1619          		res = move_window(dj->fs, dj->sect);
   \   00000132   0x6921             LDR      R1,[R4, #+16]
   \   00000134   0x6820             LDR      R0,[R4, #+0]
   \   00000136   0x.... 0x....      BL       move_window
   \   0000013A   0x0005             MOVS     R5,R0
   1620          		if (res == FR_OK) {
   \   0000013C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000013E   0x2D00             CMP      R5,#+0
   \   00000140   0xD112             BNE.N    ??dir_register_15
   1621          			mem_set(dj->dir, 0, SZ_DIR);	/* Clean the entry */
   \   00000142   0x2220             MOVS     R2,#+32
   \   00000144   0x2100             MOVS     R1,#+0
   \   00000146   0x6960             LDR      R0,[R4, #+20]
   \   00000148   0x.... 0x....      BL       mem_set
   1622          			mem_cpy(dj->dir, dj->fn, 11);	/* Put SFN */
   \   0000014C   0x220B             MOVS     R2,#+11
   \   0000014E   0x69A1             LDR      R1,[R4, #+24]
   \   00000150   0x6960             LDR      R0,[R4, #+20]
   \   00000152   0x.... 0x....      BL       mem_cpy
   1623          #if _USE_LFN
   1624          			dj->dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
   \   00000156   0x69A0             LDR      R0,[R4, #+24]
   \   00000158   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000015A   0xF010 0x0018      ANDS     R0,R0,#0x18
   \   0000015E   0x6961             LDR      R1,[R4, #+20]
   \   00000160   0x7308             STRB     R0,[R1, #+12]
   1625          #endif
   1626          			dj->fs->wflag = 1;
   \   00000162   0x6820             LDR      R0,[R4, #+0]
   \   00000164   0x2101             MOVS     R1,#+1
   \   00000166   0x7101             STRB     R1,[R0, #+4]
   1627          		}
   1628          	}
   1629          
   1630          	return res;
   \                     ??dir_register_15:
   \   00000168   0x0028             MOVS     R0,R5
   \   0000016A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??dir_register_1:
   \   0000016C   0xB004             ADD      SP,SP,#+16
   \   0000016E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1631          }
   1632          #endif /* !_FS_READONLY */
   1633          
   1634          
   1635          
   1636          
   1637          /*-----------------------------------------------------------------------*/
   1638          /* Remove an object from the directory                                   */
   1639          /*-----------------------------------------------------------------------*/
   1640          #if !_FS_READONLY && !_FS_MINIMIZE

   \                                 In section .text, align 2, keep-with-next
   1641          static
   1642          FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
   1643          	DIR *dj				/* Directory object pointing the entry to be removed */
   1644          )
   1645          {
   \                     dir_remove:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1646          	FRESULT res;
   1647          #if _USE_LFN	/* LFN configuration */
   1648          	WORD i;
   1649          
   1650          	i = dj->index;	/* SFN index */
   \   00000004   0x88E5             LDRH     R5,[R4, #+6]
   1651          	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
   \   00000006   0x8C20             LDRH     R0,[R4, #+32]
   \   00000008   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD101             BNE.N    ??dir_remove_0
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0xE000             B.N      ??dir_remove_1
   \                     ??dir_remove_0:
   \   00000014   0x8C21             LDRH     R1,[R4, #+32]
   \                     ??dir_remove_1:
   \   00000016   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       dir_sdi
   1652          	if (res == FR_OK) {
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD11B             BNE.N    ??dir_remove_2
   1653          		do {
   1654          			res = move_window(dj->fs, dj->sect);
   \                     ??dir_remove_3:
   \   00000024   0x6921             LDR      R1,[R4, #+16]
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x.... 0x....      BL       move_window
   1655          			if (res != FR_OK) break;
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD110             BNE.N    ??dir_remove_4
   1656          			*dj->dir = DDE;			/* Mark the entry "deleted" */
   \                     ??dir_remove_5:
   \   00000032   0x6961             LDR      R1,[R4, #+20]
   \   00000034   0x22E5             MOVS     R2,#+229
   \   00000036   0x700A             STRB     R2,[R1, #+0]
   1657          			dj->fs->wflag = 1;
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0x710A             STRB     R2,[R1, #+4]
   1658          			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
   \   0000003E   0x88E1             LDRH     R1,[R4, #+6]
   \   00000040   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000042   0x42A9             CMP      R1,R5
   \   00000044   0xD206             BCS.N    ??dir_remove_4
   1659          			res = dir_next(dj, 0);		/* Next entry */
   \                     ??dir_remove_6:
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       dir_next
   1660          		} while (res == FR_OK);
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD0E7             BEQ.N    ??dir_remove_3
   1661          		if (res == FR_NO_FILE) res = FR_INT_ERR;
   \                     ??dir_remove_4:
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0x2804             CMP      R0,#+4
   \   00000058   0xD100             BNE.N    ??dir_remove_2
   \   0000005A   0x2002             MOVS     R0,#+2
   1662          	}
   1663          
   1664          #else			/* Non LFN configuration */
   1665          	res = dir_sdi(dj, dj->index);
   1666          	if (res == FR_OK) {
   1667          		res = move_window(dj->fs, dj->sect);
   1668          		if (res == FR_OK) {
   1669          			*dj->dir = DDE;			/* Mark the entry "deleted" */
   1670          			dj->fs->wflag = 1;
   1671          		}
   1672          	}
   1673          #endif
   1674          
   1675          	return res;
   \                     ??dir_remove_2:
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1676          }
   1677          #endif /* !_FS_READONLY */
   1678          
   1679          
   1680          
   1681          
   1682          /*-----------------------------------------------------------------------*/
   1683          /* Pick a segment and create the object name in directory form           */
   1684          /*-----------------------------------------------------------------------*/
   1685          

   \                                 In section .text, align 2, keep-with-next
   1686          static
   1687          FRESULT create_name (
   1688          	DIR *dj,			/* Pointer to the directory object */
   1689          	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
   1690          )
   1691          {
   \                     create_name:
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0x4688             MOV      R8,R1
   1692          #if _USE_LFN	/* LFN configuration */
   1693          	BYTE b, cf;
   1694          	WCHAR w, *lfn;
   1695          	UINT i, ni, si, di;
   1696          	const TCHAR *p;
   1697          
   1698          	/* Create LFN in Unicode */
   1699          	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   \   00000006   0xF8D8 0x9000      LDR      R9,[R8, #+0]
   \   0000000A   0xE001             B.N      ??create_name_0
   \                     ??create_name_1:
   \   0000000C   0xF119 0x0901      ADDS     R9,R9,#+1
   \                     ??create_name_0:
   \   00000010   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000014   0x282F             CMP      R0,#+47
   \   00000016   0xD0F9             BEQ.N    ??create_name_1
   \   00000018   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   0000001C   0x285C             CMP      R0,#+92
   \   0000001E   0xD0F5             BEQ.N    ??create_name_1
   1700          	lfn = dj->lfn;
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x69C6             LDR      R6,[R0, #+28]
   1701          	si = di = 0;
   \   00000024   0x2400             MOVS     R4,#+0
   \   00000026   0x0025             MOVS     R5,R4
   \   00000028   0xE002             B.N      ??create_name_2
   1702          	for (;;) {
   1703          		w = p[si++];					/* Get a character */
   1704          		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
   1705          		if (di >= _MAX_LFN)				/* Reject too long name */
   1706          			return FR_INVALID_NAME;
   1707          #if !_LFN_UNICODE
   1708          		w &= 0xFF;
   1709          		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   1710          			b = (BYTE)p[si++];			/* Get 2nd byte */
   1711          			if (!IsDBCS2(b))
   1712          				return FR_INVALID_NAME;	/* Reject invalid sequence */
   1713          			w = (w << 8) + b;			/* Create a DBC */
   1714          		}
   1715          		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
   1716          		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
   1717          #endif
   1718          		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
   1719          			return FR_INVALID_NAME;
   1720          		lfn[di++] = w;					/* Store the Unicode char */
   \                     ??create_name_3:
   \   0000002A   0xF826 0x7015      STRH     R7,[R6, R5, LSL #+1]
   \   0000002E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??create_name_2:
   \   00000030   0xF814 0x7009      LDRB     R7,[R4, R9]
   \   00000034   0x1C64             ADDS     R4,R4,#+1
   \   00000036   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000038   0x2F20             CMP      R7,#+32
   \   0000003A   0xD305             BCC.N    ??create_name_4
   \   0000003C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000003E   0x2F2F             CMP      R7,#+47
   \   00000040   0xD002             BEQ.N    ??create_name_4
   \   00000042   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000044   0x2F5C             CMP      R7,#+92
   \   00000046   0xD109             BNE.N    ??create_name_5
   1721          	}
   1722          	*path = &p[si];						/* Return pointer to the next segment */
   \                     ??create_name_4:
   \   00000048   0xEB14 0x0009      ADDS     R0,R4,R9
   \   0000004C   0xF8C8 0x0000      STR      R0,[R8, #+0]
   1723          	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   \   00000050   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000052   0x2F20             CMP      R7,#+32
   \   00000054   0xD21F             BCS.N    ??create_name_6
   \   00000056   0xF05F 0x0804      MOVS     R8,#+4
   \   0000005A   0xE01E             B.N      ??create_name_7
   \                     ??create_name_5:
   \   0000005C   0x2D40             CMP      R5,#+64
   \   0000005E   0xD301             BCC.N    ??create_name_8
   \   00000060   0x2006             MOVS     R0,#+6
   \   00000062   0xE0C1             B.N      ??create_name_9
   \                     ??create_name_8:
   \   00000064   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0x0038             MOVS     R0,R7
   \   0000006A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006C   0x.... 0x....      BL       ff_convert
   \   00000070   0x0007             MOVS     R7,R0
   \   00000072   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000074   0x2F00             CMP      R7,#+0
   \   00000076   0xD101             BNE.N    ??create_name_10
   \   00000078   0x2006             MOVS     R0,#+6
   \   0000007A   0xE0B5             B.N      ??create_name_9
   \                     ??create_name_10:
   \   0000007C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000007E   0x2F80             CMP      R7,#+128
   \   00000080   0xD2D3             BCS.N    ??create_name_3
   \   00000082   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000084   0x0039             MOVS     R1,R7
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable11
   \   0000008A   0x.... 0x....      BL       chk_chr
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD0CB             BEQ.N    ??create_name_3
   \   00000092   0x2006             MOVS     R0,#+6
   \   00000094   0xE0A8             B.N      ??create_name_9
   \                     ??create_name_6:
   \   00000096   0xF05F 0x0800      MOVS     R8,#+0
   1724          #if _FS_RPATH
   1725          	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
   1726          		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
   \                     ??create_name_7:
   \   0000009A   0x2D01             CMP      R5,#+1
   \   0000009C   0xD105             BNE.N    ??create_name_11
   \   0000009E   0xEB16 0x0045      ADDS     R0,R6,R5, LSL #+1
   \   000000A2   0xF830 0x0C02      LDRH     R0,[R0, #-2]
   \   000000A6   0x282E             CMP      R0,#+46
   \   000000A8   0xD00D             BEQ.N    ??create_name_12
   \                     ??create_name_11:
   \   000000AA   0x2D02             CMP      R5,#+2
   \   000000AC   0xD128             BNE.N    ??create_name_13
   \   000000AE   0xEB16 0x0045      ADDS     R0,R6,R5, LSL #+1
   \   000000B2   0xF830 0x0C02      LDRH     R0,[R0, #-2]
   \   000000B6   0x282E             CMP      R0,#+46
   \   000000B8   0xD122             BNE.N    ??create_name_13
   \   000000BA   0xEB16 0x0045      ADDS     R0,R6,R5, LSL #+1
   \   000000BE   0xF830 0x0C04      LDRH     R0,[R0, #-4]
   \   000000C2   0x282E             CMP      R0,#+46
   \   000000C4   0xD11C             BNE.N    ??create_name_13
   1727          		lfn[di] = 0;
   \                     ??create_name_12:
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0xF826 0x0015      STRH     R0,[R6, R5, LSL #+1]
   1728          		for (i = 0; i < 11; i++)
   \   000000CC   0xF05F 0x0900      MOVS     R9,#+0
   \   000000D0   0xE006             B.N      ??create_name_14
   1729          			dj->fn[i] = (i < di) ? '.' : ' ';
   \                     ??create_name_15:
   \   000000D2   0x2020             MOVS     R0,#+32
   \                     ??create_name_16:
   \   000000D4   0x9900             LDR      R1,[SP, #+0]
   \   000000D6   0x6989             LDR      R1,[R1, #+24]
   \   000000D8   0xF809 0x0001      STRB     R0,[R9, R1]
   \   000000DC   0xF119 0x0901      ADDS     R9,R9,#+1
   \                     ??create_name_14:
   \   000000E0   0xF1B9 0x0F0B      CMP      R9,#+11
   \   000000E4   0xD203             BCS.N    ??create_name_17
   \   000000E6   0x45A9             CMP      R9,R5
   \   000000E8   0xD2F3             BCS.N    ??create_name_15
   \   000000EA   0x202E             MOVS     R0,#+46
   \   000000EC   0xE7F2             B.N      ??create_name_16
   1730          		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
   \                     ??create_name_17:
   \   000000EE   0x9800             LDR      R0,[SP, #+0]
   \   000000F0   0x6980             LDR      R0,[R0, #+24]
   \   000000F2   0xF058 0x0120      ORRS     R1,R8,#0x20
   \   000000F6   0xF809 0x1000      STRB     R1,[R9, R0]
   1731          		return FR_OK;
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0xE074             B.N      ??create_name_9
   1732          	}
   1733          #endif
   1734          	while (di) {						/* Strip trailing spaces and dots */
   1735          		w = lfn[di-1];
   1736          		if (w != ' ' && w != '.') break;
   1737          		di--;
   \                     ??create_name_18:
   \   000000FE   0x1E6D             SUBS     R5,R5,#+1
   \                     ??create_name_13:
   \   00000100   0x2D00             CMP      R5,#+0
   \   00000102   0xD009             BEQ.N    ??create_name_19
   \   00000104   0xEB16 0x0045      ADDS     R0,R6,R5, LSL #+1
   \   00000108   0xF830 0x7C02      LDRH     R7,[R0, #-2]
   \   0000010C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000010E   0x2F20             CMP      R7,#+32
   \   00000110   0xD0F5             BEQ.N    ??create_name_18
   \   00000112   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000114   0x2F2E             CMP      R7,#+46
   \   00000116   0xD0F2             BEQ.N    ??create_name_18
   1738          	}
   1739          	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
   \                     ??create_name_19:
   \   00000118   0x2D00             CMP      R5,#+0
   \   0000011A   0xD101             BNE.N    ??create_name_20
   \   0000011C   0x2006             MOVS     R0,#+6
   \   0000011E   0xE063             B.N      ??create_name_9
   1740          
   1741          	lfn[di] = 0;						/* LFN is created */
   \                     ??create_name_20:
   \   00000120   0x2000             MOVS     R0,#+0
   \   00000122   0xF826 0x0015      STRH     R0,[R6, R5, LSL #+1]
   1742          
   1743          	/* Create SFN in directory form */
   1744          	mem_set(dj->fn, ' ', 11);
   \   00000126   0x220B             MOVS     R2,#+11
   \   00000128   0x2120             MOVS     R1,#+32
   \   0000012A   0x9800             LDR      R0,[SP, #+0]
   \   0000012C   0x6980             LDR      R0,[R0, #+24]
   \   0000012E   0x.... 0x....      BL       mem_set
   1745          	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
   \   00000132   0x2400             MOVS     R4,#+0
   \   00000134   0xE000             B.N      ??create_name_21
   \                     ??create_name_22:
   \   00000136   0x1C64             ADDS     R4,R4,#+1
   \                     ??create_name_21:
   \   00000138   0xF836 0x0014      LDRH     R0,[R6, R4, LSL #+1]
   \   0000013C   0x2820             CMP      R0,#+32
   \   0000013E   0xD0FA             BEQ.N    ??create_name_22
   \   00000140   0xF836 0x0014      LDRH     R0,[R6, R4, LSL #+1]
   \   00000144   0x282E             CMP      R0,#+46
   \   00000146   0xD0F6             BEQ.N    ??create_name_22
   1746          	if (si) cf |= NS_LOSS | NS_LFN;
   \   00000148   0x2C00             CMP      R4,#+0
   \   0000014A   0xD003             BEQ.N    ??create_name_23
   \   0000014C   0xF058 0x0803      ORRS     R8,R8,#0x3
   \   00000150   0xE000             B.N      ??create_name_23
   1747          	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
   \                     ??create_name_24:
   \   00000152   0x1E6D             SUBS     R5,R5,#+1
   \                     ??create_name_23:
   \   00000154   0x2D00             CMP      R5,#+0
   \   00000156   0xD005             BEQ.N    ??create_name_25
   \   00000158   0xEB16 0x0045      ADDS     R0,R6,R5, LSL #+1
   \   0000015C   0xF830 0x0C02      LDRH     R0,[R0, #-2]
   \   00000160   0x282E             CMP      R0,#+46
   \   00000162   0xD1F6             BNE.N    ??create_name_24
   1748          
   1749          	b = i = 0; ni = 8;
   \                     ??create_name_25:
   \   00000164   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000168   0x46D1             MOV      R9,R10
   \   0000016A   0xF05F 0x0B08      MOVS     R11,#+8
   \   0000016E   0xE001             B.N      ??create_name_26
   1750          	for (;;) {
   1751          		w = lfn[si++];					/* Get an LFN char */
   1752          		if (!w) break;					/* Break on end of the LFN */
   1753          		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
   1754          			cf |= NS_LOSS | NS_LFN; continue;
   \                     ??create_name_27:
   \   00000170   0xF058 0x0803      ORRS     R8,R8,#0x3
   1755          		}
   \                     ??create_name_26:
   \   00000174   0xF836 0x7014      LDRH     R7,[R6, R4, LSL #+1]
   \   00000178   0x1C64             ADDS     R4,R4,#+1
   \   0000017A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000017C   0x2F00             CMP      R7,#+0
   \   0000017E   0xD135             BNE.N    ??create_name_28
   1756          
   1757          		if (i >= ni || si == di) {		/* Extension or end of SFN */
   1758          			if (ni == 11) {				/* Long extension */
   1759          				cf |= NS_LOSS | NS_LFN; break;
   1760          			}
   1761          			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
   1762          			if (si > di) break;			/* No extension */
   1763          			si = di; i = 8; ni = 11;	/* Enter extension section */
   1764          			b <<= 2; continue;
   1765          		}
   1766          
   1767          		if (w >= 0x80) {				/* Non ASCII char */
   1768          #ifdef _EXCVT
   1769          			w = ff_convert(w, 0);		/* Unicode -> OEM code */
   1770          			if (w) w = ExCvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
   1771          #else
   1772          			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
   1773          #endif
   1774          			cf |= NS_LFN;				/* Force create LFN entry */
   1775          		}
   1776          
   1777          		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
   1778          			if (i >= ni - 1) {
   1779          				cf |= NS_LOSS | NS_LFN; i = ni; continue;
   1780          			}
   1781          			dj->fn[i++] = (BYTE)(w >> 8);
   1782          		} else {						/* Single byte char */
   1783          			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
   1784          				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
   1785          			} else {
   1786          				if (IsUpper(w)) {		/* ASCII large capital */
   1787          					b |= 2;
   1788          				} else {
   1789          					if (IsLower(w)) {	/* ASCII small capital */
   1790          						b |= 1; w -= 0x20;
   1791          					}
   1792          				}
   1793          			}
   1794          		}
   1795          		dj->fn[i++] = (BYTE)w;
   1796          	}
   1797          
   1798          	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
   \                     ??create_name_29:
   \   00000180   0x9800             LDR      R0,[SP, #+0]
   \   00000182   0x6980             LDR      R0,[R0, #+24]
   \   00000184   0x7800             LDRB     R0,[R0, #+0]
   \   00000186   0x28E5             CMP      R0,#+229
   \   00000188   0xD103             BNE.N    ??create_name_30
   \   0000018A   0x9800             LDR      R0,[SP, #+0]
   \   0000018C   0x6980             LDR      R0,[R0, #+24]
   \   0000018E   0x2105             MOVS     R1,#+5
   \   00000190   0x7001             STRB     R1,[R0, #+0]
   1799          
   1800          	if (ni == 8) b <<= 2;
   \                     ??create_name_30:
   \   00000192   0xF1BB 0x0F08      CMP      R11,#+8
   \   00000196   0xD101             BNE.N    ??create_name_31
   \   00000198   0xEA5F 0x0A8A      LSLS     R10,R10,#+2
   1801          	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
   \                     ??create_name_31:
   \   0000019C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001A0   0xF01A 0x000C      ANDS     R0,R10,#0xC
   \   000001A4   0x280C             CMP      R0,#+12
   \   000001A6   0xD005             BEQ.N    ??create_name_32
   \   000001A8   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001AC   0xF01A 0x0003      ANDS     R0,R10,#0x3
   \   000001B0   0x2803             CMP      R0,#+3
   \   000001B2   0xD101             BNE.N    ??create_name_33
   1802          		cf |= NS_LFN;
   \                     ??create_name_32:
   \   000001B4   0xF058 0x0802      ORRS     R8,R8,#0x2
   1803          	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
   \                     ??create_name_33:
   \   000001B8   0xEA5F 0x7088      LSLS     R0,R8,#+30
   \   000001BC   0xD40F             BMI.N    ??create_name_34
   1804          		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
   \   000001BE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001C2   0xF01A 0x0003      ANDS     R0,R10,#0x3
   \   000001C6   0x2801             CMP      R0,#+1
   \   000001C8   0xD101             BNE.N    ??create_name_35
   \   000001CA   0xF058 0x0810      ORRS     R8,R8,#0x10
   1805          		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
   \                     ??create_name_35:
   \   000001CE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001D2   0xF01A 0x000C      ANDS     R0,R10,#0xC
   \   000001D6   0x2804             CMP      R0,#+4
   \   000001D8   0xD101             BNE.N    ??create_name_34
   \   000001DA   0xF058 0x0808      ORRS     R8,R8,#0x8
   1806          	}
   1807          
   1808          	dj->fn[NS] = cf;	/* SFN is created */
   \                     ??create_name_34:
   \   000001DE   0x9800             LDR      R0,[SP, #+0]
   \   000001E0   0x6980             LDR      R0,[R0, #+24]
   \   000001E2   0xF880 0x800B      STRB     R8,[R0, #+11]
   1809          
   1810          	return FR_OK;
   \   000001E6   0x2000             MOVS     R0,#+0
   \                     ??create_name_9:
   \   000001E8   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??create_name_28:
   \   000001EC   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000001EE   0x2F20             CMP      R7,#+32
   \   000001F0   0xD0BE             BEQ.N    ??create_name_27
   \   000001F2   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000001F4   0x2F2E             CMP      R7,#+46
   \   000001F6   0xD101             BNE.N    ??create_name_36
   \   000001F8   0x42AC             CMP      R4,R5
   \   000001FA   0xD1B9             BNE.N    ??create_name_27
   \                     ??create_name_36:
   \   000001FC   0x45D9             CMP      R9,R11
   \   000001FE   0xD201             BCS.N    ??create_name_37
   \   00000200   0x42AC             CMP      R4,R5
   \   00000202   0xD113             BNE.N    ??create_name_38
   \                     ??create_name_37:
   \   00000204   0xF1BB 0x0F0B      CMP      R11,#+11
   \   00000208   0xD102             BNE.N    ??create_name_39
   \   0000020A   0xF058 0x0803      ORRS     R8,R8,#0x3
   \   0000020E   0xE7B7             B.N      ??create_name_29
   \                     ??create_name_39:
   \   00000210   0x42AC             CMP      R4,R5
   \   00000212   0xD001             BEQ.N    ??create_name_40
   \   00000214   0xF058 0x0803      ORRS     R8,R8,#0x3
   \                     ??create_name_40:
   \   00000218   0x42A5             CMP      R5,R4
   \   0000021A   0xD3B1             BCC.N    ??create_name_29
   \                     ??create_name_41:
   \   0000021C   0x002C             MOVS     R4,R5
   \   0000021E   0xF05F 0x0908      MOVS     R9,#+8
   \   00000222   0xF05F 0x0B0B      MOVS     R11,#+11
   \   00000226   0xEA5F 0x0A8A      LSLS     R10,R10,#+2
   \   0000022A   0xE7A3             B.N      ??create_name_26
   \                     ??create_name_38:
   \   0000022C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000022E   0x2F80             CMP      R7,#+128
   \   00000230   0xD310             BCC.N    ??create_name_42
   \   00000232   0x2100             MOVS     R1,#+0
   \   00000234   0x0038             MOVS     R0,R7
   \   00000236   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000238   0x.... 0x....      BL       ff_convert
   \   0000023C   0x0007             MOVS     R7,R0
   \   0000023E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000240   0x2F00             CMP      R7,#+0
   \   00000242   0xD005             BEQ.N    ??create_name_43
   \   00000244   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000246   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000024A   0x1838             ADDS     R0,R7,R0
   \   0000024C   0xF810 0x7C80      LDRB     R7,[R0, #-128]
   \                     ??create_name_43:
   \   00000250   0xF058 0x0802      ORRS     R8,R8,#0x2
   \                     ??create_name_42:
   \   00000254   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000256   0x2F00             CMP      R7,#+0
   \   00000258   0xD007             BEQ.N    ??create_name_44
   \   0000025A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000025C   0x0039             MOVS     R1,R7
   \   0000025E   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \   00000262   0x.... 0x....      BL       chk_chr
   \   00000266   0x2800             CMP      R0,#+0
   \   00000268   0xD003             BEQ.N    ??create_name_45
   \                     ??create_name_44:
   \   0000026A   0x275F             MOVS     R7,#+95
   \   0000026C   0xF058 0x0803      ORRS     R8,R8,#0x3
   \   00000270   0xE00F             B.N      ??create_name_46
   \                     ??create_name_45:
   \   00000272   0xF1B7 0x0041      SUBS     R0,R7,#+65
   \   00000276   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000278   0x281A             CMP      R0,#+26
   \   0000027A   0xD202             BCS.N    ??create_name_47
   \   0000027C   0xF05A 0x0A02      ORRS     R10,R10,#0x2
   \   00000280   0xE007             B.N      ??create_name_46
   \                     ??create_name_47:
   \   00000282   0xF1B7 0x0061      SUBS     R0,R7,#+97
   \   00000286   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000288   0x281A             CMP      R0,#+26
   \   0000028A   0xD202             BCS.N    ??create_name_46
   \   0000028C   0xF05A 0x0A01      ORRS     R10,R10,#0x1
   \   00000290   0x3F20             SUBS     R7,R7,#+32
   \                     ??create_name_46:
   \   00000292   0x9800             LDR      R0,[SP, #+0]
   \   00000294   0x6980             LDR      R0,[R0, #+24]
   \   00000296   0xF809 0x7000      STRB     R7,[R9, R0]
   \   0000029A   0xF119 0x0901      ADDS     R9,R9,#+1
   \   0000029E   0xE769             B.N      ??create_name_26
   1811          
   1812          
   1813          #else	/* Non-LFN configuration */
   1814          	BYTE b, c, d, *sfn;
   1815          	UINT ni, si, i;
   1816          	const char *p;
   1817          
   1818          	/* Create file name in directory form */
   1819          	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   1820          	sfn = dj->fn;
   1821          	mem_set(sfn, ' ', 11);
   1822          	si = i = b = 0; ni = 8;
   1823          #if _FS_RPATH
   1824          	if (p[si] == '.') { /* Is this a dot entry? */
   1825          		for (;;) {
   1826          			c = (BYTE)p[si++];
   1827          			if (c != '.' || si >= 3) break;
   1828          			sfn[i++] = c;
   1829          		}
   1830          		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
   1831          		*path = &p[si];									/* Return pointer to the next segment */
   1832          		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
   1833          		return FR_OK;
   1834          	}
   1835          #endif
   1836          	for (;;) {
   1837          		c = (BYTE)p[si++];
   1838          		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
   1839          		if (c == '.' || i >= ni) {
   1840          			if (ni != 8 || c != '.') return FR_INVALID_NAME;
   1841          			i = 8; ni = 11;
   1842          			b <<= 2; continue;
   1843          		}
   1844          		if (c >= 0x80) {				/* Extended char? */
   1845          			b |= 3;						/* Eliminate NT flag */
   1846          #ifdef _EXCVT
   1847          			c = ExCvt[c - 0x80];		/* To upper extended chars (SBCS cfg) */
   1848          #else
   1849          #if !_DF1S
   1850          			return FR_INVALID_NAME;		/* Reject extended chars (ASCII cfg) */
   1851          #endif
   1852          #endif
   1853          		}
   1854          		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   1855          			d = (BYTE)p[si++];			/* Get 2nd byte */
   1856          			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
   1857          				return FR_INVALID_NAME;
   1858          			sfn[i++] = c;
   1859          			sfn[i++] = d;
   1860          		} else {						/* Single byte code */
   1861          			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
   1862          				return FR_INVALID_NAME;
   1863          			if (IsUpper(c)) {			/* ASCII large capital? */
   1864          				b |= 2;
   1865          			} else {
   1866          				if (IsLower(c)) {		/* ASCII small capital? */
   1867          					b |= 1; c -= 0x20;
   1868          				}
   1869          			}
   1870          			sfn[i++] = c;
   1871          		}
   1872          	}
   1873          	*path = &p[si];						/* Return pointer to the next segment */
   1874          	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   1875          
   1876          	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
   1877          	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
   1878          
   1879          	if (ni == 8) b <<= 2;
   1880          	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
   1881          	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
   1882          
   1883          	sfn[NS] = c;		/* Store NT flag, File name is created */
   1884          
   1885          	return FR_OK;
   1886          #endif
   1887          }
   1888          
   1889          
   1890          
   1891          
   1892          /*-----------------------------------------------------------------------*/
   1893          /* Get file information from directory entry                             */
   1894          /*-----------------------------------------------------------------------*/
   1895          #if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2

   \                                 In section .text, align 2, keep-with-next
   1896          static
   1897          void get_fileinfo (		/* No return code */
   1898          	DIR *dj,			/* Pointer to the directory object */
   1899          	FILINFO *fno	 	/* Pointer to the file information to be filled */
   1900          )
   1901          {
   \                     get_fileinfo:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x000C             MOVS     R4,R1
   1902          	UINT i;
   1903          	BYTE nt, *dir;
   1904          	TCHAR *p, c;
   1905          
   1906          
   1907          	p = fno->fname;
   \   00000004   0xF204 0x0109      ADDW     R1,R4,#+9
   1908          	if (dj->sect) {
   \   00000008   0x6902             LDR      R2,[R0, #+16]
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD048             BEQ.N    ??get_fileinfo_0
   1909          		dir = dj->dir;
   \   0000000E   0x6942             LDR      R2,[R0, #+20]
   1910          		nt = dir[DIR_NTres];		/* NT flag */
   \   00000010   0x7B13             LDRB     R3,[R2, #+12]
   1911          		for (i = 0; i < 8; i++) {	/* Copy name body */
   \   00000012   0x2500             MOVS     R5,#+0
   \   00000014   0xE00E             B.N      ??get_fileinfo_1
   1912          			c = dir[i];
   1913          			if (c == ' ') break;
   1914          			if (c == NDDE) c = (TCHAR)DDE;
   \                     ??get_fileinfo_2:
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2E05             CMP      R6,#+5
   \   0000001A   0xD100             BNE.N    ??get_fileinfo_3
   \   0000001C   0x26E5             MOVS     R6,#+229
   1915          			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
   \                     ??get_fileinfo_3:
   \   0000001E   0x071F             LSLS     R7,R3,#+28
   \   00000020   0xD505             BPL.N    ??get_fileinfo_4
   \   00000022   0xF1B6 0x0741      SUBS     R7,R6,#+65
   \   00000026   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000028   0x2F1A             CMP      R7,#+26
   \   0000002A   0xD200             BCS.N    ??get_fileinfo_4
   \   0000002C   0x3620             ADDS     R6,R6,#+32
   1916          #if _LFN_UNICODE
   1917          			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
   1918          				c = (c << 8) | dir[++i];
   1919          			c = ff_convert(c, 1);
   1920          			if (!c) c = '?';
   1921          #endif
   1922          			*p++ = c;
   \                     ??get_fileinfo_4:
   \   0000002E   0x700E             STRB     R6,[R1, #+0]
   \   00000030   0x1C49             ADDS     R1,R1,#+1
   \   00000032   0x1C6D             ADDS     R5,R5,#+1
   \                     ??get_fileinfo_1:
   \   00000034   0x2D08             CMP      R5,#+8
   \   00000036   0xD203             BCS.N    ??get_fileinfo_5
   \   00000038   0x5CAE             LDRB     R6,[R5, R2]
   \   0000003A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003C   0x2E20             CMP      R6,#+32
   \   0000003E   0xD1EA             BNE.N    ??get_fileinfo_2
   1923          		}
   1924          		if (dir[8] != ' ') {		/* Copy name extension */
   \                     ??get_fileinfo_5:
   \   00000040   0x7A15             LDRB     R5,[R2, #+8]
   \   00000042   0x2D20             CMP      R5,#+32
   \   00000044   0xD015             BEQ.N    ??get_fileinfo_6
   1925          			*p++ = '.';
   \   00000046   0x252E             MOVS     R5,#+46
   \   00000048   0x700D             STRB     R5,[R1, #+0]
   \   0000004A   0x1C49             ADDS     R1,R1,#+1
   1926          			for (i = 8; i < 11; i++) {
   \   0000004C   0x2508             MOVS     R5,#+8
   \   0000004E   0xE00A             B.N      ??get_fileinfo_7
   1927          				c = dir[i];
   1928          				if (c == ' ') break;
   1929          				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
   \                     ??get_fileinfo_8:
   \   00000050   0x06DF             LSLS     R7,R3,#+27
   \   00000052   0xD505             BPL.N    ??get_fileinfo_9
   \   00000054   0xF1B6 0x0741      SUBS     R7,R6,#+65
   \   00000058   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005A   0x2F1A             CMP      R7,#+26
   \   0000005C   0xD200             BCS.N    ??get_fileinfo_9
   \   0000005E   0x3620             ADDS     R6,R6,#+32
   1930          #if _LFN_UNICODE
   1931          				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
   1932          					c = (c << 8) | dir[++i];
   1933          				c = ff_convert(c, 1);
   1934          				if (!c) c = '?';
   1935          #endif
   1936          				*p++ = c;
   \                     ??get_fileinfo_9:
   \   00000060   0x700E             STRB     R6,[R1, #+0]
   \   00000062   0x1C49             ADDS     R1,R1,#+1
   \   00000064   0x1C6D             ADDS     R5,R5,#+1
   \                     ??get_fileinfo_7:
   \   00000066   0x2D0B             CMP      R5,#+11
   \   00000068   0xD203             BCS.N    ??get_fileinfo_6
   \   0000006A   0x5CAE             LDRB     R6,[R5, R2]
   \   0000006C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006E   0x2E20             CMP      R6,#+32
   \   00000070   0xD1EE             BNE.N    ??get_fileinfo_8
   1937          			}
   1938          		}
   1939          		fno->fattrib = dir[DIR_Attr];				/* Attribute */
   \                     ??get_fileinfo_6:
   \   00000072   0x7AD3             LDRB     R3,[R2, #+11]
   \   00000074   0x7223             STRB     R3,[R4, #+8]
   1940          		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
   \   00000076   0x7FD3             LDRB     R3,[R2, #+31]
   \   00000078   0x7F95             LDRB     R5,[R2, #+30]
   \   0000007A   0x042D             LSLS     R5,R5,#+16
   \   0000007C   0xEA55 0x6303      ORRS     R3,R5,R3, LSL #+24
   \   00000080   0x7F55             LDRB     R5,[R2, #+29]
   \   00000082   0xEA53 0x2305      ORRS     R3,R3,R5, LSL #+8
   \   00000086   0x7F15             LDRB     R5,[R2, #+28]
   \   00000088   0x432B             ORRS     R3,R5,R3
   \   0000008A   0x6023             STR      R3,[R4, #+0]
   1941          		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
   \   0000008C   0x7E53             LDRB     R3,[R2, #+25]
   \   0000008E   0x7E15             LDRB     R5,[R2, #+24]
   \   00000090   0xEA55 0x2303      ORRS     R3,R5,R3, LSL #+8
   \   00000094   0x80A3             STRH     R3,[R4, #+4]
   1942          		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
   \   00000096   0x7DD3             LDRB     R3,[R2, #+23]
   \   00000098   0x7D92             LDRB     R2,[R2, #+22]
   \   0000009A   0xEA52 0x2203      ORRS     R2,R2,R3, LSL #+8
   \   0000009E   0x80E2             STRH     R2,[R4, #+6]
   1943          	}
   1944          	*p = 0;		/* Terminate SFN str by a \0 */
   \                     ??get_fileinfo_0:
   \   000000A0   0x2200             MOVS     R2,#+0
   \   000000A2   0x700A             STRB     R2,[R1, #+0]
   1945          
   1946          #if _USE_LFN
   1947          	if (fno->lfname && fno->lfsize) {
   \   000000A4   0x69A1             LDR      R1,[R4, #+24]
   \   000000A6   0x2900             CMP      R1,#+0
   \   000000A8   0xD026             BEQ.N    ??get_fileinfo_10
   \   000000AA   0x69E1             LDR      R1,[R4, #+28]
   \   000000AC   0x2900             CMP      R1,#+0
   \   000000AE   0xD023             BEQ.N    ??get_fileinfo_10
   1948          		TCHAR *tp = fno->lfname;
   \   000000B0   0x69A6             LDR      R6,[R4, #+24]
   1949          		WCHAR w, *lfn;
   1950          
   1951          		i = 0;
   \   000000B2   0x2500             MOVS     R5,#+0
   1952          		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
   \   000000B4   0x6901             LDR      R1,[R0, #+16]
   \   000000B6   0x2900             CMP      R1,#+0
   \   000000B8   0xD01C             BEQ.N    ??get_fileinfo_11
   \   000000BA   0x8C01             LDRH     R1,[R0, #+32]
   \   000000BC   0xF64F 0x72FF      MOVW     R2,#+65535
   \   000000C0   0x4291             CMP      R1,R2
   \   000000C2   0xD017             BEQ.N    ??get_fileinfo_11
   1953          			lfn = dj->lfn;
   \   000000C4   0x69C7             LDR      R7,[R0, #+28]
   \   000000C6   0xE001             B.N      ??get_fileinfo_12
   1954          			while ((w = *lfn++) != 0) {			/* Get an LFN char */
   1955          #if !_LFN_UNICODE
   1956          				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
   1957          				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
   1958          				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
   1959          					tp[i++] = (TCHAR)(w >> 8);
   1960          #endif
   1961          				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
   1962          				tp[i++] = (TCHAR)w;
   \                     ??get_fileinfo_13:
   \   000000C8   0x55A8             STRB     R0,[R5, R6]
   \   000000CA   0x1C6D             ADDS     R5,R5,#+1
   \                     ??get_fileinfo_12:
   \   000000CC   0x8838             LDRH     R0,[R7, #+0]
   \   000000CE   0x1CBF             ADDS     R7,R7,#+2
   \   000000D0   0x0001             MOVS     R1,R0
   \   000000D2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000D4   0x2900             CMP      R1,#+0
   \   000000D6   0xD00D             BEQ.N    ??get_fileinfo_11
   \   000000D8   0x2100             MOVS     R1,#+0
   \   000000DA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000DC   0x.... 0x....      BL       ff_convert
   \   000000E0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD101             BNE.N    ??get_fileinfo_14
   \   000000E6   0x2500             MOVS     R5,#+0
   \   000000E8   0xE004             B.N      ??get_fileinfo_11
   \                     ??get_fileinfo_14:
   \   000000EA   0x69E1             LDR      R1,[R4, #+28]
   \   000000EC   0x1E49             SUBS     R1,R1,#+1
   \   000000EE   0x428D             CMP      R5,R1
   \   000000F0   0xD3EA             BCC.N    ??get_fileinfo_13
   \   000000F2   0x2500             MOVS     R5,#+0
   1963          			}
   1964          		}
   1965          		tp[i] = 0;	/* Terminate the LFN str by a \0 */
   \                     ??get_fileinfo_11:
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0x55A8             STRB     R0,[R5, R6]
   1966          	}
   1967          #endif
   1968          }
   \                     ??get_fileinfo_10:
   \   000000F8   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1969          #endif /* _FS_MINIMIZE <= 1 || _FS_RPATH >= 2*/
   1970          
   1971          
   1972          
   1973          
   1974          /*-----------------------------------------------------------------------*/
   1975          /* Follow a file path                                                    */
   1976          /*-----------------------------------------------------------------------*/
   1977          

   \                                 In section .text, align 2, keep-with-next
   1978          static
   1979          FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
   1980          	DIR *dj,			/* Directory object to return last directory and found object */
   1981          	const TCHAR *path	/* Full-path string to find a file or directory */
   1982          )
   1983          {
   \                     follow_path:
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1984          	FRESULT res;
   1985          	BYTE *dir, ns;
   1986          
   1987          
   1988          #if _FS_RPATH
   1989          	if (*path == '/' || *path == '\\') { /* There is a heading separator */
   \   00000004   0x9801             LDR      R0,[SP, #+4]
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x282F             CMP      R0,#+47
   \   0000000A   0xD003             BEQ.N    ??follow_path_0
   \   0000000C   0x9801             LDR      R0,[SP, #+4]
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x285C             CMP      R0,#+92
   \   00000012   0xD105             BNE.N    ??follow_path_1
   1990          		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
   \                     ??follow_path_0:
   \   00000014   0x9801             LDR      R0,[SP, #+4]
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x9001             STR      R0,[SP, #+4]
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x60A0             STR      R0,[R4, #+8]
   \   0000001E   0xE002             B.N      ??follow_path_2
   1991          	} else {							/* No heading separator */
   1992          		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
   \                     ??follow_path_1:
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6980             LDR      R0,[R0, #+24]
   \   00000024   0x60A0             STR      R0,[R4, #+8]
   1993          	}
   1994          #else
   1995          	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
   1996          		path++;
   1997          	dj->sclust = 0;						/* Start from the root dir */
   1998          #endif
   1999          
   2000          	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
   \                     ??follow_path_2:
   \   00000026   0x9801             LDR      R0,[SP, #+4]
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x2820             CMP      R0,#+32
   \   0000002C   0xD20E             BCS.N    ??follow_path_3
   2001          		res = dir_sdi(dj, 0);
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       dir_sdi
   2002          		dj->dir = 0;
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x6161             STR      R1,[R4, #+20]
   2003          	} else {							/* Follow path */
   2004          		for (;;) {
   2005          			res = create_name(dj, &path);	/* Get a segment */
   2006          			if (res != FR_OK) break;
   2007          			res = dir_find(dj);				/* Find it */
   2008          			ns = *(dj->fn+NS);
   2009          			if (res != FR_OK) {				/* Failed to find the object */
   2010          				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
   2011          				/* Object not found */
   2012          				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
   2013          					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
   2014          					res = FR_OK;
   2015          					if (!(ns & NS_LAST)) continue;
   2016          				} else {							/* Could not find the object */
   2017          					if (!(ns & NS_LAST)) res = FR_NO_PATH;
   2018          				}
   2019          				break;
   2020          			}
   2021          			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
   2022          			dir = dj->dir;						/* There is next segment. Follow the sub directory */
   2023          			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
   2024          				res = FR_NO_PATH; break;
   2025          			}
   2026          			dj->sclust = ld_clust(dj->fs, dir);
   2027          		}
   2028          	}
   2029          
   2030          	return res;
   \                     ??follow_path_4:
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   \                     ??follow_path_5:
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x60A0             STR      R0,[R4, #+8]
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x6160             STR      R0,[R4, #+20]
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x0749             LSLS     R1,R1,#+29
   \   0000004A   0xD416             BMI.N    ??follow_path_6
   \                     ??follow_path_3:
   \   0000004C   0xA901             ADD      R1,SP,#+4
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       create_name
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD1EF             BNE.N    ??follow_path_4
   \                     ??follow_path_7:
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       dir_find
   \   00000060   0x69A1             LDR      R1,[R4, #+24]
   \   00000062   0x7AC9             LDRB     R1,[R1, #+11]
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD008             BEQ.N    ??follow_path_8
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006C   0x2804             CMP      R0,#+4
   \   0000006E   0xD1E4             BNE.N    ??follow_path_4
   \                     ??follow_path_9:
   \   00000070   0x068A             LSLS     R2,R1,#+26
   \   00000072   0xD4E4             BMI.N    ??follow_path_5
   \   00000074   0x0749             LSLS     R1,R1,#+29
   \   00000076   0xD400             BMI.N    ??follow_path_6
   \   00000078   0x2005             MOVS     R0,#+5
   \                     ??follow_path_6:
   \   0000007A   0xE7DE             B.N      ??follow_path_4
   \                     ??follow_path_8:
   \   0000007C   0x0749             LSLS     R1,R1,#+29
   \   0000007E   0xD4DC             BMI.N    ??follow_path_4
   \                     ??follow_path_10:
   \   00000080   0x6961             LDR      R1,[R4, #+20]
   \   00000082   0x7AC8             LDRB     R0,[R1, #+11]
   \   00000084   0x06C0             LSLS     R0,R0,#+27
   \   00000086   0xD401             BMI.N    ??follow_path_11
   \   00000088   0x2005             MOVS     R0,#+5
   \   0000008A   0xE7D6             B.N      ??follow_path_4
   \                     ??follow_path_11:
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x.... 0x....      BL       ld_clust
   \   00000092   0x60A0             STR      R0,[R4, #+8]
   \   00000094   0xE7DA             B.N      ??follow_path_3
   2031          }
   2032          
   2033          
   2034          
   2035          
   2036          /*-----------------------------------------------------------------------*/
   2037          /* Load a sector and check if it is an FAT Volume Boot Record            */
   2038          /*-----------------------------------------------------------------------*/
   2039          

   \                                 In section .text, align 2, keep-with-next
   2040          static
   2041          BYTE check_fs (	/* 0:FAT-VBR, 1:Any BR but not FAT, 2:Not a BR, 3:Disk error */
   2042          	FATFS *fs,	/* File system object */
   2043          	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
   2044          )
   2045          {
   \                     check_fs:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2046          	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0x000A             MOVS     R2,R1
   \   00000008   0xF114 0x0138      ADDS     R1,R4,#+56
   \   0000000C   0x7860             LDRB     R0,[R4, #+1]
   \   0000000E   0x.... 0x....      BL       disk_read
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD001             BEQ.N    ??check_fs_0
   2047          		return 3;
   \   00000016   0x2003             MOVS     R0,#+3
   \   00000018   0xE02D             B.N      ??check_fs_1
   2048          	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
   \                     ??check_fs_0:
   \   0000001A   0xF894 0x0237      LDRB     R0,[R4, #+567]
   \   0000001E   0xF894 0x1236      LDRB     R1,[R4, #+566]
   \   00000022   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000026   0xF64A 0x2155      MOVW     R1,#+43605
   \   0000002A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD001             BEQ.N    ??check_fs_2
   2049          		return 2;
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0xE020             B.N      ??check_fs_1
   2050          
   2051          	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
   \                     ??check_fs_2:
   \   00000034   0xF894 0x0070      LDRB     R0,[R4, #+112]
   \   00000038   0xF894 0x106F      LDRB     R1,[R4, #+111]
   \   0000003C   0x0209             LSLS     R1,R1,#+8
   \   0000003E   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   00000042   0xF894 0x106E      LDRB     R1,[R4, #+110]
   \   00000046   0x4308             ORRS     R0,R1,R0
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0x544146
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xD101             BNE.N    ??check_fs_3
   2052          		return 0;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE010             B.N      ??check_fs_1
   2053          	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
   \                     ??check_fs_3:
   \   00000054   0xF894 0x008C      LDRB     R0,[R4, #+140]
   \   00000058   0xF894 0x108B      LDRB     R1,[R4, #+139]
   \   0000005C   0x0209             LSLS     R1,R1,#+8
   \   0000005E   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   00000062   0xF894 0x108A      LDRB     R1,[R4, #+138]
   \   00000066   0x4308             ORRS     R0,R1,R0
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0x544146
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xD101             BNE.N    ??check_fs_4
   2054          		return 0;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xE000             B.N      ??check_fs_1
   2055          
   2056          	return 1;
   \                     ??check_fs_4:
   \   00000074   0x2001             MOVS     R0,#+1
   \                     ??check_fs_1:
   \   00000076   0xBD10             POP      {R4,PC}          ;; return
   2057          }
   2058          
   2059          
   2060          
   2061          
   2062          /*-----------------------------------------------------------------------*/
   2063          /* Check if the file system object is valid or not                       */
   2064          /*-----------------------------------------------------------------------*/
   2065          

   \                                 In section .text, align 2, keep-with-next
   2066          static
   2067          FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
   2068          	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
   2069          	FATFS **rfs,		/* Pointer to pointer to the found file system object */
   2070          	BYTE wmode			/* !=0: Check write protection for write access */
   2071          )
   2072          {
   \                     chk_mounted:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0015             MOVS     R5,R2
   2073          	BYTE fmt, b, pi, *tbl;
   2074          	UINT vol;
   2075          	DSTATUS stat;
   2076          	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
   2077          	WORD nrsv;
   2078          	const TCHAR *p = *path;
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   2079          	FATFS *fs;
   2080          
   2081          
   2082          	/* Get logical drive number from the path name */
   2083          	vol = p[0] - '0';					/* Is there a drive number? */
   \   00000006   0x7813             LDRB     R3,[R2, #+0]
   \   00000008   0xF1B3 0x0630      SUBS     R6,R3,#+48
   2084          	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
   \   0000000C   0x2E0A             CMP      R6,#+10
   \   0000000E   0xD205             BCS.N    ??chk_mounted_0
   \   00000010   0x7853             LDRB     R3,[R2, #+1]
   \   00000012   0x2B3A             CMP      R3,#+58
   \   00000014   0xD102             BNE.N    ??chk_mounted_0
   2085          		p += 2; *path = p;				/* Return pointer to the path name */
   \   00000016   0x1C92             ADDS     R2,R2,#+2
   \   00000018   0x6002             STR      R2,[R0, #+0]
   \   0000001A   0xE002             B.N      ??chk_mounted_1
   2086          	} else {							/* No drive number, use default drive */
   2087          #if _FS_RPATH
   2088          		vol = CurrVol;					/* Use current drive */
   \                     ??chk_mounted_0:
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000020   0x7806             LDRB     R6,[R0, #+0]
   2089          #else
   2090          		vol = 0;						/* Use drive 0 */
   2091          #endif
   2092          	}
   2093          
   2094          	/* Check if the file system object is valid or not */
   2095          	*rfs = 0;
   \                     ??chk_mounted_1:
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x6008             STR      R0,[R1, #+0]
   2096          	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
   \   00000026   0x2E00             CMP      R6,#+0
   \   00000028   0xD001             BEQ.N    ??chk_mounted_2
   2097          		return FR_INVALID_DRIVE;
   \   0000002A   0x200B             MOVS     R0,#+11
   \   0000002C   0xE1A2             B.N      ??chk_mounted_3
   2098          	fs = FatFs[vol];					/* Get corresponding file system object */
   \                     ??chk_mounted_2:
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   00000032   0xF850 0x4026      LDR      R4,[R0, R6, LSL #+2]
   2099          	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
   \   00000036   0x2C00             CMP      R4,#+0
   \   00000038   0xD101             BNE.N    ??chk_mounted_4
   \   0000003A   0x200C             MOVS     R0,#+12
   \   0000003C   0xE19A             B.N      ??chk_mounted_3
   2100          
   2101          	ENTER_FF(fs);						/* Lock volume */
   2102          
   2103          	*rfs = fs;							/* Return pointer to the corresponding file system object */
   \                     ??chk_mounted_4:
   \   0000003E   0x600C             STR      R4,[R1, #+0]
   2104          	if (fs->fs_type) {					/* If the volume has been mounted */
   \   00000040   0x7820             LDRB     R0,[R4, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD00D             BEQ.N    ??chk_mounted_5
   2105          		stat = disk_status(fs->drv);
   \   00000046   0x7860             LDRB     R0,[R4, #+1]
   \   00000048   0x.... 0x....      BL       disk_status
   2106          		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
   \   0000004C   0x07C1             LSLS     R1,R0,#+31
   \   0000004E   0xD408             BMI.N    ??chk_mounted_5
   2107          			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
   \   00000050   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xD003             BEQ.N    ??chk_mounted_6
   \   00000056   0x0740             LSLS     R0,R0,#+29
   \   00000058   0xD501             BPL.N    ??chk_mounted_6
   2108          				return FR_WRITE_PROTECTED;
   \   0000005A   0x200A             MOVS     R0,#+10
   \   0000005C   0xE18A             B.N      ??chk_mounted_3
   2109          			return FR_OK;				/* The file system object is valid */
   \                     ??chk_mounted_6:
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xE188             B.N      ??chk_mounted_3
   2110          		}
   2111          	}
   2112          
   2113          	/* The file system object is not valid. */
   2114          	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
   2115          
   2116          	fs->fs_type = 0;					/* Clear the file system object */
   \                     ??chk_mounted_5:
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x7020             STRB     R0,[R4, #+0]
   2117          	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
   \   00000066   0x7066             STRB     R6,[R4, #+1]
   2118          	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
   \   00000068   0x7860             LDRB     R0,[R4, #+1]
   \   0000006A   0x.... 0x....      BL       disk_initialize
   2119          	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
   \   0000006E   0x07C1             LSLS     R1,R0,#+31
   \   00000070   0xD501             BPL.N    ??chk_mounted_7
   2120          		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
   \   00000072   0x2003             MOVS     R0,#+3
   \   00000074   0xE17E             B.N      ??chk_mounted_3
   2121          	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
   \                     ??chk_mounted_7:
   \   00000076   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000078   0x2D00             CMP      R5,#+0
   \   0000007A   0xD003             BEQ.N    ??chk_mounted_8
   \   0000007C   0x0740             LSLS     R0,R0,#+29
   \   0000007E   0xD501             BPL.N    ??chk_mounted_8
   2122          		return FR_WRITE_PROTECTED;
   \   00000080   0x200A             MOVS     R0,#+10
   \   00000082   0xE177             B.N      ??chk_mounted_3
   2123          #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
   2124          	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
   2125          		return FR_DISK_ERR;
   2126          #endif
   2127          	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
   2128          	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
   \                     ??chk_mounted_8:
   \   00000084   0x2500             MOVS     R5,#+0
   \   00000086   0x0029             MOVS     R1,R5
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x.... 0x....      BL       check_fs
   \   0000008E   0x0006             MOVS     R6,R0
   2129          	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
   2130          	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
   \   00000090   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000092   0x2E01             CMP      R6,#+1
   \   00000094   0xD11C             BNE.N    ??chk_mounted_9
   2131          		/* Check the partition listed in the partition table */
   2132          		pi = LD2PT(vol);
   \   00000096   0x2000             MOVS     R0,#+0
   2133          		if (pi) pi--;
   \   00000098   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD000             BEQ.N    ??chk_mounted_10
   \   0000009E   0x1E40             SUBS     R0,R0,#+1
   2134          		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
   \                     ??chk_mounted_10:
   \   000000A0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A2   0xEB14 0x1000      ADDS     R0,R4,R0, LSL #+4
   \   000000A6   0xF200 0x10F6      ADDW     R0,R0,#+502
   2135          		if (tbl[4]) {						/* Is the partition existing? */
   \   000000AA   0x7901             LDRB     R1,[R0, #+4]
   \   000000AC   0x2900             CMP      R1,#+0
   \   000000AE   0xD00F             BEQ.N    ??chk_mounted_9
   2136          			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
   \   000000B0   0x7AC1             LDRB     R1,[R0, #+11]
   \   000000B2   0x7A82             LDRB     R2,[R0, #+10]
   \   000000B4   0x0412             LSLS     R2,R2,#+16
   \   000000B6   0xEA52 0x6101      ORRS     R1,R2,R1, LSL #+24
   \   000000BA   0x7A42             LDRB     R2,[R0, #+9]
   \   000000BC   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   000000C0   0x7A00             LDRB     R0,[R0, #+8]
   \   000000C2   0xEA50 0x0501      ORRS     R5,R0,R1
   2137          			fmt = check_fs(fs, bsect);		/* Check the partition */
   \   000000C6   0x0029             MOVS     R1,R5
   \   000000C8   0x0020             MOVS     R0,R4
   \   000000CA   0x.... 0x....      BL       check_fs
   \   000000CE   0x0006             MOVS     R6,R0
   2138          		}
   2139          	}
   2140          	if (fmt == 3) return FR_DISK_ERR;
   \                     ??chk_mounted_9:
   \   000000D0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D2   0x2E03             CMP      R6,#+3
   \   000000D4   0xD101             BNE.N    ??chk_mounted_11
   \   000000D6   0x2001             MOVS     R0,#+1
   \   000000D8   0xE14C             B.N      ??chk_mounted_3
   2141          	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
   \                     ??chk_mounted_11:
   \   000000DA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000DC   0x2E00             CMP      R6,#+0
   \   000000DE   0xD001             BEQ.N    ??chk_mounted_12
   \   000000E0   0x200D             MOVS     R0,#+13
   \   000000E2   0xE147             B.N      ??chk_mounted_3
   2142          
   2143          	/* An FAT volume is found. Following code initializes the file system object */
   2144          
   2145          	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
   \                     ??chk_mounted_12:
   \   000000E4   0xF894 0x0044      LDRB     R0,[R4, #+68]
   \   000000E8   0xF894 0x1043      LDRB     R1,[R4, #+67]
   \   000000EC   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000F0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000F2   0xF5B0 0x7F00      CMP      R0,#+512
   \   000000F6   0xD001             BEQ.N    ??chk_mounted_13
   2146          		return FR_NO_FILESYSTEM;
   \   000000F8   0x200D             MOVS     R0,#+13
   \   000000FA   0xE13B             B.N      ??chk_mounted_3
   2147          
   2148          	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
   \                     ??chk_mounted_13:
   \   000000FC   0xF894 0x004F      LDRB     R0,[R4, #+79]
   \   00000100   0xF894 0x104E      LDRB     R1,[R4, #+78]
   \   00000104   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000108   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   2149          	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
   \   0000010A   0x2800             CMP      R0,#+0
   \   0000010C   0xD10D             BNE.N    ??chk_mounted_14
   \   0000010E   0xF894 0x005F      LDRB     R0,[R4, #+95]
   \   00000112   0xF894 0x105E      LDRB     R1,[R4, #+94]
   \   00000116   0x0409             LSLS     R1,R1,#+16
   \   00000118   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   0000011C   0xF894 0x105D      LDRB     R1,[R4, #+93]
   \   00000120   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000124   0xF894 0x105C      LDRB     R1,[R4, #+92]
   \   00000128   0x4308             ORRS     R0,R1,R0
   2150          	fs->fsize = fasize;
   \                     ??chk_mounted_14:
   \   0000012A   0x6220             STR      R0,[R4, #+32]
   2151          
   2152          	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
   \   0000012C   0xF894 0x1048      LDRB     R1,[R4, #+72]
   \   00000130   0x70E1             STRB     R1,[R4, #+3]
   2153          	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
   \   00000132   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000134   0x2901             CMP      R1,#+1
   \   00000136   0xD004             BEQ.N    ??chk_mounted_15
   \   00000138   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000013A   0x2902             CMP      R1,#+2
   \   0000013C   0xD001             BEQ.N    ??chk_mounted_15
   \   0000013E   0x200D             MOVS     R0,#+13
   \   00000140   0xE118             B.N      ??chk_mounted_3
   2154          	fasize *= b;										/* Number of sectors for FAT area */
   \                     ??chk_mounted_15:
   \   00000142   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000144   0x4348             MULS     R0,R1,R0
   2155          
   2156          	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
   \   00000146   0xF894 0x1045      LDRB     R1,[R4, #+69]
   \   0000014A   0x70A1             STRB     R1,[R4, #+2]
   2157          	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
   \   0000014C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000014E   0x2900             CMP      R1,#+0
   \   00000150   0xD003             BEQ.N    ??chk_mounted_16
   \   00000152   0x1E4A             SUBS     R2,R1,#+1
   \   00000154   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000156   0x4211             TST      R1,R2
   \   00000158   0xD001             BEQ.N    ??chk_mounted_17
   \                     ??chk_mounted_16:
   \   0000015A   0x200D             MOVS     R0,#+13
   \   0000015C   0xE10A             B.N      ??chk_mounted_3
   2158          
   2159          	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
   \                     ??chk_mounted_17:
   \   0000015E   0xF894 0x104A      LDRB     R1,[R4, #+74]
   \   00000162   0xF894 0x2049      LDRB     R2,[R4, #+73]
   \   00000166   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   0000016A   0x8121             STRH     R1,[R4, #+8]
   2160          	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
   \   0000016C   0x8921             LDRH     R1,[R4, #+8]
   \   0000016E   0x2210             MOVS     R2,#+16
   \   00000170   0xFBB1 0xF3F2      UDIV     R3,R1,R2
   \   00000174   0xFB03 0x1312      MLS      R3,R3,R2,R1
   \   00000178   0x2B00             CMP      R3,#+0
   \   0000017A   0xD001             BEQ.N    ??chk_mounted_18
   \   0000017C   0x200D             MOVS     R0,#+13
   \   0000017E   0xE0F9             B.N      ??chk_mounted_3
   2161          
   2162          	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
   \                     ??chk_mounted_18:
   \   00000180   0xF894 0x104C      LDRB     R1,[R4, #+76]
   \   00000184   0xF894 0x204B      LDRB     R2,[R4, #+75]
   \   00000188   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   \   0000018C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   2163          	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
   \   0000018E   0x2A00             CMP      R2,#+0
   \   00000190   0xD10D             BNE.N    ??chk_mounted_19
   \   00000192   0xF894 0x105B      LDRB     R1,[R4, #+91]
   \   00000196   0xF894 0x205A      LDRB     R2,[R4, #+90]
   \   0000019A   0x0412             LSLS     R2,R2,#+16
   \   0000019C   0xEA52 0x6101      ORRS     R1,R2,R1, LSL #+24
   \   000001A0   0xF894 0x2059      LDRB     R2,[R4, #+89]
   \   000001A4   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   000001A8   0xF894 0x2058      LDRB     R2,[R4, #+88]
   \   000001AC   0x430A             ORRS     R2,R2,R1
   2164          
   2165          	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
   \                     ??chk_mounted_19:
   \   000001AE   0xF894 0x1047      LDRB     R1,[R4, #+71]
   \   000001B2   0xF894 0x3046      LDRB     R3,[R4, #+70]
   \   000001B6   0xEA53 0x2101      ORRS     R1,R3,R1, LSL #+8
   2166          	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
   \   000001BA   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000001BC   0x2900             CMP      R1,#+0
   \   000001BE   0xD101             BNE.N    ??chk_mounted_20
   \   000001C0   0x200D             MOVS     R0,#+13
   \   000001C2   0xE0D7             B.N      ??chk_mounted_3
   2167          
   2168          	/* Determine the FAT sub type */
   2169          	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
   \                     ??chk_mounted_20:
   \   000001C4   0xFA10 0xF381      UXTAH    R3,R0,R1
   \   000001C8   0x8926             LDRH     R6,[R4, #+8]
   \   000001CA   0xEB13 0x1316      ADDS     R3,R3,R6, LSR #+4
   2170          	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
   \   000001CE   0x429A             CMP      R2,R3
   \   000001D0   0xD201             BCS.N    ??chk_mounted_21
   \   000001D2   0x200D             MOVS     R0,#+13
   \   000001D4   0xE0CE             B.N      ??chk_mounted_3
   2171          	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
   \                     ??chk_mounted_21:
   \   000001D6   0x1AD2             SUBS     R2,R2,R3
   \   000001D8   0x78A6             LDRB     R6,[R4, #+2]
   \   000001DA   0xFBB2 0xF2F6      UDIV     R2,R2,R6
   2172          	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
   \   000001DE   0x2A00             CMP      R2,#+0
   \   000001E0   0xD101             BNE.N    ??chk_mounted_22
   \   000001E2   0x200D             MOVS     R0,#+13
   \   000001E4   0xE0C6             B.N      ??chk_mounted_3
   2173          	fmt = FS_FAT12;
   \                     ??chk_mounted_22:
   \   000001E6   0x2601             MOVS     R6,#+1
   2174          	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
   \   000001E8   0xF640 0x77F6      MOVW     R7,#+4086
   \   000001EC   0x42BA             CMP      R2,R7
   \   000001EE   0xD300             BCC.N    ??chk_mounted_23
   \   000001F0   0x2602             MOVS     R6,#+2
   2175          	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
   \                     ??chk_mounted_23:
   \   000001F2   0xF64F 0x77F6      MOVW     R7,#+65526
   \   000001F6   0x42BA             CMP      R2,R7
   \   000001F8   0xD300             BCC.N    ??chk_mounted_24
   \   000001FA   0x2603             MOVS     R6,#+3
   2176          
   2177          	/* Boundaries and Limits */
   2178          	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
   \                     ??chk_mounted_24:
   \   000001FC   0x1C92             ADDS     R2,R2,#+2
   \   000001FE   0x61E2             STR      R2,[R4, #+28]
   2179          	fs->volbase = bsect;								/* Volume start sector */
   \   00000200   0x6265             STR      R5,[R4, #+36]
   2180          	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
   \   00000202   0xFA15 0xF181      UXTAH    R1,R5,R1
   \   00000206   0x62A1             STR      R1,[R4, #+40]
   2181          	fs->database = bsect + sysect;						/* Data start sector */
   \   00000208   0x1959             ADDS     R1,R3,R5
   \   0000020A   0x6321             STR      R1,[R4, #+48]
   2182          	if (fmt == FS_FAT32) {
   \   0000020C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000020E   0x2E03             CMP      R6,#+3
   \   00000210   0xD116             BNE.N    ??chk_mounted_25
   2183          		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
   \   00000212   0x8920             LDRH     R0,[R4, #+8]
   \   00000214   0x2800             CMP      R0,#+0
   \   00000216   0xD001             BEQ.N    ??chk_mounted_26
   \   00000218   0x200D             MOVS     R0,#+13
   \   0000021A   0xE0AB             B.N      ??chk_mounted_3
   2184          		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
   \                     ??chk_mounted_26:
   \   0000021C   0xF894 0x0067      LDRB     R0,[R4, #+103]
   \   00000220   0xF894 0x1066      LDRB     R1,[R4, #+102]
   \   00000224   0x0409             LSLS     R1,R1,#+16
   \   00000226   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   0000022A   0xF894 0x1065      LDRB     R1,[R4, #+101]
   \   0000022E   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000232   0xF894 0x1064      LDRB     R1,[R4, #+100]
   \   00000236   0x4308             ORRS     R0,R1,R0
   \   00000238   0x62E0             STR      R0,[R4, #+44]
   2185          		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
   \   0000023A   0x69E0             LDR      R0,[R4, #+28]
   \   0000023C   0x0080             LSLS     R0,R0,#+2
   \   0000023E   0xE015             B.N      ??chk_mounted_27
   2186          	} else {
   2187          		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
   \                     ??chk_mounted_25:
   \   00000240   0x8921             LDRH     R1,[R4, #+8]
   \   00000242   0x2900             CMP      R1,#+0
   \   00000244   0xD101             BNE.N    ??chk_mounted_28
   \   00000246   0x200D             MOVS     R0,#+13
   \   00000248   0xE094             B.N      ??chk_mounted_3
   2188          		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
   \                     ??chk_mounted_28:
   \   0000024A   0x6AA1             LDR      R1,[R4, #+40]
   \   0000024C   0x1840             ADDS     R0,R0,R1
   \   0000024E   0x62E0             STR      R0,[R4, #+44]
   2189          		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
   2190          			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
   \   00000250   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000252   0x2E02             CMP      R6,#+2
   \   00000254   0xD102             BNE.N    ??chk_mounted_29
   \   00000256   0x69E0             LDR      R0,[R4, #+28]
   \   00000258   0x0040             LSLS     R0,R0,#+1
   \   0000025A   0xE007             B.N      ??chk_mounted_27
   \                     ??chk_mounted_29:
   \   0000025C   0x69E0             LDR      R0,[R4, #+28]
   \   0000025E   0x2103             MOVS     R1,#+3
   \   00000260   0x4348             MULS     R0,R1,R0
   \   00000262   0x7F21             LDRB     R1,[R4, #+28]
   \   00000264   0xF011 0x0101      ANDS     R1,R1,#0x1
   \   00000268   0xEB11 0x0050      ADDS     R0,R1,R0, LSR #+1
   2191          	}
   2192          	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
   \                     ??chk_mounted_27:
   \   0000026C   0x6A21             LDR      R1,[R4, #+32]
   \   0000026E   0xF200 0x10FF      ADDW     R0,R0,#+511
   \   00000272   0xEBB1 0x2F50      CMP      R1,R0, LSR #+9
   \   00000276   0xD201             BCS.N    ??chk_mounted_30
   2193          		return FR_NO_FILESYSTEM;
   \   00000278   0x200D             MOVS     R0,#+13
   \   0000027A   0xE07B             B.N      ??chk_mounted_3
   2194          
   2195          #if !_FS_READONLY
   2196          	/* Initialize cluster allocation information */
   2197          	fs->free_clust = 0xFFFFFFFF;
   \                     ??chk_mounted_30:
   \   0000027C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000280   0x6120             STR      R0,[R4, #+16]
   2198          	fs->last_clust = 0;
   \   00000282   0x2000             MOVS     R0,#+0
   \   00000284   0x60E0             STR      R0,[R4, #+12]
   2199          
   2200          	/* Get fsinfo if available */
   2201          	if (fmt == FS_FAT32) {
   \   00000286   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000288   0x2E03             CMP      R6,#+3
   \   0000028A   0xD160             BNE.N    ??chk_mounted_31
   2202          	 	fs->fsi_flag = 0;
   \   0000028C   0x2000             MOVS     R0,#+0
   \   0000028E   0x7160             STRB     R0,[R4, #+5]
   2203          		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
   \   00000290   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000294   0xF894 0x1068      LDRB     R1,[R4, #+104]
   \   00000298   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000029C   0xFA15 0xF080      UXTAH    R0,R5,R0
   \   000002A0   0x6160             STR      R0,[R4, #+20]
   2204          		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
   2205          			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
   2206          			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
   2207          			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
   \   000002A2   0x2301             MOVS     R3,#+1
   \   000002A4   0x6962             LDR      R2,[R4, #+20]
   \   000002A6   0xF114 0x0138      ADDS     R1,R4,#+56
   \   000002AA   0x7860             LDRB     R0,[R4, #+1]
   \   000002AC   0x.... 0x....      BL       disk_read
   \   000002B0   0x2800             CMP      R0,#+0
   \   000002B2   0xD14C             BNE.N    ??chk_mounted_31
   \   000002B4   0xF894 0x0237      LDRB     R0,[R4, #+567]
   \   000002B8   0xF894 0x1236      LDRB     R1,[R4, #+566]
   \   000002BC   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000002C0   0xF64A 0x2155      MOVW     R1,#+43605
   \   000002C4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000002C6   0x4288             CMP      R0,R1
   \   000002C8   0xD141             BNE.N    ??chk_mounted_31
   \   000002CA   0xF894 0x003B      LDRB     R0,[R4, #+59]
   \   000002CE   0xF894 0x103A      LDRB     R1,[R4, #+58]
   \   000002D2   0x0409             LSLS     R1,R1,#+16
   \   000002D4   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   000002D8   0xF894 0x1039      LDRB     R1,[R4, #+57]
   \   000002DC   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000002E0   0xF894 0x1038      LDRB     R1,[R4, #+56]
   \   000002E4   0x4308             ORRS     R0,R1,R0
   \   000002E6   0x.... 0x....      LDR.W    R1,??DataTable13_3  ;; 0x41615252
   \   000002EA   0x4288             CMP      R0,R1
   \   000002EC   0xD12F             BNE.N    ??chk_mounted_31
   \   000002EE   0xF894 0x021F      LDRB     R0,[R4, #+543]
   \   000002F2   0xF894 0x121E      LDRB     R1,[R4, #+542]
   \   000002F6   0x0409             LSLS     R1,R1,#+16
   \   000002F8   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   000002FC   0xF894 0x121D      LDRB     R1,[R4, #+541]
   \   00000300   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000304   0xF894 0x121C      LDRB     R1,[R4, #+540]
   \   00000308   0x4308             ORRS     R0,R1,R0
   \   0000030A   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x61417272
   \   0000030E   0x4288             CMP      R0,R1
   \   00000310   0xD11D             BNE.N    ??chk_mounted_31
   2208          				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
   \   00000312   0xF894 0x0227      LDRB     R0,[R4, #+551]
   \   00000316   0xF894 0x1226      LDRB     R1,[R4, #+550]
   \   0000031A   0x0409             LSLS     R1,R1,#+16
   \   0000031C   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   00000320   0xF894 0x1225      LDRB     R1,[R4, #+549]
   \   00000324   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000328   0xF894 0x1224      LDRB     R1,[R4, #+548]
   \   0000032C   0x4308             ORRS     R0,R1,R0
   \   0000032E   0x60E0             STR      R0,[R4, #+12]
   2209          				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
   \   00000330   0xF894 0x0223      LDRB     R0,[R4, #+547]
   \   00000334   0xF894 0x1222      LDRB     R1,[R4, #+546]
   \   00000338   0x0409             LSLS     R1,R1,#+16
   \   0000033A   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   0000033E   0xF894 0x1221      LDRB     R1,[R4, #+545]
   \   00000342   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000346   0xF894 0x1220      LDRB     R1,[R4, #+544]
   \   0000034A   0x4308             ORRS     R0,R1,R0
   \   0000034C   0x6120             STR      R0,[R4, #+16]
   2210          		}
   2211          	}
   2212          #endif
   2213          	fs->fs_type = fmt;		/* FAT sub-type */
   \                     ??chk_mounted_31:
   \   0000034E   0x7026             STRB     R6,[R4, #+0]
   2214          	fs->id = ++Fsid;		/* File system mount ID */
   \   00000350   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \   00000354   0x8800             LDRH     R0,[R0, #+0]
   \   00000356   0x1C40             ADDS     R0,R0,#+1
   \   00000358   0x.... 0x....      LDR.W    R1,??DataTable13_5
   \   0000035C   0x8008             STRH     R0,[R1, #+0]
   \   0000035E   0x80E0             STRH     R0,[R4, #+6]
   2215          	fs->winsect = 0;		/* Invalidate sector cache */
   \   00000360   0x2000             MOVS     R0,#+0
   \   00000362   0x6360             STR      R0,[R4, #+52]
   2216          	fs->wflag = 0;
   \   00000364   0x2000             MOVS     R0,#+0
   \   00000366   0x7120             STRB     R0,[R4, #+4]
   2217          #if _FS_RPATH
   2218          	fs->cdir = 0;			/* Current directory (root dir) */
   \   00000368   0x2000             MOVS     R0,#+0
   \   0000036A   0x61A0             STR      R0,[R4, #+24]
   2219          #endif
   2220          #if _FS_LOCK				/* Clear file lock semaphores */
   2221          	clear_lock(fs);
   \   0000036C   0x0020             MOVS     R0,R4
   \   0000036E   0x.... 0x....      BL       clear_lock
   2222          #endif
   2223          
   2224          	return FR_OK;
   \   00000372   0x2000             MOVS     R0,#+0
   \                     ??chk_mounted_3:
   \   00000374   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2225          }
   2226          
   2227          
   2228          
   2229          
   2230          /*-----------------------------------------------------------------------*/
   2231          /* Check if the file/dir object is valid or not                          */
   2232          /*-----------------------------------------------------------------------*/
   2233          

   \                                 In section .text, align 2, keep-with-next
   2234          static
   2235          FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
   2236          	void* obj		/* Pointer to the object FIL/DIR to check validity */
   2237          )
   2238          {
   \                     validate:
   \   00000000   0xB580             PUSH     {R7,LR}
   2239          	FIL *fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
   2240          
   2241          
   2242          	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD00B             BEQ.N    ??validate_0
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD008             BEQ.N    ??validate_0
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD004             BEQ.N    ??validate_0
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   \   00000016   0x88C9             LDRH     R1,[R1, #+6]
   \   00000018   0x8882             LDRH     R2,[R0, #+4]
   \   0000001A   0x4291             CMP      R1,R2
   \   0000001C   0xD001             BEQ.N    ??validate_1
   2243          		return FR_INVALID_OBJECT;
   \                     ??validate_0:
   \   0000001E   0x2009             MOVS     R0,#+9
   \   00000020   0xE008             B.N      ??validate_2
   2244          
   2245          	ENTER_FF(fil->fs);		/* Lock file system */
   2246          
   2247          	if (disk_status(fil->fs->drv) & STA_NOINIT)
   \                     ??validate_1:
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x7840             LDRB     R0,[R0, #+1]
   \   00000026   0x.... 0x....      BL       disk_status
   \   0000002A   0x07C0             LSLS     R0,R0,#+31
   \   0000002C   0xD501             BPL.N    ??validate_3
   2248          		return FR_NOT_READY;
   \   0000002E   0x2003             MOVS     R0,#+3
   \   00000030   0xE000             B.N      ??validate_2
   2249          
   2250          	return FR_OK;
   \                     ??validate_3:
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??validate_2:
   \   00000034   0xBD02             POP      {R1,PC}          ;; return
   2251          }
   2252          
   2253          
   2254          
   2255          
   2256          /*--------------------------------------------------------------------------
   2257          
   2258             Public Functions
   2259          
   2260          --------------------------------------------------------------------------*/
   2261          
   2262          
   2263          
   2264          /*-----------------------------------------------------------------------*/
   2265          /* Mount/Unmount a Logical Drive                                         */
   2266          /*-----------------------------------------------------------------------*/
   2267          

   \                                 In section .text, align 2, keep-with-next
   2268          FRESULT f_mount (
   2269          	BYTE vol,		/* Logical drive number to be mounted/unmounted */
   2270          	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
   2271          )
   2272          {
   \                     f_mount:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2273          	FATFS *rfs;
   2274          
   2275          
   2276          	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD301             BCC.N    ??f_mount_0
   2277          		return FR_INVALID_DRIVE;
   \   0000000C   0x200B             MOVS     R0,#+11
   \   0000000E   0xE015             B.N      ??f_mount_1
   2278          	rfs = FatFs[vol];			/* Get current fs object */
   \                     ??f_mount_0:
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   00000016   0xF850 0x6024      LDR      R6,[R0, R4, LSL #+2]
   2279          
   2280          	if (rfs) {
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD004             BEQ.N    ??f_mount_2
   2281          #if _FS_LOCK
   2282          		clear_lock(rfs);
   \   0000001E   0x0030             MOVS     R0,R6
   \   00000020   0x.... 0x....      BL       clear_lock
   2283          #endif
   2284          #if _FS_REENTRANT				/* Discard sync object of the current volume */
   2285          		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
   2286          #endif
   2287          		rfs->fs_type = 0;		/* Clear old fs object */
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x7030             STRB     R0,[R6, #+0]
   2288          	}
   2289          
   2290          	if (fs) {
   \                     ??f_mount_2:
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD001             BEQ.N    ??f_mount_3
   2291          		fs->fs_type = 0;		/* Clear new fs object */
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x7028             STRB     R0,[R5, #+0]
   2292          #if _FS_REENTRANT				/* Create sync object for the new volume */
   2293          		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
   2294          #endif
   2295          	}
   2296          	FatFs[vol] = fs;			/* Register new fs object */
   \                     ??f_mount_3:
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   00000036   0xF840 0x5024      STR      R5,[R0, R4, LSL #+2]
   2297          
   2298          	return FR_OK;
   \   0000003A   0x2000             MOVS     R0,#+0
   \                     ??f_mount_1:
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
   2299          }
   2300          
   2301          
   2302          
   2303          
   2304          /*-----------------------------------------------------------------------*/
   2305          /* Open or Create a File                                                 */
   2306          /*-----------------------------------------------------------------------*/
   2307          

   \                                 In section .text, align 2, keep-with-next
   2308          FRESULT f_open (
   2309          	FIL *fp,			/* Pointer to the blank file object */
   2310          	const TCHAR *path,	/* Pointer to the file name */
   2311          	BYTE mode			/* Access mode and file open mode flags */
   2312          )
   2313          {
   \                     f_open:
   \   00000000   0xE92D 0x47F2      PUSH     {R1,R4-R10,LR}
   \   00000004   0xB08D             SUB      SP,SP,#+52
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x0016             MOVS     R6,R2
   2314          	FRESULT res;
   2315          	DIR dj;
   2316          	BYTE *dir;
   2317          	DEF_NAMEBUF;
   2318          
   2319          
   2320          	if (!fp) return FR_INVALID_OBJECT;
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD101             BNE.N    ??f_open_0
   \   0000000E   0x2009             MOVS     R0,#+9
   \   00000010   0xE0F6             B.N      ??f_open_1
   2321          	fp->fs = 0;			/* Clear file object */
   \                     ??f_open_0:
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x6020             STR      R0,[R4, #+0]
   2322          
   2323          #if !_FS_READONLY
   2324          	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
   \   00000016   0xF016 0x061F      ANDS     R6,R6,#0x1F
   2325          	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
   \   0000001A   0xF016 0x02FE      ANDS     R2,R6,#0xFE
   \   0000001E   0xA900             ADD      R1,SP,#+0
   \   00000020   0xA80D             ADD      R0,SP,#+52
   \   00000022   0x.... 0x....      BL       chk_mounted
   \   00000026   0x4680             MOV      R8,R0
   2326          #else
   2327          	mode &= FA_READ;
   2328          	res = chk_mounted(&path, &dj.fs, 0);
   2329          #endif
   2330          	if (res == FR_OK) {
   \   00000028   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000002C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000030   0xF040 0x80E4      BNE.W    ??f_open_2
   2331          		INIT_BUF(dj);
   \   00000034   0x2082             MOVS     R0,#+130
   \   00000036   0x.... 0x....      BL       ff_memalloc
   \   0000003A   0x0005             MOVS     R5,R0
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD101             BNE.N    ??f_open_3
   \   00000040   0x2011             MOVS     R0,#+17
   \   00000042   0xE0DD             B.N      ??f_open_1
   \                     ??f_open_3:
   \   00000044   0x9507             STR      R5,[SP, #+28]
   \   00000046   0xA809             ADD      R0,SP,#+36
   \   00000048   0x9006             STR      R0,[SP, #+24]
   2332          		res = follow_path(&dj, path);	/* Follow the file path */
   \   0000004A   0x990D             LDR      R1,[SP, #+52]
   \   0000004C   0xA800             ADD      R0,SP,#+0
   \   0000004E   0x.... 0x....      BL       follow_path
   \   00000052   0x4680             MOV      R8,R0
   2333          		dir = dj.dir;
   \   00000054   0x9F05             LDR      R7,[SP, #+20]
   2334          #if !_FS_READONLY	/* R/W configuration */
   2335          		if (res == FR_OK) {
   \   00000056   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000005A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000005E   0xD10E             BNE.N    ??f_open_4
   2336          			if (!dir)	/* Current dir itself */
   \   00000060   0x2F00             CMP      R7,#+0
   \   00000062   0xD102             BNE.N    ??f_open_5
   2337          				res = FR_INVALID_NAME;
   \   00000064   0xF05F 0x0806      MOVS     R8,#+6
   \   00000068   0xE009             B.N      ??f_open_4
   2338          #if _FS_LOCK
   2339          			else
   2340          				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   \                     ??f_open_5:
   \   0000006A   0x20FE             MOVS     R0,#+254
   \   0000006C   0x4206             TST      R6,R0
   \   0000006E   0xD001             BEQ.N    ??f_open_6
   \   00000070   0x2101             MOVS     R1,#+1
   \   00000072   0xE000             B.N      ??f_open_7
   \                     ??f_open_6:
   \   00000074   0x2100             MOVS     R1,#+0
   \                     ??f_open_7:
   \   00000076   0xA800             ADD      R0,SP,#+0
   \   00000078   0x.... 0x....      BL       chk_lock
   \   0000007C   0x4680             MOV      R8,R0
   2341          #endif
   2342          		}
   2343          		/* Create or Open a file */
   2344          		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
   \                     ??f_open_4:
   \   0000007E   0x201C             MOVS     R0,#+28
   \   00000080   0x4206             TST      R6,R0
   \   00000082   0xD069             BEQ.N    ??f_open_8
   2345          			DWORD dw, cl;
   2346          
   2347          			if (res != FR_OK) {					/* No file, create new */
   \   00000084   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000088   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000008C   0xD013             BEQ.N    ??f_open_9
   2348          				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
   \   0000008E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000092   0xF1B8 0x0F04      CMP      R8,#+4
   \   00000096   0xD10A             BNE.N    ??f_open_10
   2349          #if _FS_LOCK
   2350          					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
   \   00000098   0x.... 0x....      BL       enq_lock
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD004             BEQ.N    ??f_open_11
   \   000000A0   0xA800             ADD      R0,SP,#+0
   \   000000A2   0x.... 0x....      BL       dir_register
   \   000000A6   0x4680             MOV      R8,R0
   \   000000A8   0xE001             B.N      ??f_open_12
   \                     ??f_open_11:
   \   000000AA   0xF05F 0x0812      MOVS     R8,#+18
   2351          #else
   2352          					res = dir_register(&dj);
   2353          #endif
   2354          				mode |= FA_CREATE_ALWAYS;		/* File is created */
   \                     ??f_open_12:
   \                     ??f_open_10:
   \   000000AE   0xF056 0x0608      ORRS     R6,R6,#0x8
   2355          				dir = dj.dir;					/* New entry */
   \   000000B2   0x9F05             LDR      R7,[SP, #+20]
   \   000000B4   0xE00A             B.N      ??f_open_13
   2356          			}
   2357          			else {								/* Any object is already existing */
   2358          				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
   \                     ??f_open_9:
   \   000000B6   0x7AF8             LDRB     R0,[R7, #+11]
   \   000000B8   0x2111             MOVS     R1,#+17
   \   000000BA   0x4208             TST      R0,R1
   \   000000BC   0xD002             BEQ.N    ??f_open_14
   2359          					res = FR_DENIED;
   \   000000BE   0xF05F 0x0807      MOVS     R8,#+7
   \   000000C2   0xE003             B.N      ??f_open_13
   2360          				} else {
   2361          					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
   \                     ??f_open_14:
   \   000000C4   0x0770             LSLS     R0,R6,#+29
   \   000000C6   0xD501             BPL.N    ??f_open_13
   2362          						res = FR_EXIST;
   \   000000C8   0xF05F 0x0808      MOVS     R8,#+8
   2363          				}
   2364          			}
   2365          			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
   \                     ??f_open_13:
   \   000000CC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000D0   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000D4   0xD152             BNE.N    ??f_open_15
   \   000000D6   0x0730             LSLS     R0,R6,#+28
   \   000000D8   0xD550             BPL.N    ??f_open_15
   2366          				dw = get_fattime();					/* Created time */
   \   000000DA   0x.... 0x....      BL       get_fattime
   \   000000DE   0x4681             MOV      R9,R0
   2367          				ST_DWORD(dir+DIR_CrtTime, dw);
   \   000000E0   0xF887 0x900E      STRB     R9,[R7, #+14]
   \   000000E4   0x4648             MOV      R0,R9
   \   000000E6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000E8   0x0A00             LSRS     R0,R0,#+8
   \   000000EA   0x73F8             STRB     R0,[R7, #+15]
   \   000000EC   0xEA5F 0x4019      LSRS     R0,R9,#+16
   \   000000F0   0x7438             STRB     R0,[R7, #+16]
   \   000000F2   0xEA5F 0x6019      LSRS     R0,R9,#+24
   \   000000F6   0x7478             STRB     R0,[R7, #+17]
   2368          				dir[DIR_Attr] = 0;					/* Reset attribute */
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0x72F8             STRB     R0,[R7, #+11]
   2369          				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0x7738             STRB     R0,[R7, #+28]
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x7778             STRB     R0,[R7, #+29]
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0x77B8             STRB     R0,[R7, #+30]
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0x77F8             STRB     R0,[R7, #+31]
   2370          				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
   \   0000010C   0x0039             MOVS     R1,R7
   \   0000010E   0x9800             LDR      R0,[SP, #+0]
   \   00000110   0x.... 0x....      BL       ld_clust
   \   00000114   0x4682             MOV      R10,R0
   2371          				st_clust(dir, 0);					/* cluster = 0 */
   \   00000116   0x2100             MOVS     R1,#+0
   \   00000118   0x0038             MOVS     R0,R7
   \   0000011A   0x.... 0x....      BL       st_clust
   2372          				dj.fs->wflag = 1;
   \   0000011E   0x9800             LDR      R0,[SP, #+0]
   \   00000120   0x2101             MOVS     R1,#+1
   \   00000122   0x7101             STRB     R1,[R0, #+4]
   2373          				if (cl) {							/* Remove the cluster chain if exist */
   \   00000124   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000128   0xD028             BEQ.N    ??f_open_15
   2374          					dw = dj.fs->winsect;
   \   0000012A   0x9800             LDR      R0,[SP, #+0]
   \   0000012C   0xF8D0 0x9034      LDR      R9,[R0, #+52]
   2375          					res = remove_chain(dj.fs, cl);
   \   00000130   0x4651             MOV      R1,R10
   \   00000132   0x9800             LDR      R0,[SP, #+0]
   \   00000134   0x.... 0x....      BL       remove_chain
   \   00000138   0x4680             MOV      R8,R0
   2376          					if (res == FR_OK) {
   \   0000013A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000013E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000142   0xD11B             BNE.N    ??f_open_15
   2377          						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
   \   00000144   0x9800             LDR      R0,[SP, #+0]
   \   00000146   0xF1BA 0x0101      SUBS     R1,R10,#+1
   \   0000014A   0x60C1             STR      R1,[R0, #+12]
   2378          						res = move_window(dj.fs, dw);
   \   0000014C   0x4649             MOV      R1,R9
   \   0000014E   0x9800             LDR      R0,[SP, #+0]
   \   00000150   0x.... 0x....      BL       move_window
   \   00000154   0x4680             MOV      R8,R0
   \   00000156   0xE011             B.N      ??f_open_15
   2379          					}
   2380          				}
   2381          			}
   2382          		}
   2383          		else {	/* Open an existing file */
   2384          			if (res == FR_OK) {						/* Follow succeeded */
   \                     ??f_open_8:
   \   00000158   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000015C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000160   0xD10C             BNE.N    ??f_open_15
   2385          				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
   \   00000162   0x7AF8             LDRB     R0,[R7, #+11]
   \   00000164   0x06C0             LSLS     R0,R0,#+27
   \   00000166   0xD502             BPL.N    ??f_open_16
   2386          					res = FR_NO_FILE;
   \   00000168   0xF05F 0x0804      MOVS     R8,#+4
   \   0000016C   0xE006             B.N      ??f_open_15
   2387          				} else {
   2388          					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
   \                     ??f_open_16:
   \   0000016E   0x07B0             LSLS     R0,R6,#+30
   \   00000170   0xD504             BPL.N    ??f_open_15
   \   00000172   0x7AF8             LDRB     R0,[R7, #+11]
   \   00000174   0x07C0             LSLS     R0,R0,#+31
   \   00000176   0xD501             BPL.N    ??f_open_15
   2389          						res = FR_DENIED;
   \   00000178   0xF05F 0x0807      MOVS     R8,#+7
   2390          				}
   2391          			}
   2392          		}
   2393          		if (res == FR_OK) {
   \                     ??f_open_15:
   \   0000017C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000180   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000184   0xD116             BNE.N    ??f_open_17
   2394          			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
   \   00000186   0x0730             LSLS     R0,R6,#+28
   \   00000188   0xD501             BPL.N    ??f_open_18
   2395          				mode |= FA__WRITTEN;
   \   0000018A   0xF056 0x0620      ORRS     R6,R6,#0x20
   2396          			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
   \                     ??f_open_18:
   \   0000018E   0x9800             LDR      R0,[SP, #+0]
   \   00000190   0x6B40             LDR      R0,[R0, #+52]
   \   00000192   0x61E0             STR      R0,[R4, #+28]
   2397          			fp->dir_ptr = dir;
   \   00000194   0x6227             STR      R7,[R4, #+32]
   2398          #if _FS_LOCK
   2399          			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   \   00000196   0x20FE             MOVS     R0,#+254
   \   00000198   0x4206             TST      R6,R0
   \   0000019A   0xD001             BEQ.N    ??f_open_19
   \   0000019C   0x2101             MOVS     R1,#+1
   \   0000019E   0xE000             B.N      ??f_open_20
   \                     ??f_open_19:
   \   000001A0   0x2100             MOVS     R1,#+0
   \                     ??f_open_20:
   \   000001A2   0xA800             ADD      R0,SP,#+0
   \   000001A4   0x.... 0x....      BL       inc_lock
   \   000001A8   0x62A0             STR      R0,[R4, #+40]
   2400          			if (!fp->lockid) res = FR_INT_ERR;
   \   000001AA   0x6AA0             LDR      R0,[R4, #+40]
   \   000001AC   0x2800             CMP      R0,#+0
   \   000001AE   0xD101             BNE.N    ??f_open_17
   \   000001B0   0xF05F 0x0802      MOVS     R8,#+2
   2401          #endif
   2402          		}
   2403          
   2404          #else				/* R/O configuration */
   2405          		if (res == FR_OK) {					/* Follow succeeded */
   2406          			dir = dj.dir;
   2407          			if (!dir) {						/* Current dir itself */
   2408          				res = FR_INVALID_NAME;
   2409          			} else {
   2410          				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
   2411          					res = FR_NO_FILE;
   2412          			}
   2413          		}
   2414          #endif
   2415          		FREE_BUF();
   \                     ??f_open_17:
   \   000001B4   0x0028             MOVS     R0,R5
   \   000001B6   0x.... 0x....      BL       ff_memfree
   2416          
   2417          		if (res == FR_OK) {
   \   000001BA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001BE   0xF1B8 0x0F00      CMP      R8,#+0
   \   000001C2   0xD11B             BNE.N    ??f_open_2
   2418          			fp->flag = mode;					/* File access mode */
   \   000001C4   0x71A6             STRB     R6,[R4, #+6]
   2419          			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
   \   000001C6   0x0039             MOVS     R1,R7
   \   000001C8   0x9800             LDR      R0,[SP, #+0]
   \   000001CA   0x.... 0x....      BL       ld_clust
   \   000001CE   0x6120             STR      R0,[R4, #+16]
   2420          			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
   \   000001D0   0x7FF8             LDRB     R0,[R7, #+31]
   \   000001D2   0x7FB9             LDRB     R1,[R7, #+30]
   \   000001D4   0x0409             LSLS     R1,R1,#+16
   \   000001D6   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   000001DA   0x7F79             LDRB     R1,[R7, #+29]
   \   000001DC   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000001E0   0x7F39             LDRB     R1,[R7, #+28]
   \   000001E2   0x4308             ORRS     R0,R1,R0
   \   000001E4   0x60E0             STR      R0,[R4, #+12]
   2421          			fp->fptr = 0;						/* File pointer */
   \   000001E6   0x2000             MOVS     R0,#+0
   \   000001E8   0x60A0             STR      R0,[R4, #+8]
   2422          			fp->dsect = 0;
   \   000001EA   0x2000             MOVS     R0,#+0
   \   000001EC   0x61A0             STR      R0,[R4, #+24]
   2423          #if _USE_FASTSEEK
   2424          			fp->cltbl = 0;						/* Normal seek mode */
   \   000001EE   0x2000             MOVS     R0,#+0
   \   000001F0   0x6260             STR      R0,[R4, #+36]
   2425          #endif
   2426          			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
   \   000001F2   0x9800             LDR      R0,[SP, #+0]
   \   000001F4   0x6020             STR      R0,[R4, #+0]
   \   000001F6   0x9800             LDR      R0,[SP, #+0]
   \   000001F8   0x88C0             LDRH     R0,[R0, #+6]
   \   000001FA   0x80A0             STRH     R0,[R4, #+4]
   2427          		}
   2428          	}
   2429          
   2430          	LEAVE_FF(dj.fs, res);
   \                     ??f_open_2:
   \   000001FC   0x4640             MOV      R0,R8
   \   000001FE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_open_1:
   \   00000200   0xB00E             ADD      SP,SP,#+56
   \   00000202   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   2431          }
   2432          
   2433          
   2434          
   2435          
   2436          /*-----------------------------------------------------------------------*/
   2437          /* Read File                                                             */
   2438          /*-----------------------------------------------------------------------*/
   2439          

   \                                 In section .text, align 2, keep-with-next
   2440          FRESULT f_read (
   2441          	FIL *fp, 		/* Pointer to the file object */
   2442          	void *buff,		/* Pointer to data buffer */
   2443          	UINT btr,		/* Number of bytes to read */
   2444          	UINT *br		/* Pointer to number of bytes read */
   2445          )
   2446          {
   \                     f_read:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
   2447          	FRESULT res;
   2448          	DWORD clst, sect, remain;
   2449          	UINT rcnt, cc;
   2450          	BYTE csect, *rbuff = (BYTE*)buff;
   \   0000000A   0x000C             MOVS     R4,R1
   2451          
   2452          
   2453          	*br = 0;	/* Clear read byte counter */
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6038             STR      R0,[R7, #+0]
   2454          
   2455          	res = validate(fp);							/* Check validity */
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0x.... 0x....      BL       validate
   2456          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD001             BEQ.N    ??f_read_0
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0xE0EB             B.N      ??f_read_1
   2457          	if (fp->flag & FA__ERROR)					/* Aborted file? */
   \                     ??f_read_0:
   \   00000020   0x79A8             LDRB     R0,[R5, #+6]
   \   00000022   0x0600             LSLS     R0,R0,#+24
   \   00000024   0xD501             BPL.N    ??f_read_2
   2458          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xE0E6             B.N      ??f_read_1
   2459          	if (!(fp->flag & FA_READ)) 					/* Check access mode */
   \                     ??f_read_2:
   \   0000002A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000002C   0x07C0             LSLS     R0,R0,#+31
   \   0000002E   0xD401             BMI.N    ??f_read_3
   2460          		LEAVE_FF(fp->fs, FR_DENIED);
   \   00000030   0x2007             MOVS     R0,#+7
   \   00000032   0xE0E1             B.N      ??f_read_1
   2461          	remain = fp->fsize - fp->fptr;
   \                     ??f_read_3:
   \   00000034   0x68E8             LDR      R0,[R5, #+12]
   \   00000036   0x68A9             LDR      R1,[R5, #+8]
   \   00000038   0x1A40             SUBS     R0,R0,R1
   2462          	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
   \   0000003A   0x42B0             CMP      R0,R6
   \   0000003C   0xD229             BCS.N    ??f_read_4
   \   0000003E   0x0006             MOVS     R6,R0
   \   00000040   0xE027             B.N      ??f_read_4
   2463          
   2464          	for ( ;  btr;								/* Repeat until all data read */
   2465          		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
   2466          		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
   2467          			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   2468          			if (!csect) {						/* On the cluster boundary? */
   2469          				if (fp->fptr == 0) {			/* On the top of the file? */
   2470          					clst = fp->sclust;			/* Follow from the origin */
   2471          				} else {						/* Middle or end of the file */
   2472          #if _USE_FASTSEEK
   2473          					if (fp->cltbl)
   2474          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   2475          					else
   2476          #endif
   2477          						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
   2478          				}
   2479          				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
   2480          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2481          				fp->clust = clst;				/* Update current cluster */
   2482          			}
   2483          			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   2484          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   2485          			sect += csect;
   2486          			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
   2487          			if (cc) {							/* Read maximum contiguous sectors directly */
   2488          				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   2489          					cc = fp->fs->csize - csect;
   2490          				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
   2491          					ABORT(fp->fs, FR_DISK_ERR);
   2492          #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
   2493          #if _FS_TINY
   2494          				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
   2495          					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
   2496          #else
   2497          				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
   2498          					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
   2499          #endif
   2500          #endif
   2501          				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
   2502          				continue;
   2503          			}
   2504          #if !_FS_TINY
   2505          			if (fp->dsect != sect) {			/* Load data sector if not in cache */
   2506          #if !_FS_READONLY
   2507          				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
   2508          					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2509          						ABORT(fp->fs, FR_DISK_ERR);
   2510          					fp->flag &= ~FA__DIRTY;
   2511          				}
   2512          #endif
   2513          				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
   2514          					ABORT(fp->fs, FR_DISK_ERR);
   2515          			}
   2516          #endif
   2517          			fp->dsect = sect;
   \                     ??f_read_5:
   \   00000042   0xF8C5 0x9018      STR      R9,[R5, #+24]
   2518          		}
   2519          		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
   \                     ??f_read_6:
   \   00000046   0x68A8             LDR      R0,[R5, #+8]
   \   00000048   0xF44F 0x7100      MOV      R1,#+512
   \   0000004C   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   00000050   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   00000054   0xF5D2 0x7800      RSBS     R8,R2,#+512
   2520          		if (rcnt > btr) rcnt = btr;
   \   00000058   0x4546             CMP      R6,R8
   \   0000005A   0xD200             BCS.N    ??f_read_7
   \   0000005C   0x46B0             MOV      R8,R6
   2521          #if _FS_TINY
   2522          		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
   2523          			ABORT(fp->fs, FR_DISK_ERR);
   2524          		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   2525          #else
   2526          		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   \                     ??f_read_7:
   \   0000005E   0x4642             MOV      R2,R8
   \   00000060   0x68A8             LDR      R0,[R5, #+8]
   \   00000062   0xF44F 0x7100      MOV      R1,#+512
   \   00000066   0xFBB0 0xF3F1      UDIV     R3,R0,R1
   \   0000006A   0xFB03 0x0311      MLS      R3,R3,R1,R0
   \   0000006E   0x1958             ADDS     R0,R3,R5
   \   00000070   0xF110 0x012C      ADDS     R1,R0,#+44
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       mem_cpy
   \                     ??f_read_8:
   \   0000007A   0xEB18 0x0404      ADDS     R4,R8,R4
   \   0000007E   0x68A8             LDR      R0,[R5, #+8]
   \   00000080   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000084   0x60A8             STR      R0,[R5, #+8]
   \   00000086   0x6838             LDR      R0,[R7, #+0]
   \   00000088   0xEB18 0x0000      ADDS     R0,R8,R0
   \   0000008C   0x6038             STR      R0,[R7, #+0]
   \   0000008E   0xEBB6 0x0608      SUBS     R6,R6,R8
   \                     ??f_read_4:
   \   00000092   0x2E00             CMP      R6,#+0
   \   00000094   0xF000 0x80AF      BEQ.W    ??f_read_9
   \   00000098   0x68A8             LDR      R0,[R5, #+8]
   \   0000009A   0xF44F 0x7100      MOV      R1,#+512
   \   0000009E   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   000000A2   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   000000A6   0x2A00             CMP      R2,#+0
   \   000000A8   0xD1CD             BNE.N    ??f_read_6
   \   000000AA   0x68A8             LDR      R0,[R5, #+8]
   \   000000AC   0x0A40             LSRS     R0,R0,#+9
   \   000000AE   0x6829             LDR      R1,[R5, #+0]
   \   000000B0   0x7889             LDRB     R1,[R1, #+2]
   \   000000B2   0x1E49             SUBS     R1,R1,#+1
   \   000000B4   0xEA11 0x0800      ANDS     R8,R1,R0
   \   000000B8   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000BC   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000C0   0xD122             BNE.N    ??f_read_10
   \   000000C2   0x68A8             LDR      R0,[R5, #+8]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD101             BNE.N    ??f_read_11
   \   000000C8   0x6928             LDR      R0,[R5, #+16]
   \   000000CA   0xE00B             B.N      ??f_read_12
   \                     ??f_read_11:
   \   000000CC   0x6A68             LDR      R0,[R5, #+36]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD004             BEQ.N    ??f_read_13
   \   000000D2   0x68A9             LDR      R1,[R5, #+8]
   \   000000D4   0x0028             MOVS     R0,R5
   \   000000D6   0x.... 0x....      BL       clmt_clust
   \   000000DA   0xE003             B.N      ??f_read_12
   \                     ??f_read_13:
   \   000000DC   0x6969             LDR      R1,[R5, #+20]
   \   000000DE   0x6828             LDR      R0,[R5, #+0]
   \   000000E0   0x.... 0x....      BL       get_fat
   \                     ??f_read_12:
   \   000000E4   0x2802             CMP      R0,#+2
   \   000000E6   0xD205             BCS.N    ??f_read_14
   \   000000E8   0x79A8             LDRB     R0,[R5, #+6]
   \   000000EA   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000EE   0x71A8             STRB     R0,[R5, #+6]
   \   000000F0   0x2002             MOVS     R0,#+2
   \   000000F2   0xE081             B.N      ??f_read_1
   \                     ??f_read_14:
   \   000000F4   0xF110 0x0F01      CMN      R0,#+1
   \   000000F8   0xD105             BNE.N    ??f_read_15
   \   000000FA   0x79A8             LDRB     R0,[R5, #+6]
   \   000000FC   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000100   0x71A8             STRB     R0,[R5, #+6]
   \   00000102   0x2001             MOVS     R0,#+1
   \   00000104   0xE078             B.N      ??f_read_1
   \                     ??f_read_15:
   \   00000106   0x6168             STR      R0,[R5, #+20]
   \                     ??f_read_10:
   \   00000108   0x6969             LDR      R1,[R5, #+20]
   \   0000010A   0x6828             LDR      R0,[R5, #+0]
   \   0000010C   0x.... 0x....      BL       clust2sect
   \   00000110   0x4681             MOV      R9,R0
   \   00000112   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000116   0xD105             BNE.N    ??f_read_16
   \   00000118   0x79A8             LDRB     R0,[R5, #+6]
   \   0000011A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000011E   0x71A8             STRB     R0,[R5, #+6]
   \   00000120   0x2002             MOVS     R0,#+2
   \   00000122   0xE069             B.N      ??f_read_1
   \                     ??f_read_16:
   \   00000124   0xFA59 0xF988      UXTAB    R9,R9,R8
   \   00000128   0xEA5F 0x2A56      LSRS     R10,R6,#+9
   \   0000012C   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000130   0xD035             BEQ.N    ??f_read_17
   \   00000132   0x6828             LDR      R0,[R5, #+0]
   \   00000134   0x7880             LDRB     R0,[R0, #+2]
   \   00000136   0xFA5A 0xF188      UXTAB    R1,R10,R8
   \   0000013A   0x4288             CMP      R0,R1
   \   0000013C   0xD205             BCS.N    ??f_read_18
   \   0000013E   0x6828             LDR      R0,[R5, #+0]
   \   00000140   0x7880             LDRB     R0,[R0, #+2]
   \   00000142   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000146   0xEBB0 0x0A08      SUBS     R10,R0,R8
   \                     ??f_read_18:
   \   0000014A   0x4653             MOV      R3,R10
   \   0000014C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000014E   0x464A             MOV      R2,R9
   \   00000150   0x0021             MOVS     R1,R4
   \   00000152   0x6828             LDR      R0,[R5, #+0]
   \   00000154   0x7840             LDRB     R0,[R0, #+1]
   \   00000156   0x.... 0x....      BL       disk_read
   \   0000015A   0x2800             CMP      R0,#+0
   \   0000015C   0xD005             BEQ.N    ??f_read_19
   \   0000015E   0x79A8             LDRB     R0,[R5, #+6]
   \   00000160   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000164   0x71A8             STRB     R0,[R5, #+6]
   \   00000166   0x2001             MOVS     R0,#+1
   \   00000168   0xE046             B.N      ??f_read_1
   \                     ??f_read_19:
   \   0000016A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000016C   0x0640             LSLS     R0,R0,#+25
   \   0000016E   0xD511             BPL.N    ??f_read_20
   \   00000170   0x69A8             LDR      R0,[R5, #+24]
   \   00000172   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   00000176   0x4550             CMP      R0,R10
   \   00000178   0xD20C             BCS.N    ??f_read_20
   \   0000017A   0xF44F 0x7200      MOV      R2,#+512
   \   0000017E   0xF115 0x012C      ADDS     R1,R5,#+44
   \   00000182   0x69A8             LDR      R0,[R5, #+24]
   \   00000184   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   00000188   0xF44F 0x7300      MOV      R3,#+512
   \   0000018C   0xFB03 0x4000      MLA      R0,R3,R0,R4
   \   00000190   0x.... 0x....      BL       mem_cpy
   \                     ??f_read_20:
   \   00000194   0xF44F 0x7000      MOV      R0,#+512
   \   00000198   0xFB00 0xF80A      MUL      R8,R0,R10
   \   0000019C   0xE76D             B.N      ??f_read_8
   \                     ??f_read_17:
   \   0000019E   0x69A8             LDR      R0,[R5, #+24]
   \   000001A0   0x4548             CMP      R0,R9
   \   000001A2   0xF43F 0xAF4E      BEQ.W    ??f_read_5
   \   000001A6   0x79A8             LDRB     R0,[R5, #+6]
   \   000001A8   0x0640             LSLS     R0,R0,#+25
   \   000001AA   0xD513             BPL.N    ??f_read_21
   \   000001AC   0x2301             MOVS     R3,#+1
   \   000001AE   0x69AA             LDR      R2,[R5, #+24]
   \   000001B0   0xF115 0x012C      ADDS     R1,R5,#+44
   \   000001B4   0x6828             LDR      R0,[R5, #+0]
   \   000001B6   0x7840             LDRB     R0,[R0, #+1]
   \   000001B8   0x.... 0x....      BL       disk_write
   \   000001BC   0x2800             CMP      R0,#+0
   \   000001BE   0xD005             BEQ.N    ??f_read_22
   \   000001C0   0x79A8             LDRB     R0,[R5, #+6]
   \   000001C2   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000001C6   0x71A8             STRB     R0,[R5, #+6]
   \   000001C8   0x2001             MOVS     R0,#+1
   \   000001CA   0xE015             B.N      ??f_read_1
   \                     ??f_read_22:
   \   000001CC   0x79A8             LDRB     R0,[R5, #+6]
   \   000001CE   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   000001D2   0x71A8             STRB     R0,[R5, #+6]
   \                     ??f_read_21:
   \   000001D4   0x2301             MOVS     R3,#+1
   \   000001D6   0x464A             MOV      R2,R9
   \   000001D8   0xF115 0x012C      ADDS     R1,R5,#+44
   \   000001DC   0x6828             LDR      R0,[R5, #+0]
   \   000001DE   0x7840             LDRB     R0,[R0, #+1]
   \   000001E0   0x.... 0x....      BL       disk_read
   \   000001E4   0x2800             CMP      R0,#+0
   \   000001E6   0xF43F 0xAF2C      BEQ.W    ??f_read_5
   \   000001EA   0x79A8             LDRB     R0,[R5, #+6]
   \   000001EC   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000001F0   0x71A8             STRB     R0,[R5, #+6]
   \   000001F2   0x2001             MOVS     R0,#+1
   \   000001F4   0xE000             B.N      ??f_read_1
   2527          #endif
   2528          	}
   2529          
   2530          	LEAVE_FF(fp->fs, FR_OK);
   \                     ??f_read_9:
   \   000001F6   0x2000             MOVS     R0,#+0
   \                     ??f_read_1:
   \   000001F8   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   2531          }
   2532          
   2533          
   2534          
   2535          
   2536          #if !_FS_READONLY
   2537          /*-----------------------------------------------------------------------*/
   2538          /* Write File                                                            */
   2539          /*-----------------------------------------------------------------------*/
   2540          

   \                                 In section .text, align 2, keep-with-next
   2541          FRESULT f_write (
   2542          	FIL *fp,			/* Pointer to the file object */
   2543          	const void *buff,	/* Pointer to the data to be written */
   2544          	UINT btw,			/* Number of bytes to write */
   2545          	UINT *bw			/* Pointer to number of bytes written */
   2546          )
   2547          {
   \                     f_write:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
   2548          	FRESULT res;
   2549          	DWORD clst, sect;
   2550          	UINT wcnt, cc;
   2551          	const BYTE *wbuff = (const BYTE*)buff;
   \   0000000A   0x000C             MOVS     R4,R1
   2552          	BYTE csect;
   2553          
   2554          
   2555          	*bw = 0;	/* Clear write byte counter */
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6038             STR      R0,[R7, #+0]
   2556          
   2557          	res = validate(fp);						/* Check validity */
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0x.... 0x....      BL       validate
   2558          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD001             BEQ.N    ??f_write_0
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0xE078             B.N      ??f_write_1
   2559          	if (fp->flag & FA__ERROR)				/* Aborted file? */
   \                     ??f_write_0:
   \   00000020   0x79A8             LDRB     R0,[R5, #+6]
   \   00000022   0x0600             LSLS     R0,R0,#+24
   \   00000024   0xD501             BPL.N    ??f_write_2
   2560          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xE073             B.N      ??f_write_1
   2561          	if (!(fp->flag & FA_WRITE))				/* Check access mode */
   \                     ??f_write_2:
   \   0000002A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000002C   0x0780             LSLS     R0,R0,#+30
   \   0000002E   0xD401             BMI.N    ??f_write_3
   2562          		LEAVE_FF(fp->fs, FR_DENIED);
   \   00000030   0x2007             MOVS     R0,#+7
   \   00000032   0xE06E             B.N      ??f_write_1
   2563          	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
   \                     ??f_write_3:
   \   00000034   0x68E8             LDR      R0,[R5, #+12]
   \   00000036   0x1830             ADDS     R0,R6,R0
   \   00000038   0x68E9             LDR      R1,[R5, #+12]
   \   0000003A   0x4288             CMP      R0,R1
   \   0000003C   0xD22D             BCS.N    ??f_write_4
   \   0000003E   0x2600             MOVS     R6,#+0
   \   00000040   0xE02B             B.N      ??f_write_4
   2564          
   2565          	for ( ;  btw;							/* Repeat until all data written */
   2566          		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
   2567          		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
   2568          			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   2569          			if (!csect) {					/* On the cluster boundary? */
   2570          				if (fp->fptr == 0) {		/* On the top of the file? */
   2571          					clst = fp->sclust;		/* Follow from the origin */
   2572          					if (clst == 0)			/* When no cluster is allocated, */
   2573          						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
   2574          				} else {					/* Middle or end of the file */
   2575          #if _USE_FASTSEEK
   2576          					if (fp->cltbl)
   2577          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   2578          					else
   2579          #endif
   2580          						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
   2581          				}
   2582          				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
   2583          				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   2584          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2585          				fp->clust = clst;			/* Update current cluster */
   2586          			}
   2587          #if _FS_TINY
   2588          			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
   2589          				ABORT(fp->fs, FR_DISK_ERR);
   2590          #else
   2591          			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
   2592          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2593          					ABORT(fp->fs, FR_DISK_ERR);
   2594          				fp->flag &= ~FA__DIRTY;
   2595          			}
   2596          #endif
   2597          			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   2598          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   2599          			sect += csect;
   2600          			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
   2601          			if (cc) {						/* Write maximum contiguous sectors directly */
   2602          				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   2603          					cc = fp->fs->csize - csect;
   2604          				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
   2605          					ABORT(fp->fs, FR_DISK_ERR);
   2606          #if _FS_TINY
   2607          				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
   2608          					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
   2609          					fp->fs->wflag = 0;
   2610          				}
   2611          #else
   2612          				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
   2613          					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
   2614          					fp->flag &= ~FA__DIRTY;
   2615          				}
   2616          #endif
   2617          				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
   2618          				continue;
   2619          			}
   2620          #if _FS_TINY
   2621          			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
   2622          				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
   2623          				fp->fs->winsect = sect;
   2624          			}
   2625          #else
   2626          			if (fp->dsect != sect) {		/* Fill sector cache with file data */
   2627          				if (fp->fptr < fp->fsize &&
   2628          					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
   2629          						ABORT(fp->fs, FR_DISK_ERR);
   2630          			}
   2631          #endif
   2632          			fp->dsect = sect;
   \                     ??f_write_5:
   \   00000042   0xF8C5 0x9018      STR      R9,[R5, #+24]
   2633          		}
   2634          		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
   \                     ??f_write_6:
   \   00000046   0x68A8             LDR      R0,[R5, #+8]
   \   00000048   0xF44F 0x7100      MOV      R1,#+512
   \   0000004C   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   00000050   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   00000054   0xF5D2 0x7800      RSBS     R8,R2,#+512
   2635          		if (wcnt > btw) wcnt = btw;
   \   00000058   0x4546             CMP      R6,R8
   \   0000005A   0xD200             BCS.N    ??f_write_7
   \   0000005C   0x46B0             MOV      R8,R6
   2636          #if _FS_TINY
   2637          		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
   2638          			ABORT(fp->fs, FR_DISK_ERR);
   2639          		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   2640          		fp->fs->wflag = 1;
   2641          #else
   2642          		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   \                     ??f_write_7:
   \   0000005E   0x4642             MOV      R2,R8
   \   00000060   0x0021             MOVS     R1,R4
   \   00000062   0x68A8             LDR      R0,[R5, #+8]
   \   00000064   0xF44F 0x7300      MOV      R3,#+512
   \   00000068   0xFBB0 0xFCF3      UDIV     R12,R0,R3
   \   0000006C   0xFB0C 0x0C13      MLS      R12,R12,R3,R0
   \   00000070   0xEB1C 0x0005      ADDS     R0,R12,R5
   \   00000074   0x302C             ADDS     R0,R0,#+44
   \   00000076   0x.... 0x....      BL       mem_cpy
   2643          		fp->flag |= FA__DIRTY;
   \   0000007A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000007C   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000080   0x71A8             STRB     R0,[R5, #+6]
   \                     ??f_write_8:
   \   00000082   0xEB18 0x0404      ADDS     R4,R8,R4
   \   00000086   0x68A8             LDR      R0,[R5, #+8]
   \   00000088   0xEB18 0x0000      ADDS     R0,R8,R0
   \   0000008C   0x60A8             STR      R0,[R5, #+8]
   \   0000008E   0x6838             LDR      R0,[R7, #+0]
   \   00000090   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000094   0x6038             STR      R0,[R7, #+0]
   \   00000096   0xEBB6 0x0608      SUBS     R6,R6,R8
   \                     ??f_write_4:
   \   0000009A   0x2E00             CMP      R6,#+0
   \   0000009C   0xD02E             BEQ.N    ??f_write_9
   \   0000009E   0x68A8             LDR      R0,[R5, #+8]
   \   000000A0   0xF44F 0x7100      MOV      R1,#+512
   \   000000A4   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   000000A8   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   000000AC   0x2A00             CMP      R2,#+0
   \   000000AE   0xD1CA             BNE.N    ??f_write_6
   \   000000B0   0x68A8             LDR      R0,[R5, #+8]
   \   000000B2   0x0A40             LSRS     R0,R0,#+9
   \   000000B4   0x6829             LDR      R1,[R5, #+0]
   \   000000B6   0x7889             LDRB     R1,[R1, #+2]
   \   000000B8   0x1E49             SUBS     R1,R1,#+1
   \   000000BA   0xEA11 0x0800      ANDS     R8,R1,R0
   \   000000BE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000C2   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000C6   0xD138             BNE.N    ??f_write_10
   \   000000C8   0x68A8             LDR      R0,[R5, #+8]
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD108             BNE.N    ??f_write_11
   \   000000CE   0x6928             LDR      R0,[R5, #+16]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD111             BNE.N    ??f_write_12
   \   000000D4   0x2100             MOVS     R1,#+0
   \   000000D6   0x6828             LDR      R0,[R5, #+0]
   \   000000D8   0x.... 0x....      BL       create_chain
   \   000000DC   0x6128             STR      R0,[R5, #+16]
   \   000000DE   0xE00B             B.N      ??f_write_12
   \                     ??f_write_11:
   \   000000E0   0x6A68             LDR      R0,[R5, #+36]
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD004             BEQ.N    ??f_write_13
   \   000000E6   0x68A9             LDR      R1,[R5, #+8]
   \   000000E8   0x0028             MOVS     R0,R5
   \   000000EA   0x.... 0x....      BL       clmt_clust
   \   000000EE   0xE003             B.N      ??f_write_12
   \                     ??f_write_13:
   \   000000F0   0x6969             LDR      R1,[R5, #+20]
   \   000000F2   0x6828             LDR      R0,[R5, #+0]
   \   000000F4   0x.... 0x....      BL       create_chain
   \                     ??f_write_12:
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD10C             BNE.N    ??f_write_14
   2644          #endif
   2645          	}
   2646          
   2647          	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
   \                     ??f_write_9:
   \   000000FC   0x68E8             LDR      R0,[R5, #+12]
   \   000000FE   0x68A9             LDR      R1,[R5, #+8]
   \   00000100   0x4288             CMP      R0,R1
   \   00000102   0xD201             BCS.N    ??f_write_15
   \   00000104   0x68A8             LDR      R0,[R5, #+8]
   \   00000106   0x60E8             STR      R0,[R5, #+12]
   2648          	fp->flag |= FA__WRITTEN;						/* Set file change flag */
   \                     ??f_write_15:
   \   00000108   0x79A8             LDRB     R0,[R5, #+6]
   \   0000010A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000010E   0x71A8             STRB     R0,[R5, #+6]
   2649          
   2650          	LEAVE_FF(fp->fs, FR_OK);
   \   00000110   0x2000             MOVS     R0,#+0
   \                     ??f_write_1:
   \   00000112   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \                     ??f_write_14:
   \   00000116   0x2801             CMP      R0,#+1
   \   00000118   0xD105             BNE.N    ??f_write_16
   \   0000011A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000011C   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000120   0x71A8             STRB     R0,[R5, #+6]
   \   00000122   0x2002             MOVS     R0,#+2
   \   00000124   0xE7F5             B.N      ??f_write_1
   \                     ??f_write_16:
   \   00000126   0xF110 0x0F01      CMN      R0,#+1
   \   0000012A   0xD105             BNE.N    ??f_write_17
   \   0000012C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000012E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000132   0x71A8             STRB     R0,[R5, #+6]
   \   00000134   0x2001             MOVS     R0,#+1
   \   00000136   0xE7EC             B.N      ??f_write_1
   \                     ??f_write_17:
   \   00000138   0x6168             STR      R0,[R5, #+20]
   \                     ??f_write_10:
   \   0000013A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000013C   0x0640             LSLS     R0,R0,#+25
   \   0000013E   0xD513             BPL.N    ??f_write_18
   \   00000140   0x2301             MOVS     R3,#+1
   \   00000142   0x69AA             LDR      R2,[R5, #+24]
   \   00000144   0xF115 0x012C      ADDS     R1,R5,#+44
   \   00000148   0x6828             LDR      R0,[R5, #+0]
   \   0000014A   0x7840             LDRB     R0,[R0, #+1]
   \   0000014C   0x.... 0x....      BL       disk_write
   \   00000150   0x2800             CMP      R0,#+0
   \   00000152   0xD005             BEQ.N    ??f_write_19
   \   00000154   0x79A8             LDRB     R0,[R5, #+6]
   \   00000156   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000015A   0x71A8             STRB     R0,[R5, #+6]
   \   0000015C   0x2001             MOVS     R0,#+1
   \   0000015E   0xE7D8             B.N      ??f_write_1
   \                     ??f_write_19:
   \   00000160   0x79A8             LDRB     R0,[R5, #+6]
   \   00000162   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   00000166   0x71A8             STRB     R0,[R5, #+6]
   \                     ??f_write_18:
   \   00000168   0x6969             LDR      R1,[R5, #+20]
   \   0000016A   0x6828             LDR      R0,[R5, #+0]
   \   0000016C   0x.... 0x....      BL       clust2sect
   \   00000170   0x4681             MOV      R9,R0
   \   00000172   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000176   0xD105             BNE.N    ??f_write_20
   \   00000178   0x79A8             LDRB     R0,[R5, #+6]
   \   0000017A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000017E   0x71A8             STRB     R0,[R5, #+6]
   \   00000180   0x2002             MOVS     R0,#+2
   \   00000182   0xE7C6             B.N      ??f_write_1
   \                     ??f_write_20:
   \   00000184   0xFA59 0xF988      UXTAB    R9,R9,R8
   \   00000188   0xEA5F 0x2A56      LSRS     R10,R6,#+9
   \   0000018C   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000190   0xD036             BEQ.N    ??f_write_21
   \   00000192   0x6828             LDR      R0,[R5, #+0]
   \   00000194   0x7880             LDRB     R0,[R0, #+2]
   \   00000196   0xFA5A 0xF188      UXTAB    R1,R10,R8
   \   0000019A   0x4288             CMP      R0,R1
   \   0000019C   0xD205             BCS.N    ??f_write_22
   \   0000019E   0x6828             LDR      R0,[R5, #+0]
   \   000001A0   0x7880             LDRB     R0,[R0, #+2]
   \   000001A2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001A6   0xEBB0 0x0A08      SUBS     R10,R0,R8
   \                     ??f_write_22:
   \   000001AA   0x4653             MOV      R3,R10
   \   000001AC   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001AE   0x464A             MOV      R2,R9
   \   000001B0   0x0021             MOVS     R1,R4
   \   000001B2   0x6828             LDR      R0,[R5, #+0]
   \   000001B4   0x7840             LDRB     R0,[R0, #+1]
   \   000001B6   0x.... 0x....      BL       disk_write
   \   000001BA   0x2800             CMP      R0,#+0
   \   000001BC   0xD005             BEQ.N    ??f_write_23
   \   000001BE   0x79A8             LDRB     R0,[R5, #+6]
   \   000001C0   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000001C4   0x71A8             STRB     R0,[R5, #+6]
   \   000001C6   0x2001             MOVS     R0,#+1
   \   000001C8   0xE7A3             B.N      ??f_write_1
   \                     ??f_write_23:
   \   000001CA   0x69A8             LDR      R0,[R5, #+24]
   \   000001CC   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   000001D0   0x4550             CMP      R0,R10
   \   000001D2   0xD210             BCS.N    ??f_write_24
   \   000001D4   0xF44F 0x7200      MOV      R2,#+512
   \   000001D8   0x69A8             LDR      R0,[R5, #+24]
   \   000001DA   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   000001DE   0xF44F 0x7100      MOV      R1,#+512
   \   000001E2   0xFB01 0x4100      MLA      R1,R1,R0,R4
   \   000001E6   0xF115 0x002C      ADDS     R0,R5,#+44
   \   000001EA   0x.... 0x....      BL       mem_cpy
   \   000001EE   0x79A8             LDRB     R0,[R5, #+6]
   \   000001F0   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   000001F4   0x71A8             STRB     R0,[R5, #+6]
   \                     ??f_write_24:
   \   000001F6   0xF44F 0x7000      MOV      R0,#+512
   \   000001FA   0xFB00 0xF80A      MUL      R8,R0,R10
   \   000001FE   0xE740             B.N      ??f_write_8
   \                     ??f_write_21:
   \   00000200   0x69A8             LDR      R0,[R5, #+24]
   \   00000202   0x4548             CMP      R0,R9
   \   00000204   0xF43F 0xAF1D      BEQ.W    ??f_write_5
   \   00000208   0x68A8             LDR      R0,[R5, #+8]
   \   0000020A   0x68E9             LDR      R1,[R5, #+12]
   \   0000020C   0x4288             CMP      R0,R1
   \   0000020E   0xF4BF 0xAF18      BCS.W    ??f_write_5
   \   00000212   0x2301             MOVS     R3,#+1
   \   00000214   0x464A             MOV      R2,R9
   \   00000216   0xF115 0x012C      ADDS     R1,R5,#+44
   \   0000021A   0x6828             LDR      R0,[R5, #+0]
   \   0000021C   0x7840             LDRB     R0,[R0, #+1]
   \   0000021E   0x.... 0x....      BL       disk_read
   \   00000222   0x2800             CMP      R0,#+0
   \   00000224   0xF43F 0xAF0D      BEQ.W    ??f_write_5
   \   00000228   0x79A8             LDRB     R0,[R5, #+6]
   \   0000022A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000022E   0x71A8             STRB     R0,[R5, #+6]
   \   00000230   0x2001             MOVS     R0,#+1
   \   00000232   0xE76E             B.N      ??f_write_1
   2651          }
   2652          
   2653          
   2654          
   2655          
   2656          /*-----------------------------------------------------------------------*/
   2657          /* Synchronize the File Object                                           */
   2658          /*-----------------------------------------------------------------------*/
   2659          

   \                                 In section .text, align 2, keep-with-next
   2660          FRESULT f_sync (
   2661          	FIL *fp		/* Pointer to the file object */
   2662          )
   2663          {
   \                     f_sync:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2664          	FRESULT res;
   2665          	DWORD tm;
   2666          	BYTE *dir;
   2667          
   2668          
   2669          	res = validate(fp);					/* Check validity of the object */
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       validate
   2670          	if (res == FR_OK) {
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD14A             BNE.N    ??f_sync_0
   2671          		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
   \   00000010   0x79A1             LDRB     R1,[R4, #+6]
   \   00000012   0x0689             LSLS     R1,R1,#+26
   \   00000014   0xD547             BPL.N    ??f_sync_0
   2672          #if !_FS_TINY	/* Write-back dirty buffer */
   2673          			if (fp->flag & FA__DIRTY) {
   \   00000016   0x79A0             LDRB     R0,[R4, #+6]
   \   00000018   0x0640             LSLS     R0,R0,#+25
   \   0000001A   0xD50F             BPL.N    ??f_sync_1
   2674          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   0000001C   0x2301             MOVS     R3,#+1
   \   0000001E   0x69A2             LDR      R2,[R4, #+24]
   \   00000020   0xF114 0x012C      ADDS     R1,R4,#+44
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x7840             LDRB     R0,[R0, #+1]
   \   00000028   0x.... 0x....      BL       disk_write
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD001             BEQ.N    ??f_sync_2
   2675          					LEAVE_FF(fp->fs, FR_DISK_ERR);
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xE039             B.N      ??f_sync_3
   2676          				fp->flag &= ~FA__DIRTY;
   \                     ??f_sync_2:
   \   00000034   0x79A0             LDRB     R0,[R4, #+6]
   \   00000036   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   0000003A   0x71A0             STRB     R0,[R4, #+6]
   2677          			}
   2678          #endif
   2679          			/* Update the directory entry */
   2680          			res = move_window(fp->fs, fp->dir_sect);
   \                     ??f_sync_1:
   \   0000003C   0x69E1             LDR      R1,[R4, #+28]
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x.... 0x....      BL       move_window
   2681          			if (res == FR_OK) {
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD12D             BNE.N    ??f_sync_0
   2682          				dir = fp->dir_ptr;
   \   0000004A   0x6A25             LDR      R5,[R4, #+32]
   2683          				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
   \   0000004C   0x7AE8             LDRB     R0,[R5, #+11]
   \   0000004E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000052   0x72E8             STRB     R0,[R5, #+11]
   2684          				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
   \   00000054   0x68E0             LDR      R0,[R4, #+12]
   \   00000056   0x7728             STRB     R0,[R5, #+28]
   \   00000058   0x68E0             LDR      R0,[R4, #+12]
   \   0000005A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005C   0x0A00             LSRS     R0,R0,#+8
   \   0000005E   0x7768             STRB     R0,[R5, #+29]
   \   00000060   0x68E0             LDR      R0,[R4, #+12]
   \   00000062   0x0C00             LSRS     R0,R0,#+16
   \   00000064   0x77A8             STRB     R0,[R5, #+30]
   \   00000066   0x68E0             LDR      R0,[R4, #+12]
   \   00000068   0x0E00             LSRS     R0,R0,#+24
   \   0000006A   0x77E8             STRB     R0,[R5, #+31]
   2685          				st_clust(dir, fp->sclust);					/* Update start cluster */
   \   0000006C   0x6921             LDR      R1,[R4, #+16]
   \   0000006E   0x0028             MOVS     R0,R5
   \   00000070   0x.... 0x....      BL       st_clust
   2686          				tm = get_fattime();							/* Update updated time */
   \   00000074   0x.... 0x....      BL       get_fattime
   2687          				ST_DWORD(dir+DIR_WrtTime, tm);
   \   00000078   0x75A8             STRB     R0,[R5, #+22]
   \   0000007A   0x0001             MOVS     R1,R0
   \   0000007C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000007E   0x0A09             LSRS     R1,R1,#+8
   \   00000080   0x75E9             STRB     R1,[R5, #+23]
   \   00000082   0x0C01             LSRS     R1,R0,#+16
   \   00000084   0x7629             STRB     R1,[R5, #+24]
   \   00000086   0x0E00             LSRS     R0,R0,#+24
   \   00000088   0x7668             STRB     R0,[R5, #+25]
   2688          				ST_WORD(dir+DIR_LstAccDate, 0);
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x74A8             STRB     R0,[R5, #+18]
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x74E8             STRB     R0,[R5, #+19]
   2689          				fp->flag &= ~FA__WRITTEN;
   \   00000092   0x79A0             LDRB     R0,[R4, #+6]
   \   00000094   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   00000098   0x71A0             STRB     R0,[R4, #+6]
   2690          				fp->fs->wflag = 1;
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x2101             MOVS     R1,#+1
   \   0000009E   0x7101             STRB     R1,[R0, #+4]
   2691          				res = sync_fs(fp->fs);
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x.... 0x....      BL       sync_fs
   2692          			}
   2693          		}
   2694          	}
   2695          
   2696          	LEAVE_FF(fp->fs, res);
   \                     ??f_sync_0:
   \   000000A6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_sync_3:
   \   000000A8   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2697          }
   2698          
   2699          #endif /* !_FS_READONLY */
   2700          
   2701          
   2702          
   2703          
   2704          /*-----------------------------------------------------------------------*/
   2705          /* Close File                                                            */
   2706          /*-----------------------------------------------------------------------*/
   2707          

   \                                 In section .text, align 2, keep-with-next
   2708          FRESULT f_close (
   2709          	FIL *fp		/* Pointer to the file object to be closed */
   2710          )
   2711          {
   \                     f_close:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2712          	FRESULT res;
   2713          
   2714          
   2715          #if _FS_READONLY
   2716          	res = validate(fp);
   2717          	{
   2718          #if _FS_REENTRANT
   2719          		FATFS *fs = fp->fs;
   2720          #endif
   2721          		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
   2722          		LEAVE_FF(fs, res);
   2723          	}
   2724          #else
   2725          	res = f_sync(fp);		/* Flush cached data */
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       f_sync
   2726          #if _FS_LOCK
   2727          	if (res == FR_OK) {		/* Decrement open counter */
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD102             BNE.N    ??f_close_0
   2728          #if _FS_REENTRANT
   2729          		FATFS *fs = fp->fs;;
   2730          		res = validate(fp);
   2731          		if (res == FR_OK) {
   2732          			res = dec_lock(fp->lockid);	
   2733          			unlock_fs(fs, FR_OK);
   2734          		}
   2735          #else
   2736          		res = dec_lock(fp->lockid);
   \   00000010   0x6AA0             LDR      R0,[R4, #+40]
   \   00000012   0x.... 0x....      BL       dec_lock
   2737          #endif
   2738          	}
   2739          #endif
   2740          	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
   \                     ??f_close_0:
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD101             BNE.N    ??f_close_1
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x6021             STR      R1,[R4, #+0]
   2741          	return res;
   \                     ??f_close_1:
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
   2742          #endif
   2743          }
   2744          
   2745          
   2746          
   2747          
   2748          /*-----------------------------------------------------------------------*/
   2749          /* Current Drive/Directory Handlings                                     */
   2750          /*-----------------------------------------------------------------------*/
   2751          
   2752          #if _FS_RPATH >= 1
   2753          

   \                                 In section .text, align 2, keep-with-next
   2754          FRESULT f_chdrive (
   2755          	BYTE drv		/* Drive number */
   2756          )
   2757          {
   2758          	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
   \                     f_chdrive:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2801             CMP      R0,#+1
   \   00000004   0xD301             BCC.N    ??f_chdrive_0
   \   00000006   0x200B             MOVS     R0,#+11
   \   00000008   0xE002             B.N      ??f_chdrive_1
   2759          
   2760          	CurrVol = drv;
   \                     ??f_chdrive_0:
   \   0000000A   0x....             LDR.N    R1,??DataTable13_1
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
   2761          
   2762          	return FR_OK;
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??f_chdrive_1:
   \   00000010   0x4770             BX       LR               ;; return
   2763          }
   2764          
   2765          
   2766          

   \                                 In section .text, align 2, keep-with-next
   2767          FRESULT f_chdir (
   2768          	const TCHAR *path	/* Pointer to the directory path */
   2769          )
   2770          {
   \                     f_chdir:
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   2771          	FRESULT res;
   2772          	DIR dj;
   2773          	DEF_NAMEBUF;
   2774          
   2775          
   2776          	res = chk_mounted(&path, &dj.fs, 0);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xA900             ADD      R1,SP,#+0
   \   00000008   0xA80C             ADD      R0,SP,#+48
   \   0000000A   0x.... 0x....      BL       chk_mounted
   \   0000000E   0x0004             MOVS     R4,R0
   2777          	if (res == FR_OK) {
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD12C             BNE.N    ??f_chdir_0
   2778          		INIT_BUF(dj);
   \   00000016   0x2082             MOVS     R0,#+130
   \   00000018   0x.... 0x....      BL       ff_memalloc
   \   0000001C   0x0005             MOVS     R5,R0
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD101             BNE.N    ??f_chdir_1
   \   00000022   0x2011             MOVS     R0,#+17
   \   00000024   0xE026             B.N      ??f_chdir_2
   \                     ??f_chdir_1:
   \   00000026   0x9507             STR      R5,[SP, #+28]
   \   00000028   0xA809             ADD      R0,SP,#+36
   \   0000002A   0x9006             STR      R0,[SP, #+24]
   2779          		res = follow_path(&dj, path);		/* Follow the path */
   \   0000002C   0x990C             LDR      R1,[SP, #+48]
   \   0000002E   0xA800             ADD      R0,SP,#+0
   \   00000030   0x.... 0x....      BL       follow_path
   \   00000034   0x0004             MOVS     R4,R0
   2780          		FREE_BUF();
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0x.... 0x....      BL       ff_memfree
   2781          		if (res == FR_OK) {					/* Follow completed */
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD112             BNE.N    ??f_chdir_3
   2782          			if (!dj.dir) {
   \   00000042   0x9805             LDR      R0,[SP, #+20]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD103             BNE.N    ??f_chdir_4
   2783          				dj.fs->cdir = dj.sclust;	/* Start directory itself */
   \   00000048   0x9800             LDR      R0,[SP, #+0]
   \   0000004A   0x9902             LDR      R1,[SP, #+8]
   \   0000004C   0x6181             STR      R1,[R0, #+24]
   \   0000004E   0xE00B             B.N      ??f_chdir_3
   2784          			} else {
   2785          				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
   \                     ??f_chdir_4:
   \   00000050   0x9805             LDR      R0,[SP, #+20]
   \   00000052   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000054   0x06C0             LSLS     R0,R0,#+27
   \   00000056   0xD506             BPL.N    ??f_chdir_5
   2786          					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
   \   00000058   0x9905             LDR      R1,[SP, #+20]
   \   0000005A   0x9800             LDR      R0,[SP, #+0]
   \   0000005C   0x.... 0x....      BL       ld_clust
   \   00000060   0x9900             LDR      R1,[SP, #+0]
   \   00000062   0x6188             STR      R0,[R1, #+24]
   \   00000064   0xE000             B.N      ??f_chdir_3
   2787          				else
   2788          					res = FR_NO_PATH;		/* Reached but a file */
   \                     ??f_chdir_5:
   \   00000066   0x2405             MOVS     R4,#+5
   2789          			}
   2790          		}
   2791          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   \                     ??f_chdir_3:
   \   00000068   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006A   0x2C04             CMP      R4,#+4
   \   0000006C   0xD100             BNE.N    ??f_chdir_0
   \   0000006E   0x2405             MOVS     R4,#+5
   2792          	}
   2793          
   2794          	LEAVE_FF(dj.fs, res);
   \                     ??f_chdir_0:
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_chdir_2:
   \   00000074   0xB00D             ADD      SP,SP,#+52
   \   00000076   0xBD30             POP      {R4,R5,PC}       ;; return
   2795          }
   2796          
   2797          
   2798          #if _FS_RPATH >= 2

   \                                 In section .text, align 2, keep-with-next
   2799          FRESULT f_getcwd (
   2800          	TCHAR *buff,	/* Pointer to the directory path */
   2801          	UINT len		/* Size of path */
   2802          )
   2803          {
   \                     f_getcwd:
   \   00000000   0xE92D 0x41F1      PUSH     {R0,R4-R8,LR}
   \   00000004   0xB095             SUB      SP,SP,#+84
   \   00000006   0x000C             MOVS     R4,R1
   2804          	FRESULT res;
   2805          	DIR dj;
   2806          	UINT i, n;
   2807          	DWORD ccl;
   2808          	TCHAR *tp;
   2809          	FILINFO fno;
   2810          	DEF_NAMEBUF;
   2811          
   2812          
   2813          	*buff = 0;
   \   00000008   0x9815             LDR      R0,[SP, #+84]
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
   2814          	res = chk_mounted((const TCHAR**)&buff, &dj.fs, 0);	/* Get current volume */
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0xA815             ADD      R0,SP,#+84
   \   00000014   0x.... 0x....      BL       chk_mounted
   \   00000018   0x0006             MOVS     R6,R0
   2815          	if (res == FR_OK) {
   \   0000001A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xF040 0x8090      BNE.W    ??f_getcwd_0
   2816          		INIT_BUF(dj);
   \   00000022   0x2082             MOVS     R0,#+130
   \   00000024   0x.... 0x....      BL       ff_memalloc
   \   00000028   0x0005             MOVS     R5,R0
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD101             BNE.N    ??f_getcwd_1
   \   0000002E   0x2011             MOVS     R0,#+17
   \   00000030   0xE089             B.N      ??f_getcwd_2
   \                     ??f_getcwd_1:
   \   00000032   0x9507             STR      R5,[SP, #+28]
   \   00000034   0xA809             ADD      R0,SP,#+36
   \   00000036   0x9006             STR      R0,[SP, #+24]
   2817          		i = len;			/* Bottom of buffer (dir stack base) */
   \   00000038   0x0027             MOVS     R7,R4
   2818          		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
   \   0000003A   0x9800             LDR      R0,[SP, #+0]
   \   0000003C   0x6980             LDR      R0,[R0, #+24]
   \   0000003E   0x9002             STR      R0,[SP, #+8]
   \   00000040   0xE00A             B.N      ??f_getcwd_3
   2819          		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
   2820          			res = dir_sdi(&dj, 1);			/* Get parent dir */
   2821          			if (res != FR_OK) break;
   2822          			res = dir_read(&dj, 0);
   2823          			if (res != FR_OK) break;
   2824          			dj.sclust = ld_clust(dj.fs, dj.dir);	/* Goto parent dir */
   2825          			res = dir_sdi(&dj, 0);
   2826          			if (res != FR_OK) break;
   2827          			do {							/* Find the entry links to the child dir */
   2828          				res = dir_read(&dj, 0);
   2829          				if (res != FR_OK) break;
   2830          				if (ccl == ld_clust(dj.fs, dj.dir)) break;	/* Found the entry */
   2831          				res = dir_next(&dj, 0);	
   2832          			} while (res == FR_OK);
   2833          			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
   2834          			if (res != FR_OK) break;
   2835          #if _USE_LFN
   2836          			fno.lfname = buff;
   2837          			fno.lfsize = i;
   2838          #endif
   2839          			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
   2840          			tp = fno.fname;
   2841          			if (_USE_LFN && *buff) tp = buff;
   2842          			for (n = 0; tp[n]; n++) ;
   2843          			if (i < n + 3) {
   2844          				res = FR_NOT_ENOUGH_CORE; break;
   2845          			}
   2846          			while (n) buff[--i] = tp[--n];
   \                     ??f_getcwd_4:
   \   00000042   0x1E7F             SUBS     R7,R7,#+1
   \   00000044   0x1E49             SUBS     R1,R1,#+1
   \   00000046   0x9A15             LDR      R2,[SP, #+84]
   \   00000048   0x5C0B             LDRB     R3,[R1, R0]
   \   0000004A   0x54BB             STRB     R3,[R7, R2]
   \                     ??f_getcwd_5:
   \   0000004C   0x2900             CMP      R1,#+0
   \   0000004E   0xD1F8             BNE.N    ??f_getcwd_4
   2847          			buff[--i] = '/';
   \   00000050   0x1E7F             SUBS     R7,R7,#+1
   \   00000052   0x9815             LDR      R0,[SP, #+84]
   \   00000054   0x212F             MOVS     R1,#+47
   \   00000056   0x5439             STRB     R1,[R7, R0]
   \                     ??f_getcwd_3:
   \   00000058   0xF8DD 0x8008      LDR      R8,[SP, #+8]
   \   0000005C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000060   0xD051             BEQ.N    ??f_getcwd_6
   \   00000062   0x2101             MOVS     R1,#+1
   \   00000064   0xA800             ADD      R0,SP,#+0
   \   00000066   0x.... 0x....      BL       dir_sdi
   \   0000006A   0x0006             MOVS     R6,R0
   \   0000006C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006E   0x2E00             CMP      R6,#+0
   \   00000070   0xD149             BNE.N    ??f_getcwd_6
   \                     ??f_getcwd_7:
   \   00000072   0x2100             MOVS     R1,#+0
   \   00000074   0xA800             ADD      R0,SP,#+0
   \   00000076   0x.... 0x....      BL       dir_read
   \   0000007A   0x0006             MOVS     R6,R0
   \   0000007C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007E   0x2E00             CMP      R6,#+0
   \   00000080   0xD141             BNE.N    ??f_getcwd_6
   \                     ??f_getcwd_8:
   \   00000082   0x9905             LDR      R1,[SP, #+20]
   \   00000084   0x9800             LDR      R0,[SP, #+0]
   \   00000086   0x.... 0x....      BL       ld_clust
   \   0000008A   0x9002             STR      R0,[SP, #+8]
   \   0000008C   0x2100             MOVS     R1,#+0
   \   0000008E   0xA800             ADD      R0,SP,#+0
   \   00000090   0x.... 0x....      BL       dir_sdi
   \   00000094   0x0006             MOVS     R6,R0
   \   00000096   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000098   0x2E00             CMP      R6,#+0
   \   0000009A   0xD134             BNE.N    ??f_getcwd_6
   \                     ??f_getcwd_9:
   \   0000009C   0x2100             MOVS     R1,#+0
   \   0000009E   0xA800             ADD      R0,SP,#+0
   \   000000A0   0x.... 0x....      BL       dir_read
   \   000000A4   0x0006             MOVS     R6,R0
   \   000000A6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A8   0x2E00             CMP      R6,#+0
   \   000000AA   0xD10D             BNE.N    ??f_getcwd_10
   \                     ??f_getcwd_11:
   \   000000AC   0x9905             LDR      R1,[SP, #+20]
   \   000000AE   0x9800             LDR      R0,[SP, #+0]
   \   000000B0   0x.... 0x....      BL       ld_clust
   \   000000B4   0x4580             CMP      R8,R0
   \   000000B6   0xD007             BEQ.N    ??f_getcwd_10
   \                     ??f_getcwd_12:
   \   000000B8   0x2100             MOVS     R1,#+0
   \   000000BA   0xA800             ADD      R0,SP,#+0
   \   000000BC   0x.... 0x....      BL       dir_next
   \   000000C0   0x0006             MOVS     R6,R0
   \   000000C2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000C4   0x2E00             CMP      R6,#+0
   \   000000C6   0xD0E9             BEQ.N    ??f_getcwd_9
   \                     ??f_getcwd_10:
   \   000000C8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000CA   0x2E04             CMP      R6,#+4
   \   000000CC   0xD100             BNE.N    ??f_getcwd_13
   \   000000CE   0x2602             MOVS     R6,#+2
   \                     ??f_getcwd_13:
   \   000000D0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D2   0x2E00             CMP      R6,#+0
   \   000000D4   0xD117             BNE.N    ??f_getcwd_6
   \                     ??f_getcwd_14:
   \   000000D6   0x9815             LDR      R0,[SP, #+84]
   \   000000D8   0x9012             STR      R0,[SP, #+72]
   \   000000DA   0x9713             STR      R7,[SP, #+76]
   \   000000DC   0xA90C             ADD      R1,SP,#+48
   \   000000DE   0xA800             ADD      R0,SP,#+0
   \   000000E0   0x.... 0x....      BL       get_fileinfo
   \   000000E4   0xF10D 0x0039      ADD      R0,SP,#+57
   \   000000E8   0x9915             LDR      R1,[SP, #+84]
   \   000000EA   0x7809             LDRB     R1,[R1, #+0]
   \   000000EC   0x2900             CMP      R1,#+0
   \   000000EE   0xD000             BEQ.N    ??f_getcwd_15
   \   000000F0   0x9815             LDR      R0,[SP, #+84]
   \                     ??f_getcwd_15:
   \   000000F2   0x2100             MOVS     R1,#+0
   \   000000F4   0xE000             B.N      ??f_getcwd_16
   \                     ??f_getcwd_17:
   \   000000F6   0x1C49             ADDS     R1,R1,#+1
   \                     ??f_getcwd_16:
   \   000000F8   0x5C0A             LDRB     R2,[R1, R0]
   \   000000FA   0x2A00             CMP      R2,#+0
   \   000000FC   0xD1FB             BNE.N    ??f_getcwd_17
   \   000000FE   0x1CCA             ADDS     R2,R1,#+3
   \   00000100   0x4297             CMP      R7,R2
   \   00000102   0xD2A3             BCS.N    ??f_getcwd_5
   \   00000104   0x2611             MOVS     R6,#+17
   2848          		}
   2849          		tp = buff;
   \                     ??f_getcwd_6:
   \   00000106   0x9815             LDR      R0,[SP, #+84]
   2850          		if (res == FR_OK) {
   \   00000108   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000010A   0x2E00             CMP      R6,#+0
   \   0000010C   0xD114             BNE.N    ??f_getcwd_18
   2851          			*tp++ = '0' + CurrVol;			/* Put drive number */
   \   0000010E   0x....             LDR.N    R1,??DataTable13_1
   \   00000110   0x7809             LDRB     R1,[R1, #+0]
   \   00000112   0x3130             ADDS     R1,R1,#+48
   \   00000114   0x7001             STRB     R1,[R0, #+0]
   \   00000116   0x1C40             ADDS     R0,R0,#+1
   2852          			*tp++ = ':';
   \   00000118   0x213A             MOVS     R1,#+58
   \   0000011A   0x7001             STRB     R1,[R0, #+0]
   \   0000011C   0x1C40             ADDS     R0,R0,#+1
   2853          			if (i == len) {					/* Root-dir */
   \   0000011E   0x42A7             CMP      R7,R4
   \   00000120   0xD103             BNE.N    ??f_getcwd_19
   2854          				*tp++ = '/';
   \   00000122   0x212F             MOVS     R1,#+47
   \   00000124   0x7001             STRB     R1,[R0, #+0]
   \   00000126   0x1C40             ADDS     R0,R0,#+1
   \   00000128   0xE006             B.N      ??f_getcwd_18
   2855          			} else {						/* Sub-dir */
   2856          				do		/* Add stacked path str */
   2857          					*tp++ = buff[i++];
   \                     ??f_getcwd_19:
   \   0000012A   0x9915             LDR      R1,[SP, #+84]
   \   0000012C   0x5C79             LDRB     R1,[R7, R1]
   \   0000012E   0x7001             STRB     R1,[R0, #+0]
   \   00000130   0x1C7F             ADDS     R7,R7,#+1
   \   00000132   0x1C40             ADDS     R0,R0,#+1
   2858          				while (i < len);
   \   00000134   0x42A7             CMP      R7,R4
   \   00000136   0xD3F8             BCC.N    ??f_getcwd_19
   2859          			}
   2860          		}
   2861          		*tp = 0;
   \                     ??f_getcwd_18:
   \   00000138   0x2100             MOVS     R1,#+0
   \   0000013A   0x7001             STRB     R1,[R0, #+0]
   2862          		FREE_BUF();
   \   0000013C   0x0028             MOVS     R0,R5
   \   0000013E   0x.... 0x....      BL       ff_memfree
   2863          	}
   2864          
   2865          	LEAVE_FF(dj.fs, res);
   \                     ??f_getcwd_0:
   \   00000142   0x0030             MOVS     R0,R6
   \   00000144   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_getcwd_2:
   \   00000146   0xB016             ADD      SP,SP,#+88
   \   00000148   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2866          }
   2867          #endif /* _FS_RPATH >= 2 */
   2868          #endif /* _FS_RPATH >= 1 */
   2869          
   2870          
   2871          
   2872          #if _FS_MINIMIZE <= 2
   2873          /*-----------------------------------------------------------------------*/
   2874          /* Seek File R/W Pointer                                                 */
   2875          /*-----------------------------------------------------------------------*/
   2876          

   \                                 In section .text, align 2, keep-with-next
   2877          FRESULT f_lseek (
   2878          	FIL *fp,		/* Pointer to the file object */
   2879          	DWORD ofs		/* File pointer from top of file */
   2880          )
   2881          {
   \                     f_lseek:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   2882          	FRESULT res;
   2883          
   2884          
   2885          	res = validate(fp);					/* Check validity of the object */
   \   00000008   0x0028             MOVS     R0,R5
   \   0000000A   0x.... 0x....      BL       validate
   \   0000000E   0x0004             MOVS     R4,R0
   2886          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD002             BEQ.N    ??f_lseek_0
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xE16E             B.N      ??f_lseek_1
   2887          	if (fp->flag & FA__ERROR)			/* Check abort flag */
   \                     ??f_lseek_0:
   \   0000001C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000001E   0x0600             LSLS     R0,R0,#+24
   \   00000020   0xD501             BPL.N    ??f_lseek_2
   2888          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE169             B.N      ??f_lseek_1
   2889          
   2890          #if _USE_FASTSEEK
   2891          	if (fp->cltbl) {	/* Fast seek */
   \                     ??f_lseek_2:
   \   00000026   0x6A68             LDR      R0,[R5, #+36]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xF000 0x809E      BEQ.W    ??f_lseek_3
   2892          		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
   2893          
   2894          		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
   \   0000002E   0xF116 0x0F01      CMN      R6,#+1
   \   00000032   0xD142             BNE.N    ??f_lseek_4
   2895          			tbl = fp->cltbl;
   \   00000034   0xF8D5 0xA024      LDR      R10,[R5, #+36]
   2896          			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
   \   00000038   0xF8DA 0x8000      LDR      R8,[R10, #+0]
   \   0000003C   0xF11A 0x0A04      ADDS     R10,R10,#+4
   \   00000040   0xF05F 0x0902      MOVS     R9,#+2
   2897          			cl = fp->sclust;			/* Top of the chain */
   \   00000044   0x6928             LDR      R0,[R5, #+16]
   2898          			if (cl) {
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD02C             BEQ.N    ??f_lseek_5
   2899          				do {
   2900          					/* Get a fragment */
   2901          					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
   \                     ??f_lseek_6:
   \   0000004A   0x0007             MOVS     R7,R0
   \   0000004C   0x2600             MOVS     R6,#+0
   \   0000004E   0xF119 0x0902      ADDS     R9,R9,#+2
   2902          					do {
   2903          						pcl = cl; ncl++;
   \                     ??f_lseek_7:
   \   00000052   0x4683             MOV      R11,R0
   \   00000054   0x1C76             ADDS     R6,R6,#+1
   2904          						cl = get_fat(fp->fs, cl);
   \   00000056   0x0001             MOVS     R1,R0
   \   00000058   0x6828             LDR      R0,[R5, #+0]
   \   0000005A   0x.... 0x....      BL       get_fat
   2905          						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
   \   0000005E   0x2802             CMP      R0,#+2
   \   00000060   0xD205             BCS.N    ??f_lseek_8
   \   00000062   0x79A8             LDRB     R0,[R5, #+6]
   \   00000064   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000068   0x71A8             STRB     R0,[R5, #+6]
   \   0000006A   0x2002             MOVS     R0,#+2
   \   0000006C   0xE145             B.N      ??f_lseek_1
   2906          						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_lseek_8:
   \   0000006E   0xF110 0x0F01      CMN      R0,#+1
   \   00000072   0xD105             BNE.N    ??f_lseek_9
   \   00000074   0x79A8             LDRB     R0,[R5, #+6]
   \   00000076   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000007A   0x71A8             STRB     R0,[R5, #+6]
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xE13C             B.N      ??f_lseek_1
   2907          					} while (cl == pcl + 1);
   \                     ??f_lseek_9:
   \   00000080   0xF11B 0x0101      ADDS     R1,R11,#+1
   \   00000084   0x4288             CMP      R0,R1
   \   00000086   0xD0E4             BEQ.N    ??f_lseek_7
   2908          					if (ulen <= tlen) {		/* Store the length and top of the fragment */
   \   00000088   0x45C8             CMP      R8,R9
   \   0000008A   0xD307             BCC.N    ??f_lseek_10
   2909          						*tbl++ = ncl; *tbl++ = tcl;
   \   0000008C   0xF8CA 0x6000      STR      R6,[R10, #+0]
   \   00000090   0xF11A 0x0A04      ADDS     R10,R10,#+4
   \   00000094   0xF8CA 0x7000      STR      R7,[R10, #+0]
   \   00000098   0xF11A 0x0A04      ADDS     R10,R10,#+4
   2910          					}
   2911          				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
   \                     ??f_lseek_10:
   \   0000009C   0x6829             LDR      R1,[R5, #+0]
   \   0000009E   0x69C9             LDR      R1,[R1, #+28]
   \   000000A0   0x4288             CMP      R0,R1
   \   000000A2   0xD3D2             BCC.N    ??f_lseek_6
   2912          			}
   2913          			*fp->cltbl = ulen;	/* Number of items used */
   \                     ??f_lseek_5:
   \   000000A4   0x6A68             LDR      R0,[R5, #+36]
   \   000000A6   0xF8C0 0x9000      STR      R9,[R0, #+0]
   2914          			if (ulen <= tlen)
   \   000000AA   0x45C8             CMP      R8,R9
   \   000000AC   0xD303             BCC.N    ??f_lseek_11
   2915          				*tbl = 0;		/* Terminate table */
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   000000B4   0xE11F             B.N      ??f_lseek_12
   2916          			else
   2917          				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
   \                     ??f_lseek_11:
   \   000000B6   0x2411             MOVS     R4,#+17
   \   000000B8   0xE11D             B.N      ??f_lseek_12
   2918          
   2919          		} else {						/* Fast seek */
   2920          			if (ofs > fp->fsize)		/* Clip offset at the file size */
   \                     ??f_lseek_4:
   \   000000BA   0x68E8             LDR      R0,[R5, #+12]
   \   000000BC   0x42B0             CMP      R0,R6
   \   000000BE   0xD200             BCS.N    ??f_lseek_13
   2921          				ofs = fp->fsize;
   \   000000C0   0x68EE             LDR      R6,[R5, #+12]
   2922          			fp->fptr = ofs;				/* Set file pointer */
   \                     ??f_lseek_13:
   \   000000C2   0x60AE             STR      R6,[R5, #+8]
   2923          			if (ofs) {
   \   000000C4   0x2E00             CMP      R6,#+0
   \   000000C6   0xF000 0x8116      BEQ.W    ??f_lseek_12
   2924          				fp->clust = clmt_clust(fp, ofs - 1);
   \   000000CA   0x1E71             SUBS     R1,R6,#+1
   \   000000CC   0x0028             MOVS     R0,R5
   \   000000CE   0x.... 0x....      BL       clmt_clust
   \   000000D2   0x6168             STR      R0,[R5, #+20]
   2925          				dsc = clust2sect(fp->fs, fp->clust);
   \   000000D4   0x6969             LDR      R1,[R5, #+20]
   \   000000D6   0x6828             LDR      R0,[R5, #+0]
   \   000000D8   0x.... 0x....      BL       clust2sect
   \   000000DC   0x0007             MOVS     R7,R0
   2926          				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
   \   000000DE   0x2F00             CMP      R7,#+0
   \   000000E0   0xD105             BNE.N    ??f_lseek_14
   \   000000E2   0x79A8             LDRB     R0,[R5, #+6]
   \   000000E4   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000E8   0x71A8             STRB     R0,[R5, #+6]
   \   000000EA   0x2002             MOVS     R0,#+2
   \   000000EC   0xE105             B.N      ??f_lseek_1
   2927          				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
   \                     ??f_lseek_14:
   \   000000EE   0x1E70             SUBS     R0,R6,#+1
   \   000000F0   0x6829             LDR      R1,[R5, #+0]
   \   000000F2   0x7889             LDRB     R1,[R1, #+2]
   \   000000F4   0x1E49             SUBS     R1,R1,#+1
   \   000000F6   0xEA11 0x2050      ANDS     R0,R1,R0, LSR #+9
   \   000000FA   0x19C7             ADDS     R7,R0,R7
   2928          				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
   \   000000FC   0x68A8             LDR      R0,[R5, #+8]
   \   000000FE   0xF44F 0x7100      MOV      R1,#+512
   \   00000102   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   00000106   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   0000010A   0x2A00             CMP      R2,#+0
   \   0000010C   0xF000 0x80F3      BEQ.W    ??f_lseek_12
   \   00000110   0x69A8             LDR      R0,[R5, #+24]
   \   00000112   0x4287             CMP      R7,R0
   \   00000114   0xF000 0x80EF      BEQ.W    ??f_lseek_12
   2929          #if !_FS_TINY
   2930          #if !_FS_READONLY
   2931          					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
   \   00000118   0x79A8             LDRB     R0,[R5, #+6]
   \   0000011A   0x0640             LSLS     R0,R0,#+25
   \   0000011C   0xD513             BPL.N    ??f_lseek_15
   2932          						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   0000011E   0x2301             MOVS     R3,#+1
   \   00000120   0x69AA             LDR      R2,[R5, #+24]
   \   00000122   0xF115 0x012C      ADDS     R1,R5,#+44
   \   00000126   0x6828             LDR      R0,[R5, #+0]
   \   00000128   0x7840             LDRB     R0,[R0, #+1]
   \   0000012A   0x.... 0x....      BL       disk_write
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD005             BEQ.N    ??f_lseek_16
   2933          							ABORT(fp->fs, FR_DISK_ERR);
   \   00000132   0x79A8             LDRB     R0,[R5, #+6]
   \   00000134   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000138   0x71A8             STRB     R0,[R5, #+6]
   \   0000013A   0x2001             MOVS     R0,#+1
   \   0000013C   0xE0DD             B.N      ??f_lseek_1
   2934          						fp->flag &= ~FA__DIRTY;
   \                     ??f_lseek_16:
   \   0000013E   0x79A8             LDRB     R0,[R5, #+6]
   \   00000140   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   00000144   0x71A8             STRB     R0,[R5, #+6]
   2935          					}
   2936          #endif
   2937          					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
   \                     ??f_lseek_15:
   \   00000146   0x2301             MOVS     R3,#+1
   \   00000148   0x003A             MOVS     R2,R7
   \   0000014A   0xF115 0x012C      ADDS     R1,R5,#+44
   \   0000014E   0x6828             LDR      R0,[R5, #+0]
   \   00000150   0x7840             LDRB     R0,[R0, #+1]
   \   00000152   0x.... 0x....      BL       disk_read
   \   00000156   0x2800             CMP      R0,#+0
   \   00000158   0xD005             BEQ.N    ??f_lseek_17
   2938          						ABORT(fp->fs, FR_DISK_ERR);
   \   0000015A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000015C   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000160   0x71A8             STRB     R0,[R5, #+6]
   \   00000162   0x2001             MOVS     R0,#+1
   \   00000164   0xE0C9             B.N      ??f_lseek_1
   2939          #endif
   2940          					fp->dsect = dsc;
   \                     ??f_lseek_17:
   \   00000166   0x61AF             STR      R7,[R5, #+24]
   \   00000168   0xE0C5             B.N      ??f_lseek_12
   2941          				}
   2942          			}
   2943          		}
   2944          	} else
   2945          #endif
   2946          
   2947          	/* Normal Seek */
   2948          	{
   2949          		DWORD clst, bcs, nsect, ifptr;
   2950          
   2951          		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
   2952          #if !_FS_READONLY
   2953          			 && !(fp->flag & FA_WRITE)
   2954          #endif
   2955          			) ofs = fp->fsize;
   \                     ??f_lseek_3:
   \   0000016A   0x68E8             LDR      R0,[R5, #+12]
   \   0000016C   0x42B0             CMP      R0,R6
   \   0000016E   0xD203             BCS.N    ??f_lseek_18
   \   00000170   0x79A8             LDRB     R0,[R5, #+6]
   \   00000172   0x0780             LSLS     R0,R0,#+30
   \   00000174   0xD400             BMI.N    ??f_lseek_18
   \   00000176   0x68EE             LDR      R6,[R5, #+12]
   2956          
   2957          		ifptr = fp->fptr;
   \                     ??f_lseek_18:
   \   00000178   0x68A8             LDR      R0,[R5, #+8]
   2958          		fp->fptr = nsect = 0;
   \   0000017A   0x2700             MOVS     R7,#+0
   \   0000017C   0x60AF             STR      R7,[R5, #+8]
   2959          		if (ofs) {
   \   0000017E   0x2E00             CMP      R6,#+0
   \   00000180   0xD07B             BEQ.N    ??f_lseek_19
   2960          			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
   \   00000182   0x6829             LDR      R1,[R5, #+0]
   \   00000184   0x7889             LDRB     R1,[R1, #+2]
   \   00000186   0xF44F 0x7200      MOV      R2,#+512
   \   0000018A   0xFB02 0xF801      MUL      R8,R2,R1
   2961          			if (ifptr > 0 &&
   2962          				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
   \   0000018E   0x2800             CMP      R0,#+0
   \   00000190   0xD010             BEQ.N    ??f_lseek_20
   \   00000192   0x1E41             SUBS     R1,R0,#+1
   \   00000194   0xFBB1 0xF1F8      UDIV     R1,R1,R8
   \   00000198   0x1E72             SUBS     R2,R6,#+1
   \   0000019A   0xFBB2 0xF2F8      UDIV     R2,R2,R8
   \   0000019E   0x428A             CMP      R2,R1
   \   000001A0   0xD308             BCC.N    ??f_lseek_20
   2963          				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
   \   000001A2   0x1E40             SUBS     R0,R0,#+1
   \   000001A4   0xF1B8 0x0101      SUBS     R1,R8,#+1
   \   000001A8   0x4388             BICS     R0,R0,R1
   \   000001AA   0x60A8             STR      R0,[R5, #+8]
   2964          				ofs -= fp->fptr;
   \   000001AC   0x68A8             LDR      R0,[R5, #+8]
   \   000001AE   0x1A36             SUBS     R6,R6,R0
   2965          				clst = fp->clust;
   \   000001B0   0x6969             LDR      R1,[R5, #+20]
   \   000001B2   0xE01A             B.N      ??f_lseek_21
   2966          			} else {									/* When seek to back cluster, */
   2967          				clst = fp->sclust;						/* start from the first cluster */
   \                     ??f_lseek_20:
   \   000001B4   0x6929             LDR      R1,[R5, #+16]
   2968          #if !_FS_READONLY
   2969          				if (clst == 0) {						/* If no cluster chain, create a new chain */
   \   000001B6   0x2900             CMP      R1,#+0
   \   000001B8   0xD116             BNE.N    ??f_lseek_22
   2970          					clst = create_chain(fp->fs, 0);
   \   000001BA   0x2100             MOVS     R1,#+0
   \   000001BC   0x6828             LDR      R0,[R5, #+0]
   \   000001BE   0x.... 0x....      BL       create_chain
   \   000001C2   0x0001             MOVS     R1,R0
   2971          					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   \   000001C4   0x2901             CMP      R1,#+1
   \   000001C6   0xD105             BNE.N    ??f_lseek_23
   \   000001C8   0x79A8             LDRB     R0,[R5, #+6]
   \   000001CA   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000001CE   0x71A8             STRB     R0,[R5, #+6]
   \   000001D0   0x2002             MOVS     R0,#+2
   \   000001D2   0xE092             B.N      ??f_lseek_1
   2972          					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_lseek_23:
   \   000001D4   0xF111 0x0F01      CMN      R1,#+1
   \   000001D8   0xD105             BNE.N    ??f_lseek_24
   \   000001DA   0x79A8             LDRB     R0,[R5, #+6]
   \   000001DC   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000001E0   0x71A8             STRB     R0,[R5, #+6]
   \   000001E2   0x2001             MOVS     R0,#+1
   \   000001E4   0xE089             B.N      ??f_lseek_1
   2973          					fp->sclust = clst;
   \                     ??f_lseek_24:
   \   000001E6   0x6129             STR      R1,[R5, #+16]
   2974          				}
   2975          #endif
   2976          				fp->clust = clst;
   \                     ??f_lseek_22:
   \   000001E8   0x6169             STR      R1,[R5, #+20]
   2977          			}
   2978          			if (clst != 0) {
   \                     ??f_lseek_21:
   \   000001EA   0x2900             CMP      R1,#+0
   \   000001EC   0xD107             BNE.N    ??f_lseek_25
   \   000001EE   0xE044             B.N      ??f_lseek_19
   2979          				while (ofs > bcs) {						/* Cluster following loop */
   2980          #if !_FS_READONLY
   2981          					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
   2982          						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
   2983          						if (clst == 0) {				/* When disk gets full, clip file size */
   2984          							ofs = bcs; break;
   2985          						}
   2986          					} else
   2987          #endif
   2988          						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
   2989          					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2990          					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
   2991          					fp->clust = clst;
   \                     ??f_lseek_26:
   \   000001F0   0x6169             STR      R1,[R5, #+20]
   2992          					fp->fptr += bcs;
   \   000001F2   0x68A8             LDR      R0,[R5, #+8]
   \   000001F4   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000001F8   0x60A8             STR      R0,[R5, #+8]
   2993          					ofs -= bcs;
   \   000001FA   0xEBB6 0x0608      SUBS     R6,R6,R8
   \                     ??f_lseek_25:
   \   000001FE   0x45B0             CMP      R8,R6
   \   00000200   0xD209             BCS.N    ??f_lseek_27
   \   00000202   0x79A8             LDRB     R0,[R5, #+6]
   \   00000204   0x0780             LSLS     R0,R0,#+30
   \   00000206   0xD51D             BPL.N    ??f_lseek_28
   \   00000208   0x6828             LDR      R0,[R5, #+0]
   \   0000020A   0x.... 0x....      BL       create_chain
   \   0000020E   0x0001             MOVS     R1,R0
   \   00000210   0x2900             CMP      R1,#+0
   \   00000212   0xD11B             BNE.N    ??f_lseek_29
   \   00000214   0x4646             MOV      R6,R8
   2994          				}
   2995          				fp->fptr += ofs;
   \                     ??f_lseek_27:
   \   00000216   0x68A8             LDR      R0,[R5, #+8]
   \   00000218   0x1830             ADDS     R0,R6,R0
   \   0000021A   0x60A8             STR      R0,[R5, #+8]
   2996          				if (ofs % SS(fp->fs)) {
   \   0000021C   0xF44F 0x7000      MOV      R0,#+512
   \   00000220   0xFBB6 0xF2F0      UDIV     R2,R6,R0
   \   00000224   0xFB02 0x6210      MLS      R2,R2,R0,R6
   \   00000228   0x2A00             CMP      R2,#+0
   \   0000022A   0xD026             BEQ.N    ??f_lseek_19
   2997          					nsect = clust2sect(fp->fs, clst);	/* Current sector */
   \   0000022C   0x6828             LDR      R0,[R5, #+0]
   \   0000022E   0x.... 0x....      BL       clust2sect
   \   00000232   0x0007             MOVS     R7,R0
   2998          					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
   \   00000234   0x2F00             CMP      R7,#+0
   \   00000236   0xD11E             BNE.N    ??f_lseek_30
   \   00000238   0x79A8             LDRB     R0,[R5, #+6]
   \   0000023A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000023E   0x71A8             STRB     R0,[R5, #+6]
   \   00000240   0x2002             MOVS     R0,#+2
   \   00000242   0xE05A             B.N      ??f_lseek_1
   \                     ??f_lseek_28:
   \   00000244   0x6828             LDR      R0,[R5, #+0]
   \   00000246   0x.... 0x....      BL       get_fat
   \   0000024A   0x0001             MOVS     R1,R0
   \                     ??f_lseek_29:
   \   0000024C   0xF111 0x0F01      CMN      R1,#+1
   \   00000250   0xD105             BNE.N    ??f_lseek_31
   \   00000252   0x79A8             LDRB     R0,[R5, #+6]
   \   00000254   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000258   0x71A8             STRB     R0,[R5, #+6]
   \   0000025A   0x2001             MOVS     R0,#+1
   \   0000025C   0xE04D             B.N      ??f_lseek_1
   \                     ??f_lseek_31:
   \   0000025E   0x2902             CMP      R1,#+2
   \   00000260   0xD303             BCC.N    ??f_lseek_32
   \   00000262   0x6828             LDR      R0,[R5, #+0]
   \   00000264   0x69C0             LDR      R0,[R0, #+28]
   \   00000266   0x4281             CMP      R1,R0
   \   00000268   0xD3C2             BCC.N    ??f_lseek_26
   \                     ??f_lseek_32:
   \   0000026A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000026C   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000270   0x71A8             STRB     R0,[R5, #+6]
   \   00000272   0x2002             MOVS     R0,#+2
   \   00000274   0xE041             B.N      ??f_lseek_1
   2999          					nsect += ofs / SS(fp->fs);
   \                     ??f_lseek_30:
   \   00000276   0xEB17 0x2756      ADDS     R7,R7,R6, LSR #+9
   3000          				}
   3001          			}
   3002          		}
   3003          		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
   \                     ??f_lseek_19:
   \   0000027A   0x68A8             LDR      R0,[R5, #+8]
   \   0000027C   0xF44F 0x7100      MOV      R1,#+512
   \   00000280   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   00000284   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   00000288   0x2A00             CMP      R2,#+0
   \   0000028A   0xD02A             BEQ.N    ??f_lseek_33
   \   0000028C   0x69A8             LDR      R0,[R5, #+24]
   \   0000028E   0x4287             CMP      R7,R0
   \   00000290   0xD027             BEQ.N    ??f_lseek_33
   3004          #if !_FS_TINY
   3005          #if !_FS_READONLY
   3006          			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
   \   00000292   0x79A8             LDRB     R0,[R5, #+6]
   \   00000294   0x0640             LSLS     R0,R0,#+25
   \   00000296   0xD513             BPL.N    ??f_lseek_34
   3007          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   00000298   0x2301             MOVS     R3,#+1
   \   0000029A   0x69AA             LDR      R2,[R5, #+24]
   \   0000029C   0xF115 0x012C      ADDS     R1,R5,#+44
   \   000002A0   0x6828             LDR      R0,[R5, #+0]
   \   000002A2   0x7840             LDRB     R0,[R0, #+1]
   \   000002A4   0x.... 0x....      BL       disk_write
   \   000002A8   0x2800             CMP      R0,#+0
   \   000002AA   0xD005             BEQ.N    ??f_lseek_35
   3008          					ABORT(fp->fs, FR_DISK_ERR);
   \   000002AC   0x79A8             LDRB     R0,[R5, #+6]
   \   000002AE   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000002B2   0x71A8             STRB     R0,[R5, #+6]
   \   000002B4   0x2001             MOVS     R0,#+1
   \   000002B6   0xE020             B.N      ??f_lseek_1
   3009          				fp->flag &= ~FA__DIRTY;
   \                     ??f_lseek_35:
   \   000002B8   0x79A8             LDRB     R0,[R5, #+6]
   \   000002BA   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   000002BE   0x71A8             STRB     R0,[R5, #+6]
   3010          			}
   3011          #endif
   3012          			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
   \                     ??f_lseek_34:
   \   000002C0   0x2301             MOVS     R3,#+1
   \   000002C2   0x003A             MOVS     R2,R7
   \   000002C4   0xF115 0x012C      ADDS     R1,R5,#+44
   \   000002C8   0x6828             LDR      R0,[R5, #+0]
   \   000002CA   0x7840             LDRB     R0,[R0, #+1]
   \   000002CC   0x.... 0x....      BL       disk_read
   \   000002D0   0x2800             CMP      R0,#+0
   \   000002D2   0xD005             BEQ.N    ??f_lseek_36
   3013          				ABORT(fp->fs, FR_DISK_ERR);
   \   000002D4   0x79A8             LDRB     R0,[R5, #+6]
   \   000002D6   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000002DA   0x71A8             STRB     R0,[R5, #+6]
   \   000002DC   0x2001             MOVS     R0,#+1
   \   000002DE   0xE00C             B.N      ??f_lseek_1
   3014          #endif
   3015          			fp->dsect = nsect;
   \                     ??f_lseek_36:
   \   000002E0   0x61AF             STR      R7,[R5, #+24]
   3016          		}
   3017          #if !_FS_READONLY
   3018          		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
   \                     ??f_lseek_33:
   \   000002E2   0x68E8             LDR      R0,[R5, #+12]
   \   000002E4   0x68A9             LDR      R1,[R5, #+8]
   \   000002E6   0x4288             CMP      R0,R1
   \   000002E8   0xD205             BCS.N    ??f_lseek_12
   3019          			fp->fsize = fp->fptr;
   \   000002EA   0x68A8             LDR      R0,[R5, #+8]
   \   000002EC   0x60E8             STR      R0,[R5, #+12]
   3020          			fp->flag |= FA__WRITTEN;
   \   000002EE   0x79A8             LDRB     R0,[R5, #+6]
   \   000002F0   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000002F4   0x71A8             STRB     R0,[R5, #+6]
   3021          		}
   3022          #endif
   3023          	}
   3024          
   3025          	LEAVE_FF(fp->fs, res);
   \                     ??f_lseek_12:
   \   000002F6   0x0020             MOVS     R0,R4
   \   000002F8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_lseek_1:
   \   000002FA   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   3026          }
   3027          
   3028          
   3029          
   3030          #if _FS_MINIMIZE <= 1
   3031          /*-----------------------------------------------------------------------*/
   3032          /* Create a Directory Object                                             */
   3033          /*-----------------------------------------------------------------------*/
   3034          

   \                                 In section .text, align 2, keep-with-next
   3035          FRESULT f_opendir (
   3036          	DIR *dj,			/* Pointer to directory object to create */
   3037          	const TCHAR *path	/* Pointer to the directory path */
   3038          )
   3039          {
   \                     f_opendir:
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
   3040          	FRESULT res;
   3041          	FATFS *fs;
   3042          	DEF_NAMEBUF;
   3043          
   3044          
   3045          	if (!dj) return FR_INVALID_OBJECT;
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??f_opendir_0
   \   0000000A   0x2009             MOVS     R0,#+9
   \   0000000C   0xE045             B.N      ??f_opendir_1
   3046          
   3047          	res = chk_mounted(&path, &dj->fs, 0);
   \                     ??f_opendir_0:
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x0021             MOVS     R1,R4
   \   00000012   0xA804             ADD      R0,SP,#+16
   \   00000014   0x.... 0x....      BL       chk_mounted
   \   00000018   0x0006             MOVS     R6,R0
   3048          	fs = dj->fs;
   \   0000001A   0x6825             LDR      R5,[R4, #+0]
   3049          	if (res == FR_OK) {
   \   0000001C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD137             BNE.N    ??f_opendir_2
   3050          		INIT_BUF(*dj);
   \   00000022   0x2082             MOVS     R0,#+130
   \   00000024   0x.... 0x....      BL       ff_memalloc
   \   00000028   0x0007             MOVS     R7,R0
   \   0000002A   0x2F00             CMP      R7,#+0
   \   0000002C   0xD101             BNE.N    ??f_opendir_3
   \   0000002E   0x2011             MOVS     R0,#+17
   \   00000030   0xE033             B.N      ??f_opendir_1
   \                     ??f_opendir_3:
   \   00000032   0x61E7             STR      R7,[R4, #+28]
   \   00000034   0xA800             ADD      R0,SP,#+0
   \   00000036   0x61A0             STR      R0,[R4, #+24]
   3051          		res = follow_path(dj, path);			/* Follow the path to the directory */
   \   00000038   0x9904             LDR      R1,[SP, #+16]
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       follow_path
   \   00000040   0x0006             MOVS     R6,R0
   3052          		FREE_BUF();
   \   00000042   0x0038             MOVS     R0,R7
   \   00000044   0x.... 0x....      BL       ff_memfree
   3053          		if (res == FR_OK) {						/* Follow completed */
   \   00000048   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004A   0x2E00             CMP      R6,#+0
   \   0000004C   0xD117             BNE.N    ??f_opendir_4
   3054          			if (dj->dir) {						/* It is not the root dir */
   \   0000004E   0x6960             LDR      R0,[R4, #+20]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD00A             BEQ.N    ??f_opendir_5
   3055          				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
   \   00000054   0x6960             LDR      R0,[R4, #+20]
   \   00000056   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000058   0x06C0             LSLS     R0,R0,#+27
   \   0000005A   0xD505             BPL.N    ??f_opendir_6
   3056          					dj->sclust = ld_clust(fs, dj->dir);
   \   0000005C   0x6961             LDR      R1,[R4, #+20]
   \   0000005E   0x0028             MOVS     R0,R5
   \   00000060   0x.... 0x....      BL       ld_clust
   \   00000064   0x60A0             STR      R0,[R4, #+8]
   \   00000066   0xE000             B.N      ??f_opendir_5
   3057          				} else {						/* The object is not a directory */
   3058          					res = FR_NO_PATH;
   \                     ??f_opendir_6:
   \   00000068   0x2605             MOVS     R6,#+5
   3059          				}
   3060          			}
   3061          			if (res == FR_OK) {
   \                     ??f_opendir_5:
   \   0000006A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006C   0x2E00             CMP      R6,#+0
   \   0000006E   0xD106             BNE.N    ??f_opendir_4
   3062          				dj->id = fs->id;
   \   00000070   0x88E8             LDRH     R0,[R5, #+6]
   \   00000072   0x80A0             STRH     R0,[R4, #+4]
   3063          				res = dir_sdi(dj, 0);			/* Rewind dir */
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x.... 0x....      BL       dir_sdi
   \   0000007C   0x0006             MOVS     R6,R0
   3064          			}
   3065          		}
   3066          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   \                     ??f_opendir_4:
   \   0000007E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000080   0x2E04             CMP      R6,#+4
   \   00000082   0xD100             BNE.N    ??f_opendir_7
   \   00000084   0x2605             MOVS     R6,#+5
   3067          		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
   \                     ??f_opendir_7:
   \   00000086   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000088   0x2E00             CMP      R6,#+0
   \   0000008A   0xD004             BEQ.N    ??f_opendir_8
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x6020             STR      R0,[R4, #+0]
   \   00000090   0xE001             B.N      ??f_opendir_8
   3068          	} else {
   3069          		dj->fs = 0;
   \                     ??f_opendir_2:
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x6020             STR      R0,[R4, #+0]
   3070          	}
   3071          
   3072          	LEAVE_FF(fs, res);
   \                     ??f_opendir_8:
   \   00000096   0x0030             MOVS     R0,R6
   \   00000098   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_opendir_1:
   \   0000009A   0xB005             ADD      SP,SP,#+20
   \   0000009C   0xBDF0             POP      {R4-R7,PC}       ;; return
   3073          }
   3074          
   3075          
   3076          
   3077          
   3078          /*-----------------------------------------------------------------------*/
   3079          /* Read Directory Entry in Sequence                                      */
   3080          /*-----------------------------------------------------------------------*/
   3081          

   \                                 In section .text, align 2, keep-with-next
   3082          FRESULT f_readdir (
   3083          	DIR *dj,			/* Pointer to the open directory object */
   3084          	FILINFO *fno		/* Pointer to file information to return */
   3085          )
   3086          {
   \                     f_readdir:
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3087          	FRESULT res;
   3088          	DEF_NAMEBUF;
   3089          
   3090          
   3091          	res = validate(dj);						/* Check validity of the object */
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       validate
   \   0000000C   0x0006             MOVS     R6,R0
   3092          	if (res == FR_OK) {
   \   0000000E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD132             BNE.N    ??f_readdir_0
   3093          		if (!fno) {
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD105             BNE.N    ??f_readdir_1
   3094          			res = dir_sdi(dj, 0);			/* Rewind the directory object */
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       dir_sdi
   \   00000020   0x0006             MOVS     R6,R0
   \   00000022   0xE02A             B.N      ??f_readdir_0
   3095          		} else {
   3096          			INIT_BUF(*dj);
   \                     ??f_readdir_1:
   \   00000024   0x2082             MOVS     R0,#+130
   \   00000026   0x.... 0x....      BL       ff_memalloc
   \   0000002A   0x0007             MOVS     R7,R0
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD101             BNE.N    ??f_readdir_2
   \   00000030   0x2011             MOVS     R0,#+17
   \   00000032   0xE024             B.N      ??f_readdir_3
   \                     ??f_readdir_2:
   \   00000034   0x61E7             STR      R7,[R4, #+28]
   \   00000036   0xA800             ADD      R0,SP,#+0
   \   00000038   0x61A0             STR      R0,[R4, #+24]
   3097          			res = dir_read(dj, 0);			/* Read an item */
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       dir_read
   \   00000042   0x0006             MOVS     R6,R0
   3098          			if (res == FR_NO_FILE) {		/* Reached end of dir */
   \   00000044   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000046   0x2E04             CMP      R6,#+4
   \   00000048   0xD102             BNE.N    ??f_readdir_4
   3099          				dj->sect = 0;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x6120             STR      R0,[R4, #+16]
   3100          				res = FR_OK;
   \   0000004E   0x2600             MOVS     R6,#+0
   3101          			}
   3102          			if (res == FR_OK) {				/* A valid entry is found */
   \                     ??f_readdir_4:
   \   00000050   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000052   0x2E00             CMP      R6,#+0
   \   00000054   0xD10E             BNE.N    ??f_readdir_5
   3103          				get_fileinfo(dj, fno);		/* Get the object information */
   \   00000056   0x0029             MOVS     R1,R5
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       get_fileinfo
   3104          				res = dir_next(dj, 0);		/* Increment index for next */
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x.... 0x....      BL       dir_next
   \   00000066   0x0006             MOVS     R6,R0
   3105          				if (res == FR_NO_FILE) {
   \   00000068   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006A   0x2E04             CMP      R6,#+4
   \   0000006C   0xD102             BNE.N    ??f_readdir_5
   3106          					dj->sect = 0;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x6120             STR      R0,[R4, #+16]
   3107          					res = FR_OK;
   \   00000072   0x2600             MOVS     R6,#+0
   3108          				}
   3109          			}
   3110          			FREE_BUF();
   \                     ??f_readdir_5:
   \   00000074   0x0038             MOVS     R0,R7
   \   00000076   0x.... 0x....      BL       ff_memfree
   3111          		}
   3112          	}
   3113          
   3114          	LEAVE_FF(dj->fs, res);
   \                     ??f_readdir_0:
   \   0000007A   0x0030             MOVS     R0,R6
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_readdir_3:
   \   0000007E   0xBDFE             POP      {R1-R7,PC}       ;; return
   3115          }
   3116          
   3117          
   3118          
   3119          #if _FS_MINIMIZE == 0
   3120          /*-----------------------------------------------------------------------*/
   3121          /* Get File Status                                                       */
   3122          /*-----------------------------------------------------------------------*/
   3123          

   \                                 In section .text, align 2, keep-with-next
   3124          FRESULT f_stat (
   3125          	const TCHAR *path,	/* Pointer to the file path */
   3126          	FILINFO *fno		/* Pointer to file information to return */
   3127          )
   3128          {
   \                     f_stat:
   \   00000000   0xB571             PUSH     {R0,R4-R6,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
   \   00000004   0x000C             MOVS     R4,R1
   3129          	FRESULT res;
   3130          	DIR dj;
   3131          	DEF_NAMEBUF;
   3132          
   3133          
   3134          	res = chk_mounted(&path, &dj.fs, 0);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0xA903             ADD      R1,SP,#+12
   \   0000000A   0xA80D             ADD      R0,SP,#+52
   \   0000000C   0x.... 0x....      BL       chk_mounted
   \   00000010   0x0005             MOVS     R5,R0
   3135          	if (res == FR_OK) {
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD11E             BNE.N    ??f_stat_0
   3136          		INIT_BUF(dj);
   \   00000018   0x2082             MOVS     R0,#+130
   \   0000001A   0x.... 0x....      BL       ff_memalloc
   \   0000001E   0x0006             MOVS     R6,R0
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD101             BNE.N    ??f_stat_1
   \   00000024   0x2011             MOVS     R0,#+17
   \   00000026   0xE018             B.N      ??f_stat_2
   \                     ??f_stat_1:
   \   00000028   0x960A             STR      R6,[SP, #+40]
   \   0000002A   0xA800             ADD      R0,SP,#+0
   \   0000002C   0x9009             STR      R0,[SP, #+36]
   3137          		res = follow_path(&dj, path);	/* Follow the file path */
   \   0000002E   0x990D             LDR      R1,[SP, #+52]
   \   00000030   0xA803             ADD      R0,SP,#+12
   \   00000032   0x.... 0x....      BL       follow_path
   \   00000036   0x0005             MOVS     R5,R0
   3138          		if (res == FR_OK) {				/* Follow completed */
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD108             BNE.N    ??f_stat_3
   3139          			if (dj.dir)		/* Found an object */
   \   0000003E   0x9808             LDR      R0,[SP, #+32]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD004             BEQ.N    ??f_stat_4
   3140          				get_fileinfo(&dj, fno);
   \   00000044   0x0021             MOVS     R1,R4
   \   00000046   0xA803             ADD      R0,SP,#+12
   \   00000048   0x.... 0x....      BL       get_fileinfo
   \   0000004C   0xE000             B.N      ??f_stat_3
   3141          			else			/* It is root dir */
   3142          				res = FR_INVALID_NAME;
   \                     ??f_stat_4:
   \   0000004E   0x2506             MOVS     R5,#+6
   3143          		}
   3144          		FREE_BUF();
   \                     ??f_stat_3:
   \   00000050   0x0030             MOVS     R0,R6
   \   00000052   0x.... 0x....      BL       ff_memfree
   3145          	}
   3146          
   3147          	LEAVE_FF(dj.fs, res);
   \                     ??f_stat_0:
   \   00000056   0x0028             MOVS     R0,R5
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_stat_2:
   \   0000005A   0xB00E             ADD      SP,SP,#+56
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
   3148          }
   3149          
   3150          
   3151          
   3152          #if !_FS_READONLY
   3153          /*-----------------------------------------------------------------------*/
   3154          /* Get Number of Free Clusters                                           */
   3155          /*-----------------------------------------------------------------------*/
   3156          

   \                                 In section .text, align 2, keep-with-next
   3157          FRESULT f_getfree (
   3158          	const TCHAR *path,	/* Path name of the logical drive number */
   3159          	DWORD *nclst,		/* Pointer to a variable to return number of free clusters */
   3160          	FATFS **fatfs		/* Pointer to return pointer to corresponding file system object */
   3161          )
   3162          {
   \                     f_getfree:
   \   00000000   0xE92D 0x47F1      PUSH     {R0,R4-R10,LR}
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0014             MOVS     R4,R2
   3163          	FRESULT res;
   3164          	FATFS *fs;
   3165          	DWORD n, clst, sect, stat;
   3166          	UINT i;
   3167          	BYTE fat, *p;
   3168          
   3169          
   3170          	/* Get drive number */
   3171          	res = chk_mounted(&path, fatfs, 0);
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x0021             MOVS     R1,R4
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x.... 0x....      BL       chk_mounted
   \   00000014   0x4680             MOV      R8,R0
   3172          	fs = *fatfs;
   \   00000016   0x6826             LDR      R6,[R4, #+0]
   3173          	if (res == FR_OK) {
   \   00000018   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000001C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000020   0xD168             BNE.N    ??f_getfree_0
   3174          		/* If free_clust is valid, return it without full cluster scan */
   3175          		if (fs->free_clust <= fs->n_fatent - 2) {
   \   00000022   0x69F0             LDR      R0,[R6, #+28]
   \   00000024   0x1E80             SUBS     R0,R0,#+2
   \   00000026   0x6931             LDR      R1,[R6, #+16]
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD302             BCC.N    ??f_getfree_1
   3176          			*nclst = fs->free_clust;
   \   0000002C   0x6930             LDR      R0,[R6, #+16]
   \   0000002E   0x6028             STR      R0,[R5, #+0]
   \   00000030   0xE060             B.N      ??f_getfree_0
   3177          		} else {
   3178          			/* Get number of free clusters */
   3179          			fat = fs->fs_type;
   \                     ??f_getfree_1:
   \   00000032   0x7837             LDRB     R7,[R6, #+0]
   3180          			n = 0;
   \   00000034   0xF05F 0x0900      MOVS     R9,#+0
   3181          			if (fat == FS_FAT12) {
   \   00000038   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003A   0x2F01             CMP      R7,#+1
   \   0000003C   0xD118             BNE.N    ??f_getfree_2
   3182          				clst = 2;
   \   0000003E   0x2402             MOVS     R4,#+2
   3183          				do {
   3184          					stat = get_fat(fs, clst);
   \                     ??f_getfree_3:
   \   00000040   0x0021             MOVS     R1,R4
   \   00000042   0x0030             MOVS     R0,R6
   \   00000044   0x.... 0x....      BL       get_fat
   3185          					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
   \   00000048   0xF110 0x0F01      CMN      R0,#+1
   \   0000004C   0xD102             BNE.N    ??f_getfree_4
   \   0000004E   0xF05F 0x0801      MOVS     R8,#+1
   \   00000052   0xE046             B.N      ??f_getfree_5
   3186          					if (stat == 1) { res = FR_INT_ERR; break; }
   \                     ??f_getfree_4:
   \   00000054   0x2801             CMP      R0,#+1
   \   00000056   0xD102             BNE.N    ??f_getfree_6
   \   00000058   0xF05F 0x0802      MOVS     R8,#+2
   \   0000005C   0xE041             B.N      ??f_getfree_5
   3187          					if (stat == 0) n++;
   \                     ??f_getfree_6:
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD101             BNE.N    ??f_getfree_7
   \   00000062   0xF119 0x0901      ADDS     R9,R9,#+1
   3188          				} while (++clst < fs->n_fatent);
   \                     ??f_getfree_7:
   \   00000066   0x1C64             ADDS     R4,R4,#+1
   \   00000068   0x69F0             LDR      R0,[R6, #+28]
   \   0000006A   0x4284             CMP      R4,R0
   \   0000006C   0xD3E8             BCC.N    ??f_getfree_3
   \   0000006E   0xE038             B.N      ??f_getfree_5
   3189          			} else {
   3190          				clst = fs->n_fatent;
   \                     ??f_getfree_2:
   \   00000070   0x69F4             LDR      R4,[R6, #+28]
   3191          				sect = fs->fatbase;
   \   00000072   0xF8D6 0xA028      LDR      R10,[R6, #+40]
   3192          				i = 0; p = 0;
   \   00000076   0x2100             MOVS     R1,#+0
   \   00000078   0x2000             MOVS     R0,#+0
   3193          				do {
   3194          					if (!i) {
   \                     ??f_getfree_8:
   \   0000007A   0x2900             CMP      R1,#+0
   \   0000007C   0xD10F             BNE.N    ??f_getfree_9
   3195          						res = move_window(fs, sect++);
   \   0000007E   0x4651             MOV      R1,R10
   \   00000080   0x0030             MOVS     R0,R6
   \   00000082   0x.... 0x....      BL       move_window
   \   00000086   0x4680             MOV      R8,R0
   \   00000088   0xF11A 0x0A01      ADDS     R10,R10,#+1
   3196          						if (res != FR_OK) break;
   \   0000008C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000090   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000094   0xD125             BNE.N    ??f_getfree_5
   3197          						p = fs->win;
   \                     ??f_getfree_10:
   \   00000096   0xF116 0x0038      ADDS     R0,R6,#+56
   3198          						i = SS(fs);
   \   0000009A   0xF44F 0x7100      MOV      R1,#+512
   3199          					}
   3200          					if (fat == FS_FAT16) {
   \                     ??f_getfree_9:
   \   0000009E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000A0   0x2F02             CMP      R7,#+2
   \   000000A2   0xD10B             BNE.N    ??f_getfree_11
   3201          						if (LD_WORD(p) == 0) n++;
   \   000000A4   0x7842             LDRB     R2,[R0, #+1]
   \   000000A6   0x7803             LDRB     R3,[R0, #+0]
   \   000000A8   0xEA53 0x2202      ORRS     R2,R3,R2, LSL #+8
   \   000000AC   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000AE   0x2A00             CMP      R2,#+0
   \   000000B0   0xD101             BNE.N    ??f_getfree_12
   \   000000B2   0xF119 0x0901      ADDS     R9,R9,#+1
   3202          						p += 2; i -= 2;
   \                     ??f_getfree_12:
   \   000000B6   0x1C80             ADDS     R0,R0,#+2
   \   000000B8   0x1E89             SUBS     R1,R1,#+2
   \   000000BA   0xE00F             B.N      ??f_getfree_13
   3203          					} else {
   3204          						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
   \                     ??f_getfree_11:
   \   000000BC   0x78C2             LDRB     R2,[R0, #+3]
   \   000000BE   0x7883             LDRB     R3,[R0, #+2]
   \   000000C0   0x041B             LSLS     R3,R3,#+16
   \   000000C2   0xEA53 0x6202      ORRS     R2,R3,R2, LSL #+24
   \   000000C6   0x7843             LDRB     R3,[R0, #+1]
   \   000000C8   0xEA52 0x2203      ORRS     R2,R2,R3, LSL #+8
   \   000000CC   0x7803             LDRB     R3,[R0, #+0]
   \   000000CE   0x431A             ORRS     R2,R3,R2
   \   000000D0   0x0112             LSLS     R2,R2,#+4
   \   000000D2   0xD101             BNE.N    ??f_getfree_14
   \   000000D4   0xF119 0x0901      ADDS     R9,R9,#+1
   3205          						p += 4; i -= 4;
   \                     ??f_getfree_14:
   \   000000D8   0x1D00             ADDS     R0,R0,#+4
   \   000000DA   0x1F09             SUBS     R1,R1,#+4
   3206          					}
   3207          				} while (--clst);
   \                     ??f_getfree_13:
   \   000000DC   0x1E64             SUBS     R4,R4,#+1
   \   000000DE   0x2C00             CMP      R4,#+0
   \   000000E0   0xD1CB             BNE.N    ??f_getfree_8
   3208          			}
   3209          			fs->free_clust = n;
   \                     ??f_getfree_5:
   \   000000E2   0xF8C6 0x9010      STR      R9,[R6, #+16]
   3210          			if (fat == FS_FAT32) fs->fsi_flag = 1;
   \   000000E6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000E8   0x2F03             CMP      R7,#+3
   \   000000EA   0xD101             BNE.N    ??f_getfree_15
   \   000000EC   0x2001             MOVS     R0,#+1
   \   000000EE   0x7170             STRB     R0,[R6, #+5]
   3211          			*nclst = n;
   \                     ??f_getfree_15:
   \   000000F0   0xF8C5 0x9000      STR      R9,[R5, #+0]
   3212          		}
   3213          	}
   3214          	LEAVE_FF(fs, res);
   \                     ??f_getfree_0:
   \   000000F4   0x4640             MOV      R0,R8
   \   000000F6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F8   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   3215          }
   3216          
   3217          
   3218          
   3219          
   3220          /*-----------------------------------------------------------------------*/
   3221          /* Truncate File                                                         */
   3222          /*-----------------------------------------------------------------------*/
   3223          

   \                                 In section .text, align 2, keep-with-next
   3224          FRESULT f_truncate (
   3225          	FIL *fp		/* Pointer to the file object */
   3226          )
   3227          {
   \                     f_truncate:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3228          	FRESULT res;
   3229          	DWORD ncl;
   3230          
   3231          
   3232          	res = validate(fp);						/* Check validity of the object */
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       validate
   3233          	if (res == FR_OK) {
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD108             BNE.N    ??f_truncate_0
   3234          		if (fp->flag & FA__ERROR) {			/* Check abort flag */
   \   00000010   0x79A1             LDRB     R1,[R4, #+6]
   \   00000012   0x0609             LSLS     R1,R1,#+24
   \   00000014   0xD501             BPL.N    ??f_truncate_1
   3235          			res = FR_INT_ERR;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xE003             B.N      ??f_truncate_0
   3236          		} else {
   3237          			if (!(fp->flag & FA_WRITE))		/* Check access mode */
   \                     ??f_truncate_1:
   \   0000001A   0x79A1             LDRB     R1,[R4, #+6]
   \   0000001C   0x0789             LSLS     R1,R1,#+30
   \   0000001E   0xD400             BMI.N    ??f_truncate_0
   3238          				res = FR_DENIED;
   \   00000020   0x2007             MOVS     R0,#+7
   3239          		}
   3240          	}
   3241          	if (res == FR_OK) {
   \                     ??f_truncate_0:
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD13B             BNE.N    ??f_truncate_2
   3242          		if (fp->fsize > fp->fptr) {
   \   00000028   0x68A1             LDR      R1,[R4, #+8]
   \   0000002A   0x68E2             LDR      R2,[R4, #+12]
   \   0000002C   0x4291             CMP      R1,R2
   \   0000002E   0xD230             BCS.N    ??f_truncate_3
   3243          			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
   \   00000030   0x68A0             LDR      R0,[R4, #+8]
   \   00000032   0x60E0             STR      R0,[R4, #+12]
   3244          			fp->flag |= FA__WRITTEN;
   \   00000034   0x79A0             LDRB     R0,[R4, #+6]
   \   00000036   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000003A   0x71A0             STRB     R0,[R4, #+6]
   3245          			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
   \   0000003C   0x68A0             LDR      R0,[R4, #+8]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD106             BNE.N    ??f_truncate_4
   3246          				res = remove_chain(fp->fs, fp->sclust);
   \   00000042   0x6921             LDR      R1,[R4, #+16]
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x.... 0x....      BL       remove_chain
   3247          				fp->sclust = 0;
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x6121             STR      R1,[R4, #+16]
   \   0000004E   0xE020             B.N      ??f_truncate_3
   3248          			} else {				/* When truncate a part of the file, remove remaining clusters */
   3249          				ncl = get_fat(fp->fs, fp->clust);
   \                     ??f_truncate_4:
   \   00000050   0x6961             LDR      R1,[R4, #+20]
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x.... 0x....      BL       get_fat
   \   00000058   0x0005             MOVS     R5,R0
   3250          				res = FR_OK;
   \   0000005A   0x2000             MOVS     R0,#+0
   3251          				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \   0000005C   0xF115 0x0F01      CMN      R5,#+1
   \   00000060   0xD100             BNE.N    ??f_truncate_5
   \   00000062   0x2001             MOVS     R0,#+1
   3252          				if (ncl == 1) res = FR_INT_ERR;
   \                     ??f_truncate_5:
   \   00000064   0x2D01             CMP      R5,#+1
   \   00000066   0xD100             BNE.N    ??f_truncate_6
   \   00000068   0x2002             MOVS     R0,#+2
   3253          				if (res == FR_OK && ncl < fp->fs->n_fatent) {
   \                     ??f_truncate_6:
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD110             BNE.N    ??f_truncate_3
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x69C9             LDR      R1,[R1, #+28]
   \   00000074   0x428D             CMP      R5,R1
   \   00000076   0xD20C             BCS.N    ??f_truncate_3
   3254          					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
   \   00000078   0xF07F 0x4270      MVNS     R2,#-268435456
   \   0000007C   0x6961             LDR      R1,[R4, #+20]
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x.... 0x....      BL       put_fat
   3255          					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
   \   00000084   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD103             BNE.N    ??f_truncate_3
   \   0000008A   0x0029             MOVS     R1,R5
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x.... 0x....      BL       remove_chain
   3256          				}
   3257          			}
   3258          		}
   3259          		if (res != FR_OK) fp->flag |= FA__ERROR;
   \                     ??f_truncate_3:
   \   00000092   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD003             BEQ.N    ??f_truncate_2
   \   00000098   0x79A1             LDRB     R1,[R4, #+6]
   \   0000009A   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   0000009E   0x71A1             STRB     R1,[R4, #+6]
   3260          	}
   3261          
   3262          	LEAVE_FF(fp->fs, res);
   \                     ??f_truncate_2:
   \   000000A0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A2   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3263          }
   3264          
   3265          
   3266          
   3267          
   3268          /*-----------------------------------------------------------------------*/
   3269          /* Delete a File or Directory                                            */
   3270          /*-----------------------------------------------------------------------*/
   3271          

   \                                 In section .text, align 2, keep-with-next
   3272          FRESULT f_unlink (
   3273          	const TCHAR *path		/* Pointer to the file or directory path */
   3274          )
   3275          {
   \                     f_unlink:
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB096             SUB      SP,SP,#+88
   3276          	FRESULT res;
   3277          	DIR dj, sdj;
   3278          	BYTE *dir;
   3279          	DWORD dclst;
   3280          	DEF_NAMEBUF;
   3281          
   3282          
   3283          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xA900             ADD      R1,SP,#+0
   \   00000008   0xA816             ADD      R0,SP,#+88
   \   0000000A   0x.... 0x....      BL       chk_mounted
   \   0000000E   0x0005             MOVS     R5,R0
   3284          	if (res == FR_OK) {
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD174             BNE.N    ??f_unlink_0
   3285          		INIT_BUF(dj);
   \   00000016   0x2082             MOVS     R0,#+130
   \   00000018   0x.... 0x....      BL       ff_memalloc
   \   0000001C   0x0004             MOVS     R4,R0
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD101             BNE.N    ??f_unlink_1
   \   00000022   0x2011             MOVS     R0,#+17
   \   00000024   0xE06E             B.N      ??f_unlink_2
   \                     ??f_unlink_1:
   \   00000026   0x9407             STR      R4,[SP, #+28]
   \   00000028   0xA809             ADD      R0,SP,#+36
   \   0000002A   0x9006             STR      R0,[SP, #+24]
   3286          		res = follow_path(&dj, path);		/* Follow the file path */
   \   0000002C   0x9916             LDR      R1,[SP, #+88]
   \   0000002E   0xA800             ADD      R0,SP,#+0
   \   00000030   0x.... 0x....      BL       follow_path
   \   00000034   0x0005             MOVS     R5,R0
   3287          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD104             BNE.N    ??f_unlink_3
   \   0000003C   0x9806             LDR      R0,[SP, #+24]
   \   0000003E   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000040   0x0680             LSLS     R0,R0,#+26
   \   00000042   0xD500             BPL.N    ??f_unlink_3
   3288          			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
   \   00000044   0x2506             MOVS     R5,#+6
   3289          #if _FS_LOCK
   3290          		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
   \                     ??f_unlink_3:
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2D00             CMP      R5,#+0
   \   0000004A   0xD104             BNE.N    ??f_unlink_4
   \   0000004C   0x2102             MOVS     R1,#+2
   \   0000004E   0xA800             ADD      R0,SP,#+0
   \   00000050   0x.... 0x....      BL       chk_lock
   \   00000054   0x0005             MOVS     R5,R0
   3291          #endif
   3292          		if (res == FR_OK) {					/* The object is accessible */
   \                     ??f_unlink_4:
   \   00000056   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000058   0x2D00             CMP      R5,#+0
   \   0000005A   0xD14E             BNE.N    ??f_unlink_5
   3293          			dir = dj.dir;
   \   0000005C   0x9F05             LDR      R7,[SP, #+20]
   3294          			if (!dir) {
   \   0000005E   0x2F00             CMP      R7,#+0
   \   00000060   0xD101             BNE.N    ??f_unlink_6
   3295          				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
   \   00000062   0x2506             MOVS     R5,#+6
   \   00000064   0xE003             B.N      ??f_unlink_7
   3296          			} else {
   3297          				if (dir[DIR_Attr] & AM_RDO)
   \                     ??f_unlink_6:
   \   00000066   0x7AF8             LDRB     R0,[R7, #+11]
   \   00000068   0x07C0             LSLS     R0,R0,#+31
   \   0000006A   0xD500             BPL.N    ??f_unlink_7
   3298          					res = FR_DENIED;		/* Cannot remove R/O object */
   \   0000006C   0x2507             MOVS     R5,#+7
   3299          			}
   3300          			dclst = ld_clust(dj.fs, dir);
   \                     ??f_unlink_7:
   \   0000006E   0x0039             MOVS     R1,R7
   \   00000070   0x9800             LDR      R0,[SP, #+0]
   \   00000072   0x.... 0x....      BL       ld_clust
   \   00000076   0x0006             MOVS     R6,R0
   3301          			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
   \   00000078   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007A   0x2D00             CMP      R5,#+0
   \   0000007C   0xD125             BNE.N    ??f_unlink_8
   \   0000007E   0x7AF8             LDRB     R0,[R7, #+11]
   \   00000080   0x06C0             LSLS     R0,R0,#+27
   \   00000082   0xD522             BPL.N    ??f_unlink_8
   3302          				if (dclst < 2) {
   \   00000084   0x2E02             CMP      R6,#+2
   \   00000086   0xD201             BCS.N    ??f_unlink_9
   3303          					res = FR_INT_ERR;
   \   00000088   0x2502             MOVS     R5,#+2
   \   0000008A   0xE01E             B.N      ??f_unlink_8
   3304          				} else {
   3305          					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
   \                     ??f_unlink_9:
   \   0000008C   0x2224             MOVS     R2,#+36
   \   0000008E   0xA900             ADD      R1,SP,#+0
   \   00000090   0xA80C             ADD      R0,SP,#+48
   \   00000092   0x.... 0x....      BL       mem_cpy
   3306          					sdj.sclust = dclst;
   \   00000096   0x960E             STR      R6,[SP, #+56]
   3307          					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
   \   00000098   0x2102             MOVS     R1,#+2
   \   0000009A   0xA80C             ADD      R0,SP,#+48
   \   0000009C   0x.... 0x....      BL       dir_sdi
   \   000000A0   0x0005             MOVS     R5,R0
   3308          					if (res == FR_OK) {
   \   000000A2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A4   0x2D00             CMP      R5,#+0
   \   000000A6   0xD110             BNE.N    ??f_unlink_8
   3309          						res = dir_read(&sdj, 0);	/* Read an item */
   \   000000A8   0x2100             MOVS     R1,#+0
   \   000000AA   0xA80C             ADD      R0,SP,#+48
   \   000000AC   0x.... 0x....      BL       dir_read
   \   000000B0   0x0005             MOVS     R5,R0
   3310          						if (res == FR_OK		/* Not empty dir */
   3311          #if _FS_RPATH
   3312          						|| dclst == dj.fs->cdir	/* Current dir */
   3313          #endif
   3314          						) res = FR_DENIED;
   \   000000B2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B4   0x2D00             CMP      R5,#+0
   \   000000B6   0xD003             BEQ.N    ??f_unlink_10
   \   000000B8   0x9800             LDR      R0,[SP, #+0]
   \   000000BA   0x6980             LDR      R0,[R0, #+24]
   \   000000BC   0x4286             CMP      R6,R0
   \   000000BE   0xD100             BNE.N    ??f_unlink_11
   \                     ??f_unlink_10:
   \   000000C0   0x2507             MOVS     R5,#+7
   3315          						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
   \                     ??f_unlink_11:
   \   000000C2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C4   0x2D04             CMP      R5,#+4
   \   000000C6   0xD100             BNE.N    ??f_unlink_8
   \   000000C8   0x2500             MOVS     R5,#+0
   3316          					}
   3317          				}
   3318          			}
   3319          			if (res == FR_OK) {
   \                     ??f_unlink_8:
   \   000000CA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000CC   0x2D00             CMP      R5,#+0
   \   000000CE   0xD114             BNE.N    ??f_unlink_5
   3320          				res = dir_remove(&dj);		/* Remove the directory entry */
   \   000000D0   0xA800             ADD      R0,SP,#+0
   \   000000D2   0x.... 0x....      BL       dir_remove
   \   000000D6   0x0005             MOVS     R5,R0
   3321          				if (res == FR_OK) {
   \   000000D8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000DA   0x2D00             CMP      R5,#+0
   \   000000DC   0xD10D             BNE.N    ??f_unlink_5
   3322          					if (dclst)				/* Remove the cluster chain if exist */
   \   000000DE   0x2E00             CMP      R6,#+0
   \   000000E0   0xD004             BEQ.N    ??f_unlink_12
   3323          						res = remove_chain(dj.fs, dclst);
   \   000000E2   0x0031             MOVS     R1,R6
   \   000000E4   0x9800             LDR      R0,[SP, #+0]
   \   000000E6   0x.... 0x....      BL       remove_chain
   \   000000EA   0x0005             MOVS     R5,R0
   3324          					if (res == FR_OK) res = sync_fs(dj.fs);
   \                     ??f_unlink_12:
   \   000000EC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000EE   0x2D00             CMP      R5,#+0
   \   000000F0   0xD103             BNE.N    ??f_unlink_5
   \   000000F2   0x9800             LDR      R0,[SP, #+0]
   \   000000F4   0x.... 0x....      BL       sync_fs
   \   000000F8   0x0005             MOVS     R5,R0
   3325          				}
   3326          			}
   3327          		}
   3328          		FREE_BUF();
   \                     ??f_unlink_5:
   \   000000FA   0x0020             MOVS     R0,R4
   \   000000FC   0x.... 0x....      BL       ff_memfree
   3329          	}
   3330          
   3331          	LEAVE_FF(dj.fs, res);
   \                     ??f_unlink_0:
   \   00000100   0x0028             MOVS     R0,R5
   \   00000102   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_unlink_2:
   \   00000104   0xB017             ADD      SP,SP,#+92
   \   00000106   0xBDF0             POP      {R4-R7,PC}       ;; return
   3332          }
   3333          
   3334          
   3335          
   3336          
   3337          /*-----------------------------------------------------------------------*/
   3338          /* Create a Directory                                                    */
   3339          /*-----------------------------------------------------------------------*/
   3340          

   \                                 In section .text, align 2, keep-with-next
   3341          FRESULT f_mkdir (
   3342          	const TCHAR *path		/* Pointer to the directory path */
   3343          )
   3344          {
   \                     f_mkdir:
   \   00000000   0xE92D 0x47F1      PUSH     {R0,R4-R10,LR}
   \   00000004   0xB08D             SUB      SP,SP,#+52
   3345          	FRESULT res;
   3346          	DIR dj;
   3347          	BYTE *dir, n;
   3348          	DWORD dsc, dcl, pcl, tm = get_fattime();
   \   00000006   0x.... 0x....      BL       get_fattime
   \   0000000A   0x0004             MOVS     R4,R0
   3349          	DEF_NAMEBUF;
   3350          
   3351          
   3352          	res = chk_mounted(&path, &dj.fs, 1);
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xA900             ADD      R1,SP,#+0
   \   00000010   0xA80D             ADD      R0,SP,#+52
   \   00000012   0x.... 0x....      BL       chk_mounted
   \   00000016   0x0006             MOVS     R6,R0
   3353          	if (res == FR_OK) {
   \   00000018   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xF040 0x80CA      BNE.W    ??f_mkdir_0
   3354          		INIT_BUF(dj);
   \   00000020   0x2082             MOVS     R0,#+130
   \   00000022   0x.... 0x....      BL       ff_memalloc
   \   00000026   0x0005             MOVS     R5,R0
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD101             BNE.N    ??f_mkdir_1
   \   0000002C   0x2011             MOVS     R0,#+17
   \   0000002E   0xE0C3             B.N      ??f_mkdir_2
   \                     ??f_mkdir_1:
   \   00000030   0x9507             STR      R5,[SP, #+28]
   \   00000032   0xA809             ADD      R0,SP,#+36
   \   00000034   0x9006             STR      R0,[SP, #+24]
   3355          		res = follow_path(&dj, path);			/* Follow the file path */
   \   00000036   0x990D             LDR      R1,[SP, #+52]
   \   00000038   0xA800             ADD      R0,SP,#+0
   \   0000003A   0x.... 0x....      BL       follow_path
   \   0000003E   0x0006             MOVS     R6,R0
   3356          		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD100             BNE.N    ??f_mkdir_3
   \   00000046   0x2608             MOVS     R6,#+8
   3357          		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
   \                     ??f_mkdir_3:
   \   00000048   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004A   0x2E04             CMP      R6,#+4
   \   0000004C   0xD104             BNE.N    ??f_mkdir_4
   \   0000004E   0x9806             LDR      R0,[SP, #+24]
   \   00000050   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000052   0x0680             LSLS     R0,R0,#+26
   \   00000054   0xD500             BPL.N    ??f_mkdir_4
   3358          			res = FR_INVALID_NAME;
   \   00000056   0x2606             MOVS     R6,#+6
   3359          		if (res == FR_NO_FILE) {				/* Can create a new directory */
   \                     ??f_mkdir_4:
   \   00000058   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005A   0x2E04             CMP      R6,#+4
   \   0000005C   0xF040 0x80A7      BNE.W    ??f_mkdir_5
   3360          			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x9800             LDR      R0,[SP, #+0]
   \   00000064   0x.... 0x....      BL       create_chain
   \   00000068   0x0007             MOVS     R7,R0
   3361          			res = FR_OK;
   \   0000006A   0x2600             MOVS     R6,#+0
   3362          			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
   \   0000006C   0x2F00             CMP      R7,#+0
   \   0000006E   0xD100             BNE.N    ??f_mkdir_6
   \   00000070   0x2607             MOVS     R6,#+7
   3363          			if (dcl == 1) res = FR_INT_ERR;
   \                     ??f_mkdir_6:
   \   00000072   0x2F01             CMP      R7,#+1
   \   00000074   0xD100             BNE.N    ??f_mkdir_7
   \   00000076   0x2602             MOVS     R6,#+2
   3364          			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \                     ??f_mkdir_7:
   \   00000078   0xF117 0x0F01      CMN      R7,#+1
   \   0000007C   0xD100             BNE.N    ??f_mkdir_8
   \   0000007E   0x2601             MOVS     R6,#+1
   3365          			if (res == FR_OK)					/* Flush FAT */
   \                     ??f_mkdir_8:
   \   00000080   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000082   0x2E00             CMP      R6,#+0
   \   00000084   0xD103             BNE.N    ??f_mkdir_9
   3366          				res = sync_window(dj.fs);
   \   00000086   0x9800             LDR      R0,[SP, #+0]
   \   00000088   0x.... 0x....      BL       sync_window
   \   0000008C   0x0006             MOVS     R6,R0
   3367          			if (res == FR_OK) {					/* Initialize the new directory table */
   \                     ??f_mkdir_9:
   \   0000008E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000090   0x2E00             CMP      R6,#+0
   \   00000092   0xD160             BNE.N    ??f_mkdir_10
   3368          				dsc = clust2sect(dj.fs, dcl);
   \   00000094   0x0039             MOVS     R1,R7
   \   00000096   0x9800             LDR      R0,[SP, #+0]
   \   00000098   0x.... 0x....      BL       clust2sect
   \   0000009C   0x4680             MOV      R8,R0
   3369          				dir = dj.fs->win;
   \   0000009E   0x9800             LDR      R0,[SP, #+0]
   \   000000A0   0xF110 0x0938      ADDS     R9,R0,#+56
   3370          				mem_set(dir, 0, SS(dj.fs));
   \   000000A4   0xF44F 0x7200      MOV      R2,#+512
   \   000000A8   0x2100             MOVS     R1,#+0
   \   000000AA   0x4648             MOV      R0,R9
   \   000000AC   0x.... 0x....      BL       mem_set
   3371          				mem_set(dir+DIR_Name, ' ', 11);	/* Create "." entry */
   \   000000B0   0x220B             MOVS     R2,#+11
   \   000000B2   0x2120             MOVS     R1,#+32
   \   000000B4   0x4648             MOV      R0,R9
   \   000000B6   0x.... 0x....      BL       mem_set
   3372          				dir[DIR_Name] = '.';
   \   000000BA   0x202E             MOVS     R0,#+46
   \   000000BC   0xF889 0x0000      STRB     R0,[R9, #+0]
   3373          				dir[DIR_Attr] = AM_DIR;
   \   000000C0   0x2010             MOVS     R0,#+16
   \   000000C2   0xF889 0x000B      STRB     R0,[R9, #+11]
   3374          				ST_DWORD(dir+DIR_WrtTime, tm);
   \   000000C6   0xF889 0x4016      STRB     R4,[R9, #+22]
   \   000000CA   0x0020             MOVS     R0,R4
   \   000000CC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000CE   0x0A00             LSRS     R0,R0,#+8
   \   000000D0   0xF889 0x0017      STRB     R0,[R9, #+23]
   \   000000D4   0x0C20             LSRS     R0,R4,#+16
   \   000000D6   0xF889 0x0018      STRB     R0,[R9, #+24]
   \   000000DA   0x0E20             LSRS     R0,R4,#+24
   \   000000DC   0xF889 0x0019      STRB     R0,[R9, #+25]
   3375          				st_clust(dir, dcl);
   \   000000E0   0x0039             MOVS     R1,R7
   \   000000E2   0x4648             MOV      R0,R9
   \   000000E4   0x.... 0x....      BL       st_clust
   3376          				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
   \   000000E8   0x2220             MOVS     R2,#+32
   \   000000EA   0x4649             MOV      R1,R9
   \   000000EC   0xF119 0x0020      ADDS     R0,R9,#+32
   \   000000F0   0x.... 0x....      BL       mem_cpy
   3377          				dir[33] = '.'; pcl = dj.sclust;
   \   000000F4   0x202E             MOVS     R0,#+46
   \   000000F6   0xF889 0x0021      STRB     R0,[R9, #+33]
   \   000000FA   0x9902             LDR      R1,[SP, #+8]
   3378          				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
   \   000000FC   0x9800             LDR      R0,[SP, #+0]
   \   000000FE   0x7800             LDRB     R0,[R0, #+0]
   \   00000100   0x2803             CMP      R0,#+3
   \   00000102   0xD104             BNE.N    ??f_mkdir_11
   \   00000104   0x9800             LDR      R0,[SP, #+0]
   \   00000106   0x6AC0             LDR      R0,[R0, #+44]
   \   00000108   0x4281             CMP      R1,R0
   \   0000010A   0xD100             BNE.N    ??f_mkdir_11
   3379          					pcl = 0;
   \   0000010C   0x2100             MOVS     R1,#+0
   3380          				st_clust(dir+SZ_DIR, pcl);
   \                     ??f_mkdir_11:
   \   0000010E   0xF119 0x0020      ADDS     R0,R9,#+32
   \   00000112   0x.... 0x....      BL       st_clust
   3381          				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
   \   00000116   0x9800             LDR      R0,[SP, #+0]
   \   00000118   0xF890 0xA002      LDRB     R10,[R0, #+2]
   \   0000011C   0xE007             B.N      ??f_mkdir_12
   3382          					dj.fs->winsect = dsc++;
   3383          					dj.fs->wflag = 1;
   3384          					res = sync_window(dj.fs);
   3385          					if (res != FR_OK) break;
   3386          					mem_set(dir, 0, SS(dj.fs));
   \                     ??f_mkdir_13:
   \   0000011E   0xF44F 0x7200      MOV      R2,#+512
   \   00000122   0x2100             MOVS     R1,#+0
   \   00000124   0x4648             MOV      R0,R9
   \   00000126   0x.... 0x....      BL       mem_set
   \   0000012A   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \                     ??f_mkdir_12:
   \   0000012E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000132   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000136   0xD00E             BEQ.N    ??f_mkdir_10
   \   00000138   0x9800             LDR      R0,[SP, #+0]
   \   0000013A   0xF8C0 0x8034      STR      R8,[R0, #+52]
   \   0000013E   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000142   0x9800             LDR      R0,[SP, #+0]
   \   00000144   0x2101             MOVS     R1,#+1
   \   00000146   0x7101             STRB     R1,[R0, #+4]
   \   00000148   0x9800             LDR      R0,[SP, #+0]
   \   0000014A   0x.... 0x....      BL       sync_window
   \   0000014E   0x0006             MOVS     R6,R0
   \   00000150   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000152   0x2E00             CMP      R6,#+0
   \   00000154   0xD0E3             BEQ.N    ??f_mkdir_13
   3387          				}
   3388          			}
   3389          			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
   \                     ??f_mkdir_10:
   \   00000156   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000158   0x2E00             CMP      R6,#+0
   \   0000015A   0xD103             BNE.N    ??f_mkdir_14
   \   0000015C   0xA800             ADD      R0,SP,#+0
   \   0000015E   0x.... 0x....      BL       dir_register
   \   00000162   0x0006             MOVS     R6,R0
   3390          			if (res != FR_OK) {
   \                     ??f_mkdir_14:
   \   00000164   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000166   0x2E00             CMP      R6,#+0
   \   00000168   0xD004             BEQ.N    ??f_mkdir_15
   3391          				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
   \   0000016A   0x0039             MOVS     R1,R7
   \   0000016C   0x9800             LDR      R0,[SP, #+0]
   \   0000016E   0x.... 0x....      BL       remove_chain
   \   00000172   0xE01C             B.N      ??f_mkdir_5
   3392          			} else {
   3393          				dir = dj.dir;
   \                     ??f_mkdir_15:
   \   00000174   0xF8DD 0x9014      LDR      R9,[SP, #+20]
   3394          				dir[DIR_Attr] = AM_DIR;				/* Attribute */
   \   00000178   0x2010             MOVS     R0,#+16
   \   0000017A   0xF889 0x000B      STRB     R0,[R9, #+11]
   3395          				ST_DWORD(dir+DIR_WrtTime, tm);		/* Created time */
   \   0000017E   0xF889 0x4016      STRB     R4,[R9, #+22]
   \   00000182   0x0020             MOVS     R0,R4
   \   00000184   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000186   0x0A00             LSRS     R0,R0,#+8
   \   00000188   0xF889 0x0017      STRB     R0,[R9, #+23]
   \   0000018C   0x0C20             LSRS     R0,R4,#+16
   \   0000018E   0xF889 0x0018      STRB     R0,[R9, #+24]
   \   00000192   0x0E20             LSRS     R0,R4,#+24
   \   00000194   0xF889 0x0019      STRB     R0,[R9, #+25]
   3396          				st_clust(dir, dcl);					/* Table start cluster */
   \   00000198   0x0039             MOVS     R1,R7
   \   0000019A   0x4648             MOV      R0,R9
   \   0000019C   0x.... 0x....      BL       st_clust
   3397          				dj.fs->wflag = 1;
   \   000001A0   0x9800             LDR      R0,[SP, #+0]
   \   000001A2   0x2101             MOVS     R1,#+1
   \   000001A4   0x7101             STRB     R1,[R0, #+4]
   3398          				res = sync_fs(dj.fs);
   \   000001A6   0x9800             LDR      R0,[SP, #+0]
   \   000001A8   0x.... 0x....      BL       sync_fs
   \   000001AC   0x0006             MOVS     R6,R0
   3399          			}
   3400          		}
   3401          		FREE_BUF();
   \                     ??f_mkdir_5:
   \   000001AE   0x0028             MOVS     R0,R5
   \   000001B0   0x.... 0x....      BL       ff_memfree
   3402          	}
   3403          
   3404          	LEAVE_FF(dj.fs, res);
   \                     ??f_mkdir_0:
   \   000001B4   0x0030             MOVS     R0,R6
   \   000001B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_mkdir_2:
   \   000001B8   0xB00E             ADD      SP,SP,#+56
   \   000001BA   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   3405          }
   3406          
   3407          
   3408          
   3409          
   3410          /*-----------------------------------------------------------------------*/
   3411          /* Change Attribute                                                      */
   3412          /*-----------------------------------------------------------------------*/
   3413          

   \                                 In section .text, align 2, keep-with-next
   3414          FRESULT f_chmod (
   3415          	const TCHAR *path,	/* Pointer to the file path */
   3416          	BYTE value,			/* Attribute bits */
   3417          	BYTE mask			/* Attribute mask to change */
   3418          )
   3419          {
   \                     f_chmod:
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0015             MOVS     R5,R2
   3420          	FRESULT res;
   3421          	DIR dj;
   3422          	BYTE *dir;
   3423          	DEF_NAMEBUF;
   3424          
   3425          
   3426          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xA900             ADD      R1,SP,#+0
   \   0000000C   0xA80C             ADD      R0,SP,#+48
   \   0000000E   0x.... 0x....      BL       chk_mounted
   \   00000012   0x0006             MOVS     R6,R0
   3427          	if (res == FR_OK) {
   \   00000014   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD131             BNE.N    ??f_chmod_0
   3428          		INIT_BUF(dj);
   \   0000001A   0x2082             MOVS     R0,#+130
   \   0000001C   0x.... 0x....      BL       ff_memalloc
   \   00000020   0x0007             MOVS     R7,R0
   \   00000022   0x2F00             CMP      R7,#+0
   \   00000024   0xD101             BNE.N    ??f_chmod_1
   \   00000026   0x2011             MOVS     R0,#+17
   \   00000028   0xE02B             B.N      ??f_chmod_2
   \                     ??f_chmod_1:
   \   0000002A   0x9707             STR      R7,[SP, #+28]
   \   0000002C   0xA809             ADD      R0,SP,#+36
   \   0000002E   0x9006             STR      R0,[SP, #+24]
   3429          		res = follow_path(&dj, path);		/* Follow the file path */
   \   00000030   0x990C             LDR      R1,[SP, #+48]
   \   00000032   0xA800             ADD      R0,SP,#+0
   \   00000034   0x.... 0x....      BL       follow_path
   \   00000038   0x0006             MOVS     R6,R0
   3430          		FREE_BUF();
   \   0000003A   0x0038             MOVS     R0,R7
   \   0000003C   0x.... 0x....      BL       ff_memfree
   3431          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD104             BNE.N    ??f_chmod_3
   \   00000046   0x9806             LDR      R0,[SP, #+24]
   \   00000048   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000004A   0x0680             LSLS     R0,R0,#+26
   \   0000004C   0xD500             BPL.N    ??f_chmod_3
   3432          			res = FR_INVALID_NAME;
   \   0000004E   0x2606             MOVS     R6,#+6
   3433          		if (res == FR_OK) {
   \                     ??f_chmod_3:
   \   00000050   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000052   0x2E00             CMP      R6,#+0
   \   00000054   0xD113             BNE.N    ??f_chmod_0
   3434          			dir = dj.dir;
   \   00000056   0x9805             LDR      R0,[SP, #+20]
   3435          			if (!dir) {						/* Is it a root directory? */
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD101             BNE.N    ??f_chmod_4
   3436          				res = FR_INVALID_NAME;
   \   0000005C   0x2606             MOVS     R6,#+6
   \   0000005E   0xE00E             B.N      ??f_chmod_0
   3437          			} else {						/* File or sub directory */
   3438          				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
   \                     ??f_chmod_4:
   \   00000060   0xF015 0x0527      ANDS     R5,R5,#0x27
   3439          				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
   \   00000064   0xEA15 0x0104      ANDS     R1,R5,R4
   \   00000068   0x7AC2             LDRB     R2,[R0, #+11]
   \   0000006A   0x43AA             BICS     R2,R2,R5
   \   0000006C   0x4311             ORRS     R1,R2,R1
   \   0000006E   0x72C1             STRB     R1,[R0, #+11]
   3440          				dj.fs->wflag = 1;
   \   00000070   0x9800             LDR      R0,[SP, #+0]
   \   00000072   0x2101             MOVS     R1,#+1
   \   00000074   0x7101             STRB     R1,[R0, #+4]
   3441          				res = sync_fs(dj.fs);
   \   00000076   0x9800             LDR      R0,[SP, #+0]
   \   00000078   0x.... 0x....      BL       sync_fs
   \   0000007C   0x0006             MOVS     R6,R0
   3442          			}
   3443          		}
   3444          	}
   3445          
   3446          	LEAVE_FF(dj.fs, res);
   \                     ??f_chmod_0:
   \   0000007E   0x0030             MOVS     R0,R6
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_chmod_2:
   \   00000082   0xB00D             ADD      SP,SP,#+52
   \   00000084   0xBDF0             POP      {R4-R7,PC}       ;; return
   3447          }
   3448          
   3449          
   3450          
   3451          
   3452          /*-----------------------------------------------------------------------*/
   3453          /* Change Timestamp                                                      */
   3454          /*-----------------------------------------------------------------------*/
   3455          

   \                                 In section .text, align 2, keep-with-next
   3456          FRESULT f_utime (
   3457          	const TCHAR *path,	/* Pointer to the file/directory name */
   3458          	const FILINFO *fno	/* Pointer to the time stamp to be set */
   3459          )
   3460          {
   \                     f_utime:
   \   00000000   0xB571             PUSH     {R0,R4-R6,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
   \   00000004   0x000C             MOVS     R4,R1
   3461          	FRESULT res;
   3462          	DIR dj;
   3463          	BYTE *dir;
   3464          	DEF_NAMEBUF;
   3465          
   3466          
   3467          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0xA80D             ADD      R0,SP,#+52
   \   0000000C   0x.... 0x....      BL       chk_mounted
   \   00000010   0x0005             MOVS     R5,R0
   3468          	if (res == FR_OK) {
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD135             BNE.N    ??f_utime_0
   3469          		INIT_BUF(dj);
   \   00000018   0x2082             MOVS     R0,#+130
   \   0000001A   0x.... 0x....      BL       ff_memalloc
   \   0000001E   0x0006             MOVS     R6,R0
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD101             BNE.N    ??f_utime_1
   \   00000024   0x2011             MOVS     R0,#+17
   \   00000026   0xE02F             B.N      ??f_utime_2
   \                     ??f_utime_1:
   \   00000028   0x9607             STR      R6,[SP, #+28]
   \   0000002A   0xA809             ADD      R0,SP,#+36
   \   0000002C   0x9006             STR      R0,[SP, #+24]
   3470          		res = follow_path(&dj, path);	/* Follow the file path */
   \   0000002E   0x990D             LDR      R1,[SP, #+52]
   \   00000030   0xA800             ADD      R0,SP,#+0
   \   00000032   0x.... 0x....      BL       follow_path
   \   00000036   0x0005             MOVS     R5,R0
   3471          		FREE_BUF();
   \   00000038   0x0030             MOVS     R0,R6
   \   0000003A   0x.... 0x....      BL       ff_memfree
   3472          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D00             CMP      R5,#+0
   \   00000042   0xD104             BNE.N    ??f_utime_3
   \   00000044   0x9806             LDR      R0,[SP, #+24]
   \   00000046   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000048   0x0680             LSLS     R0,R0,#+26
   \   0000004A   0xD500             BPL.N    ??f_utime_3
   3473          			res = FR_INVALID_NAME;
   \   0000004C   0x2506             MOVS     R5,#+6
   3474          		if (res == FR_OK) {
   \                     ??f_utime_3:
   \   0000004E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000050   0x2D00             CMP      R5,#+0
   \   00000052   0xD117             BNE.N    ??f_utime_0
   3475          			dir = dj.dir;
   \   00000054   0x9805             LDR      R0,[SP, #+20]
   3476          			if (!dir) {					/* Root directory */
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD101             BNE.N    ??f_utime_4
   3477          				res = FR_INVALID_NAME;
   \   0000005A   0x2506             MOVS     R5,#+6
   \   0000005C   0xE012             B.N      ??f_utime_0
   3478          			} else {					/* File or sub-directory */
   3479          				ST_WORD(dir+DIR_WrtTime, fno->ftime);
   \                     ??f_utime_4:
   \   0000005E   0x88E1             LDRH     R1,[R4, #+6]
   \   00000060   0x7581             STRB     R1,[R0, #+22]
   \   00000062   0x88E1             LDRH     R1,[R4, #+6]
   \   00000064   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000066   0x0A09             LSRS     R1,R1,#+8
   \   00000068   0x75C1             STRB     R1,[R0, #+23]
   3480          				ST_WORD(dir+DIR_WrtDate, fno->fdate);
   \   0000006A   0x88A1             LDRH     R1,[R4, #+4]
   \   0000006C   0x7601             STRB     R1,[R0, #+24]
   \   0000006E   0x88A1             LDRH     R1,[R4, #+4]
   \   00000070   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000072   0x0A09             LSRS     R1,R1,#+8
   \   00000074   0x7641             STRB     R1,[R0, #+25]
   3481          				dj.fs->wflag = 1;
   \   00000076   0x9800             LDR      R0,[SP, #+0]
   \   00000078   0x2101             MOVS     R1,#+1
   \   0000007A   0x7101             STRB     R1,[R0, #+4]
   3482          				res = sync_fs(dj.fs);
   \   0000007C   0x9800             LDR      R0,[SP, #+0]
   \   0000007E   0x.... 0x....      BL       sync_fs
   \   00000082   0x0005             MOVS     R5,R0
   3483          			}
   3484          		}
   3485          	}
   3486          
   3487          	LEAVE_FF(dj.fs, res);
   \                     ??f_utime_0:
   \   00000084   0x0028             MOVS     R0,R5
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_utime_2:
   \   00000088   0xB00E             ADD      SP,SP,#+56
   \   0000008A   0xBD70             POP      {R4-R6,PC}       ;; return
   3488          }
   3489          
   3490          
   3491          
   3492          
   3493          /*-----------------------------------------------------------------------*/
   3494          /* Rename File/Directory                                                 */
   3495          /*-----------------------------------------------------------------------*/
   3496          

   \                                 In section .text, align 2, keep-with-next
   3497          FRESULT f_rename (
   3498          	const TCHAR *path_old,	/* Pointer to the old name */
   3499          	const TCHAR *path_new	/* Pointer to the new name */
   3500          )
   3501          {
   \                     f_rename:
   \   00000000   0xB571             PUSH     {R0,R4-R6,LR}
   \   00000002   0xB09B             SUB      SP,SP,#+108
   \   00000004   0x000C             MOVS     R4,R1
   3502          	FRESULT res;
   3503          	DIR djo, djn;
   3504          	BYTE buf[21], *dir;
   3505          	DWORD dw;
   3506          	DEF_NAMEBUF;
   3507          
   3508          
   3509          	res = chk_mounted(&path_old, &djo.fs, 1);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0xA81B             ADD      R0,SP,#+108
   \   0000000C   0x.... 0x....      BL       chk_mounted
   \   00000010   0x0006             MOVS     R6,R0
   3510          	if (res == FR_OK) {
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xF040 0x809D      BNE.W    ??f_rename_0
   3511          		djn.fs = djo.fs;
   \   0000001A   0x9800             LDR      R0,[SP, #+0]
   \   0000001C   0x9009             STR      R0,[SP, #+36]
   3512          		INIT_BUF(djo);
   \   0000001E   0x2082             MOVS     R0,#+130
   \   00000020   0x.... 0x....      BL       ff_memalloc
   \   00000024   0x0005             MOVS     R5,R0
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD101             BNE.N    ??f_rename_1
   \   0000002A   0x2011             MOVS     R0,#+17
   \   0000002C   0xE094             B.N      ??f_rename_2
   \                     ??f_rename_1:
   \   0000002E   0x9507             STR      R5,[SP, #+28]
   \   00000030   0xA812             ADD      R0,SP,#+72
   \   00000032   0x9006             STR      R0,[SP, #+24]
   3513          		res = follow_path(&djo, path_old);		/* Check old object */
   \   00000034   0x991B             LDR      R1,[SP, #+108]
   \   00000036   0xA800             ADD      R0,SP,#+0
   \   00000038   0x.... 0x....      BL       follow_path
   \   0000003C   0x0006             MOVS     R6,R0
   3514          		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
   \   0000003E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000040   0x2E00             CMP      R6,#+0
   \   00000042   0xD104             BNE.N    ??f_rename_3
   \   00000044   0x9806             LDR      R0,[SP, #+24]
   \   00000046   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000048   0x0680             LSLS     R0,R0,#+26
   \   0000004A   0xD500             BPL.N    ??f_rename_3
   3515          			res = FR_INVALID_NAME;
   \   0000004C   0x2606             MOVS     R6,#+6
   3516          #if _FS_LOCK
   3517          		if (res == FR_OK) res = chk_lock(&djo, 2);
   \                     ??f_rename_3:
   \   0000004E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000050   0x2E00             CMP      R6,#+0
   \   00000052   0xD104             BNE.N    ??f_rename_4
   \   00000054   0x2102             MOVS     R1,#+2
   \   00000056   0xA800             ADD      R0,SP,#+0
   \   00000058   0x.... 0x....      BL       chk_lock
   \   0000005C   0x0006             MOVS     R6,R0
   3518          #endif
   3519          		if (res == FR_OK) {						/* Old object is found */
   \                     ??f_rename_4:
   \   0000005E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000060   0x2E00             CMP      R6,#+0
   \   00000062   0xD174             BNE.N    ??f_rename_5
   3520          			if (!djo.dir) {						/* Is root dir? */
   \   00000064   0x9805             LDR      R0,[SP, #+20]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD101             BNE.N    ??f_rename_6
   3521          				res = FR_NO_FILE;
   \   0000006A   0x2604             MOVS     R6,#+4
   \   0000006C   0xE06F             B.N      ??f_rename_5
   3522          			} else {
   3523          				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
   \                     ??f_rename_6:
   \   0000006E   0x2215             MOVS     R2,#+21
   \   00000070   0x9805             LDR      R0,[SP, #+20]
   \   00000072   0xF110 0x010B      ADDS     R1,R0,#+11
   \   00000076   0xA815             ADD      R0,SP,#+84
   \   00000078   0x.... 0x....      BL       mem_cpy
   3524          				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
   \   0000007C   0x2224             MOVS     R2,#+36
   \   0000007E   0xA900             ADD      R1,SP,#+0
   \   00000080   0xA809             ADD      R0,SP,#+36
   \   00000082   0x.... 0x....      BL       mem_cpy
   3525          				res = follow_path(&djn, path_new);
   \   00000086   0x0021             MOVS     R1,R4
   \   00000088   0xA809             ADD      R0,SP,#+36
   \   0000008A   0x.... 0x....      BL       follow_path
   \   0000008E   0x0006             MOVS     R6,R0
   3526          				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
   \   00000090   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000092   0x2E00             CMP      R6,#+0
   \   00000094   0xD100             BNE.N    ??f_rename_7
   \   00000096   0x2608             MOVS     R6,#+8
   3527          				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
   \                     ??f_rename_7:
   \   00000098   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009A   0x2E04             CMP      R6,#+4
   \   0000009C   0xD157             BNE.N    ??f_rename_5
   3528          /* Start critical section that any interruption can cause a cross-link */
   3529          					res = dir_register(&djn);			/* Register the new entry */
   \   0000009E   0xA809             ADD      R0,SP,#+36
   \   000000A0   0x.... 0x....      BL       dir_register
   \   000000A4   0x0006             MOVS     R6,R0
   3530          					if (res == FR_OK) {
   \   000000A6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A8   0x2E00             CMP      R6,#+0
   \   000000AA   0xD150             BNE.N    ??f_rename_5
   3531          						dir = djn.dir;					/* Copy object information except for name */
   \   000000AC   0x9C0E             LDR      R4,[SP, #+56]
   3532          						mem_cpy(dir+13, buf+2, 19);
   \   000000AE   0x2213             MOVS     R2,#+19
   \   000000B0   0xF10D 0x0156      ADD      R1,SP,#+86
   \   000000B4   0xF114 0x000D      ADDS     R0,R4,#+13
   \   000000B8   0x.... 0x....      BL       mem_cpy
   3533          						dir[DIR_Attr] = buf[0] | AM_ARC;
   \   000000BC   0xF89D 0x0054      LDRB     R0,[SP, #+84]
   \   000000C0   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000C4   0x72E0             STRB     R0,[R4, #+11]
   3534          						djo.fs->wflag = 1;
   \   000000C6   0x9800             LDR      R0,[SP, #+0]
   \   000000C8   0x2101             MOVS     R1,#+1
   \   000000CA   0x7101             STRB     R1,[R0, #+4]
   3535          						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
   \   000000CC   0x9802             LDR      R0,[SP, #+8]
   \   000000CE   0x990B             LDR      R1,[SP, #+44]
   \   000000D0   0x4288             CMP      R0,R1
   \   000000D2   0xD02E             BEQ.N    ??f_rename_8
   \   000000D4   0x7AE0             LDRB     R0,[R4, #+11]
   \   000000D6   0x06C0             LSLS     R0,R0,#+27
   \   000000D8   0xD52B             BPL.N    ??f_rename_8
   3536          							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
   \   000000DA   0x0021             MOVS     R1,R4
   \   000000DC   0x9800             LDR      R0,[SP, #+0]
   \   000000DE   0x.... 0x....      BL       ld_clust
   \   000000E2   0x0001             MOVS     R1,R0
   \   000000E4   0x9800             LDR      R0,[SP, #+0]
   \   000000E6   0x.... 0x....      BL       clust2sect
   \   000000EA   0x0001             MOVS     R1,R0
   3537          							if (!dw) {
   \   000000EC   0x2900             CMP      R1,#+0
   \   000000EE   0xD101             BNE.N    ??f_rename_9
   3538          								res = FR_INT_ERR;
   \   000000F0   0x2602             MOVS     R6,#+2
   \   000000F2   0xE01E             B.N      ??f_rename_8
   3539          							} else {
   3540          								res = move_window(djo.fs, dw);
   \                     ??f_rename_9:
   \   000000F4   0x9800             LDR      R0,[SP, #+0]
   \   000000F6   0x.... 0x....      BL       move_window
   \   000000FA   0x0006             MOVS     R6,R0
   3541          								dir = djo.fs->win+SZ_DIR;	/* .. entry */
   \   000000FC   0x9800             LDR      R0,[SP, #+0]
   \   000000FE   0xF110 0x0458      ADDS     R4,R0,#+88
   3542          								if (res == FR_OK && dir[1] == '.') {
   \   00000102   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000104   0x2E00             CMP      R6,#+0
   \   00000106   0xD114             BNE.N    ??f_rename_8
   \   00000108   0x7860             LDRB     R0,[R4, #+1]
   \   0000010A   0x282E             CMP      R0,#+46
   \   0000010C   0xD111             BNE.N    ??f_rename_8
   3543          									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
   \   0000010E   0x9800             LDR      R0,[SP, #+0]
   \   00000110   0x7800             LDRB     R0,[R0, #+0]
   \   00000112   0x2803             CMP      R0,#+3
   \   00000114   0xD106             BNE.N    ??f_rename_10
   \   00000116   0x980B             LDR      R0,[SP, #+44]
   \   00000118   0x9900             LDR      R1,[SP, #+0]
   \   0000011A   0x6AC9             LDR      R1,[R1, #+44]
   \   0000011C   0x4288             CMP      R0,R1
   \   0000011E   0xD101             BNE.N    ??f_rename_10
   \   00000120   0x2100             MOVS     R1,#+0
   \   00000122   0xE000             B.N      ??f_rename_11
   \                     ??f_rename_10:
   \   00000124   0x990B             LDR      R1,[SP, #+44]
   3544          									st_clust(dir, dw);
   \                     ??f_rename_11:
   \   00000126   0x0020             MOVS     R0,R4
   \   00000128   0x.... 0x....      BL       st_clust
   3545          									djo.fs->wflag = 1;
   \   0000012C   0x9800             LDR      R0,[SP, #+0]
   \   0000012E   0x2101             MOVS     R1,#+1
   \   00000130   0x7101             STRB     R1,[R0, #+4]
   3546          								}
   3547          							}
   3548          						}
   3549          						if (res == FR_OK) {
   \                     ??f_rename_8:
   \   00000132   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000134   0x2E00             CMP      R6,#+0
   \   00000136   0xD10A             BNE.N    ??f_rename_5
   3550          							res = dir_remove(&djo);		/* Remove old entry */
   \   00000138   0xA800             ADD      R0,SP,#+0
   \   0000013A   0x.... 0x....      BL       dir_remove
   \   0000013E   0x0006             MOVS     R6,R0
   3551          							if (res == FR_OK)
   \   00000140   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000142   0x2E00             CMP      R6,#+0
   \   00000144   0xD103             BNE.N    ??f_rename_5
   3552          								res = sync_fs(djo.fs);
   \   00000146   0x9800             LDR      R0,[SP, #+0]
   \   00000148   0x.... 0x....      BL       sync_fs
   \   0000014C   0x0006             MOVS     R6,R0
   3553          						}
   3554          					}
   3555          /* End critical section */
   3556          				}
   3557          			}
   3558          		}
   3559          		FREE_BUF();
   \                     ??f_rename_5:
   \   0000014E   0x0028             MOVS     R0,R5
   \   00000150   0x.... 0x....      BL       ff_memfree
   3560          	}
   3561          
   3562          	LEAVE_FF(djo.fs, res);
   \                     ??f_rename_0:
   \   00000154   0x0030             MOVS     R0,R6
   \   00000156   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_rename_2:
   \   00000158   0xB01C             ADD      SP,SP,#+112
   \   0000015A   0xBD70             POP      {R4-R6,PC}       ;; return
   3563          }
   3564          
   3565          #endif /* !_FS_READONLY */
   3566          #endif /* _FS_MINIMIZE == 0 */
   3567          #endif /* _FS_MINIMIZE <= 1 */
   3568          #endif /* _FS_MINIMIZE <= 2 */
   3569          
   3570          
   3571          
   3572          #if _USE_LABEL
   3573          /*-----------------------------------------------------------------------*/
   3574          /* Get volume label                                                      */
   3575          /*-----------------------------------------------------------------------*/
   3576          
   3577          FRESULT f_getlabel (
   3578          	const TCHAR* path,	/* Path name of the logical drive number */
   3579          	TCHAR* label,		/* Pointer to a buffer to return the volume label */
   3580          	DWORD* sn			/* Pointer to a variable to return the volume serial number */
   3581          )
   3582          {
   3583          	FRESULT res;
   3584          	DIR dj;
   3585          	UINT i, j;
   3586          
   3587          
   3588          	/* Get logical drive */
   3589          	res = chk_mounted(&path, &dj.fs, 0);
   3590          
   3591          	/* Get volume label */
   3592          	if (res == FR_OK && label) {
   3593          		dj.sclust = 0;					/* Open root dir */
   3594          		res = dir_sdi(&dj, 0);
   3595          		if (res == FR_OK) {
   3596          			res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
   3597          			if (res == FR_OK) {			/* A volume label is exist */
   3598          #if _LFN_UNICODE
   3599          				WCHAR w;
   3600          				i = j = 0;
   3601          				do {
   3602          					w = (i < 11) ? dj.dir[i++] : ' ';
   3603          					if (IsDBCS1(w) && i < 11 && IsDBCS2(dj.dir[i]))
   3604          						w = (w << 8) | dj.dir[i++];
   3605          					label[j++] = ff_convert(w, 1);
   3606          				} while (j < 11);
   3607          #else
   3608          				mem_cpy(label, dj.dir, 11);
   3609          #endif
   3610          				j = 11;
   3611          				do {
   3612          					label[j] = 0;
   3613          					if (!j) break;
   3614          				} while (label[--j] == ' ');
   3615          			}
   3616          			if (res == FR_NO_FILE) {	/* No label, return nul string */
   3617          				label[0] = 0;
   3618          				res = FR_OK;
   3619          			}
   3620          		}
   3621          	}
   3622          
   3623          	/* Get volume serial number */
   3624          	if (res == FR_OK && sn) {
   3625          		res = move_window(dj.fs, dj.fs->volbase);
   3626          		if (res == FR_OK) {
   3627          			i = dj.fs->fs_type == FS_FAT32 ? BS_VolID32 : BS_VolID;
   3628          			*sn = LD_DWORD(&dj.fs->win[i]);
   3629          		}
   3630          	}
   3631          
   3632          	LEAVE_FF(dj.fs, res);
   3633          }
   3634          
   3635          
   3636          
   3637          #if !_FS_READONLY
   3638          /*-----------------------------------------------------------------------*/
   3639          /* Set volume label                                                      */
   3640          /*-----------------------------------------------------------------------*/
   3641          
   3642          FRESULT f_setlabel (
   3643          	const TCHAR* label	/* Pointer to the volume label to set */
   3644          )
   3645          {
   3646          	FRESULT res;
   3647          	DIR dj;
   3648          	BYTE vn[11];
   3649          	UINT i, j, sl;
   3650          	WCHAR w;
   3651          	DWORD tm;
   3652          
   3653          
   3654          	/* Get logical drive */
   3655          	res = chk_mounted(&label, &dj.fs, 1);
   3656          	if (res) LEAVE_FF(dj.fs, res);
   3657          
   3658          	/* Create a volume label in directory form */
   3659          	vn[0] = 0;
   3660          	for (sl = 0; label[sl]; sl++) ;				/* Get name length */
   3661          	for ( ; sl && label[sl-1] == ' '; sl--) ;	/* Remove trailing spaces */
   3662          	if (sl) {	/* Create volume label in directory form */
   3663          		i = j = 0;
   3664          		do {
   3665          #if _LFN_UNICODE
   3666          			w = ff_convert(ff_wtoupper(label[i++]), 0);
   3667          #else
   3668          			w = (BYTE)label[i++];
   3669          			if (IsDBCS1(w))
   3670          				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? (w << 8) | (BYTE)label[i++] : 0;
   3671          #if _USE_LFN
   3672          			w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
   3673          #else
   3674          			if (IsLower(w)) w -= 0x20;			/* To upper ASCII chars */
   3675          #ifdef _EXCVT
   3676          			if (w >= 0x80) w = ExCvt[w - 0x80];	/* To upper extended chars (SBCS cfg) */
   3677          #else
   3678          			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended chars (ASCII cfg) */
   3679          #endif
   3680          #endif
   3681          #endif
   3682          			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid chars for volume label */
   3683          				LEAVE_FF(dj.fs, FR_INVALID_NAME);
   3684          			if (w >= 0x100) vn[j++] = (BYTE)(w >> 8);
   3685          			vn[j++] = (BYTE)w;
   3686          		} while (i < sl);
   3687          		while (j < 11) vn[j++] = ' ';
   3688          	}
   3689          
   3690          	/* Set volume label */
   3691          	dj.sclust = 0;					/* Open root dir */
   3692          	res = dir_sdi(&dj, 0);
   3693          	if (res == FR_OK) {
   3694          		res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
   3695          		if (res == FR_OK) {			/* A volume label is found */
   3696          			if (vn[0]) {
   3697          				mem_cpy(dj.dir, vn, 11);	/* Change the volume label name */
   3698          				tm = get_fattime();
   3699          				ST_DWORD(dj.dir+DIR_WrtTime, tm);
   3700          			} else {
   3701          				dj.dir[0] = DDE;			/* Remove the volume label */
   3702          			}
   3703          			dj.fs->wflag = 1;
   3704          			res = sync_fs(dj.fs);
   3705          		} else {					/* No volume label is found or error */
   3706          			if (res == FR_NO_FILE) {
   3707          				res = FR_OK;
   3708          				if (vn[0]) {				/* Create volume label as new */
   3709          					res = dir_alloc(&dj, 1);	/* Allocate an entry for volume label */
   3710          					if (res == FR_OK) {
   3711          						mem_set(dj.dir, 0, SZ_DIR);	/* Set volume label */
   3712          						mem_cpy(dj.dir, vn, 11);
   3713          						dj.dir[DIR_Attr] = AM_VOL;
   3714          						tm = get_fattime();
   3715          						ST_DWORD(dj.dir+DIR_WrtTime, tm);
   3716          						dj.fs->wflag = 1;
   3717          						res = sync_fs(dj.fs);
   3718          					}
   3719          				}
   3720          			}
   3721          		}
   3722          	}
   3723          
   3724          	LEAVE_FF(dj.fs, res);
   3725          }
   3726          
   3727          #endif /* !_FS_READONLY */
   3728          #endif /* _USE_LABEL */
   3729          
   3730          
   3731          
   3732          /*-----------------------------------------------------------------------*/
   3733          /* Forward data to the stream directly (available on only tiny cfg)      */
   3734          /*-----------------------------------------------------------------------*/
   3735          #if _USE_FORWARD && _FS_TINY
   3736          
   3737          FRESULT f_forward (
   3738          	FIL *fp, 						/* Pointer to the file object */
   3739          	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
   3740          	UINT btf,						/* Number of bytes to forward */
   3741          	UINT *bf						/* Pointer to number of bytes forwarded */
   3742          )
   3743          {
   3744          	FRESULT res;
   3745          	DWORD remain, clst, sect;
   3746          	UINT rcnt;
   3747          	BYTE csect;
   3748          
   3749          
   3750          	*bf = 0;	/* Clear transfer byte counter */
   3751          
   3752          	res = validate(fp);								/* Check validity of the object */
   3753          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   3754          	if (fp->flag & FA__ERROR)						/* Check error flag */
   3755          		LEAVE_FF(fp->fs, FR_INT_ERR);
   3756          	if (!(fp->flag & FA_READ))						/* Check access mode */
   3757          		LEAVE_FF(fp->fs, FR_DENIED);
   3758          
   3759          	remain = fp->fsize - fp->fptr;
   3760          	if (btf > remain) btf = (UINT)remain;			/* Truncate btf by remaining bytes */
   3761          
   3762          	for ( ;  btf && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
   3763          		fp->fptr += rcnt, *bf += rcnt, btf -= rcnt) {
   3764          		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   3765          		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
   3766          			if (!csect) {							/* On the cluster boundary? */
   3767          				clst = (fp->fptr == 0) ?			/* On the top of the file? */
   3768          					fp->sclust : get_fat(fp->fs, fp->clust);
   3769          				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
   3770          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   3771          				fp->clust = clst;					/* Update current cluster */
   3772          			}
   3773          		}
   3774          		sect = clust2sect(fp->fs, fp->clust);		/* Get current data sector */
   3775          		if (!sect) ABORT(fp->fs, FR_INT_ERR);
   3776          		sect += csect;
   3777          		if (move_window(fp->fs, sect))				/* Move sector window */
   3778          			ABORT(fp->fs, FR_DISK_ERR);
   3779          		fp->dsect = sect;
   3780          		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
   3781          		if (rcnt > btf) rcnt = btf;
   3782          		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
   3783          		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
   3784          	}
   3785          
   3786          	LEAVE_FF(fp->fs, FR_OK);
   3787          }
   3788          #endif /* _USE_FORWARD */
   3789          
   3790          
   3791          
   3792          #if _USE_MKFS && !_FS_READONLY
   3793          /*-----------------------------------------------------------------------*/
   3794          /* Create File System on the Drive                                       */
   3795          /*-----------------------------------------------------------------------*/
   3796          #define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
   3797          #define N_FATS		1		/* Number of FAT copies (1 or 2) */
   3798          
   3799          

   \                                 In section .text, align 2, keep-with-next
   3800          FRESULT f_mkfs (
   3801          	BYTE vol,		/* Logical drive number */
   3802          	BYTE sfd,		/* Partitioning rule 0:FDISK, 1:SFD */
   3803          	UINT au			/* Allocation unit size [bytes] */
   3804          )
   3805          {
   \                     f_mkfs:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x468B             MOV      R11,R1
   \   00000008   0x0014             MOVS     R4,R2
   3806          	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
   3807          	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
   3808          	BYTE fmt, md, sys, *tbl, pdrv, part;
   3809          	DWORD n_clst, vs, n, wsect;
   3810          	UINT i;
   3811          	DWORD b_vol, b_fat, b_dir, b_data;	/* LBA */
   3812          	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
   3813          	FATFS *fs;
   3814          	DSTATUS stat;
   3815          
   3816          
   3817          	/* Check mounted drive and clear work area */
   3818          	if (vol >= _VOLUMES) return FR_INVALID_DRIVE;
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD301             BCC.N    ??f_mkfs_0
   \   00000010   0x200B             MOVS     R0,#+11
   \   00000012   0xE352             B.N      ??f_mkfs_1
   3819          	if (sfd > 1) return FR_INVALID_PARAMETER;
   \                     ??f_mkfs_0:
   \   00000014   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000018   0xF1BB 0x0F02      CMP      R11,#+2
   \   0000001C   0xD301             BCC.N    ??f_mkfs_2
   \   0000001E   0x2013             MOVS     R0,#+19
   \   00000020   0xE34B             B.N      ??f_mkfs_1
   3820          	if (au & (au - 1)) return FR_INVALID_PARAMETER;
   \                     ??f_mkfs_2:
   \   00000022   0x1E61             SUBS     R1,R4,#+1
   \   00000024   0x420C             TST      R4,R1
   \   00000026   0xD001             BEQ.N    ??f_mkfs_3
   \   00000028   0x2013             MOVS     R0,#+19
   \   0000002A   0xE346             B.N      ??f_mkfs_1
   3821          	fs = FatFs[vol];
   \                     ??f_mkfs_3:
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000032   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000036   0x9103             STR      R1,[SP, #+12]
   3822          	if (!fs) return FR_NOT_ENABLED;
   \   00000038   0x9903             LDR      R1,[SP, #+12]
   \   0000003A   0x2900             CMP      R1,#+0
   \   0000003C   0xD101             BNE.N    ??f_mkfs_4
   \   0000003E   0x200C             MOVS     R0,#+12
   \   00000040   0xE33B             B.N      ??f_mkfs_1
   3823          	fs->fs_type = 0;
   \                     ??f_mkfs_4:
   \   00000042   0x9903             LDR      R1,[SP, #+12]
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x700A             STRB     R2,[R1, #+0]
   3824          	pdrv = LD2PD(vol);	/* Physical drive */
   \   00000048   0xF88D 0x0008      STRB     R0,[SP, #+8]
   3825          	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/
   \   0000004C   0x2500             MOVS     R5,#+0
   3826          
   3827          	/* Get disk statics */
   3828          	stat = disk_initialize(pdrv);
   \   0000004E   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000052   0x.... 0x....      BL       disk_initialize
   3829          	if (stat & STA_NOINIT) return FR_NOT_READY;
   \   00000056   0x07C1             LSLS     R1,R0,#+31
   \   00000058   0xD501             BPL.N    ??f_mkfs_5
   \   0000005A   0x2003             MOVS     R0,#+3
   \   0000005C   0xE32D             B.N      ??f_mkfs_1
   3830          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   \                     ??f_mkfs_5:
   \   0000005E   0x0740             LSLS     R0,R0,#+29
   \   00000060   0xD501             BPL.N    ??f_mkfs_6
   \   00000062   0x200A             MOVS     R0,#+10
   \   00000064   0xE329             B.N      ??f_mkfs_1
   3831          #if _MAX_SS != 512					/* Get disk sector size */
   3832          	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
   3833          		return FR_DISK_ERR;
   3834          #endif
   3835          	if (_MULTI_PARTITION && part) {
   3836          		/* Get partition information from partition table in the MBR */
   3837          		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
   3838          		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
   3839          		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   3840          		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
   3841          		b_vol = LD_DWORD(tbl+8);	/* Volume start sector */
   3842          		n_vol = LD_DWORD(tbl+12);	/* Volume size */
   3843          	} else {
   3844          		/* Create a partition in this function */
   3845          		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
   \                     ??f_mkfs_6:
   \   00000066   0xAA01             ADD      R2,SP,#+4
   \   00000068   0x2101             MOVS     R1,#+1
   \   0000006A   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000006E   0x.... 0x....      BL       disk_ioctl
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD102             BNE.N    ??f_mkfs_7
   \   00000076   0x9801             LDR      R0,[SP, #+4]
   \   00000078   0x2880             CMP      R0,#+128
   \   0000007A   0xD201             BCS.N    ??f_mkfs_8
   3846          			return FR_DISK_ERR;
   \                     ??f_mkfs_7:
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xE31C             B.N      ??f_mkfs_1
   3847          		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
   \                     ??f_mkfs_8:
   \   00000080   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000084   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000088   0xD001             BEQ.N    ??f_mkfs_9
   \   0000008A   0x2700             MOVS     R7,#+0
   \   0000008C   0xE000             B.N      ??f_mkfs_10
   \                     ??f_mkfs_9:
   \   0000008E   0x273F             MOVS     R7,#+63
   3848          		n_vol -= b_vol;				/* Volume size */
   \                     ??f_mkfs_10:
   \   00000090   0x9801             LDR      R0,[SP, #+4]
   \   00000092   0x1BC0             SUBS     R0,R0,R7
   \   00000094   0x9001             STR      R0,[SP, #+4]
   3849          	}
   3850          
   3851          	if (!au) {				/* AU auto selection */
   \   00000096   0x2C00             CMP      R4,#+0
   \   00000098   0xD113             BNE.N    ??f_mkfs_11
   3852          		vs = n_vol / (2000 / (SS(fs) / 512));
   \   0000009A   0x9801             LDR      R0,[SP, #+4]
   \   0000009C   0xF44F 0x61FA      MOV      R1,#+2000
   \   000000A0   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   3853          		for (i = 0; vs < vst[i]; i++) ;
   \   000000A4   0xF05F 0x0A00      MOVS     R10,#+0
   \   000000A8   0xE001             B.N      ??f_mkfs_12
   \                     ??f_mkfs_13:
   \   000000AA   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \                     ??f_mkfs_12:
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   000000B2   0xF831 0x101A      LDRH     R1,[R1, R10, LSL #+1]
   \   000000B6   0x4288             CMP      R0,R1
   \   000000B8   0xD3F7             BCC.N    ??f_mkfs_13
   3854          		au = cst[i];
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   000000BE   0xF830 0x401A      LDRH     R4,[R0, R10, LSL #+1]
   3855          	}
   3856          	au /= SS(fs);		/* Number of sectors per cluster */
   \                     ??f_mkfs_11:
   \   000000C2   0x0A64             LSRS     R4,R4,#+9
   3857          	if (au == 0) au = 1;
   \   000000C4   0x2C00             CMP      R4,#+0
   \   000000C6   0xD100             BNE.N    ??f_mkfs_14
   \   000000C8   0x2401             MOVS     R4,#+1
   3858          	if (au > 128) au = 128;
   \                     ??f_mkfs_14:
   \   000000CA   0x2C81             CMP      R4,#+129
   \   000000CC   0xD300             BCC.N    ??f_mkfs_15
   \   000000CE   0x2480             MOVS     R4,#+128
   3859          
   3860          	/* Pre-compute number of clusters and FAT sub-type */
   3861          	n_clst = n_vol / au;
   \                     ??f_mkfs_15:
   \   000000D0   0x9801             LDR      R0,[SP, #+4]
   \   000000D2   0xFBB0 0xF6F4      UDIV     R6,R0,R4
   3862          	fmt = FS_FAT12;
   \   000000D6   0x2501             MOVS     R5,#+1
   3863          	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
   \   000000D8   0xF640 0x70F6      MOVW     R0,#+4086
   \   000000DC   0x4286             CMP      R6,R0
   \   000000DE   0xD300             BCC.N    ??f_mkfs_16
   \   000000E0   0x2502             MOVS     R5,#+2
   3864          	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
   \                     ??f_mkfs_16:
   \   000000E2   0xF64F 0x70F6      MOVW     R0,#+65526
   \   000000E6   0x4286             CMP      R6,R0
   \   000000E8   0xD300             BCC.N    ??f_mkfs_17
   \   000000EA   0x2503             MOVS     R5,#+3
   3865          
   3866          	/* Determine offset and size of FAT structure */
   3867          	if (fmt == FS_FAT32) {
   \                     ??f_mkfs_17:
   \   000000EC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000EE   0x2D03             CMP      R5,#+3
   \   000000F0   0xD109             BNE.N    ??f_mkfs_18
   3868          		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
   \   000000F2   0x00B0             LSLS     R0,R6,#+2
   \   000000F4   0xF200 0x2007      ADDW     R0,R0,#+519
   \   000000F8   0xEA5F 0x2950      LSRS     R9,R0,#+9
   3869          		n_rsv = 32;
   \   000000FC   0xF05F 0x0820      MOVS     R8,#+32
   3870          		n_dir = 0;
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x9004             STR      R0,[SP, #+16]
   \   00000104   0xE015             B.N      ??f_mkfs_19
   3871          	} else {
   3872          		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
   \                     ??f_mkfs_18:
   \   00000106   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000108   0x2D01             CMP      R5,#+1
   \   0000010A   0xD107             BNE.N    ??f_mkfs_20
   \   0000010C   0x2003             MOVS     R0,#+3
   \   0000010E   0xFB00 0xF006      MUL      R0,R0,R6
   \   00000112   0x1C40             ADDS     R0,R0,#+1
   \   00000114   0x0840             LSRS     R0,R0,#+1
   \   00000116   0xF110 0x0903      ADDS     R9,R0,#+3
   \   0000011A   0xE002             B.N      ??f_mkfs_21
   \                     ??f_mkfs_20:
   \   0000011C   0x0070             LSLS     R0,R6,#+1
   \   0000011E   0xF110 0x0904      ADDS     R9,R0,#+4
   3873          		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
   \                     ??f_mkfs_21:
   \   00000122   0xF209 0x10FF      ADDW     R0,R9,#+511
   \   00000126   0xEA5F 0x2950      LSRS     R9,R0,#+9
   3874          		n_rsv = 1;
   \   0000012A   0xF05F 0x0801      MOVS     R8,#+1
   3875          		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
   \   0000012E   0x2020             MOVS     R0,#+32
   \   00000130   0x9004             STR      R0,[SP, #+16]
   3876          	}
   3877          	b_fat = b_vol + n_rsv;				/* FAT area start sector */
   \                     ??f_mkfs_19:
   \   00000132   0xEB18 0x0007      ADDS     R0,R8,R7
   \   00000136   0x9005             STR      R0,[SP, #+20]
   3878          	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
   \   00000138   0x9805             LDR      R0,[SP, #+20]
   \   0000013A   0xEB19 0x0000      ADDS     R0,R9,R0
   3879          	b_data = b_dir + n_dir;				/* Data area start sector */
   \   0000013E   0x9904             LDR      R1,[SP, #+16]
   \   00000140   0x180E             ADDS     R6,R1,R0
   3880          	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
   \   00000142   0x9801             LDR      R0,[SP, #+4]
   \   00000144   0x19A1             ADDS     R1,R4,R6
   \   00000146   0x1BC9             SUBS     R1,R1,R7
   \   00000148   0x4288             CMP      R0,R1
   \   0000014A   0xD201             BCS.N    ??f_mkfs_22
   \   0000014C   0x200E             MOVS     R0,#+14
   \   0000014E   0xE2B4             B.N      ??f_mkfs_1
   3881          
   3882          	/* Align data start sector to erase block boundary (for flash memory media) */
   3883          	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
   \                     ??f_mkfs_22:
   \   00000150   0xAA00             ADD      R2,SP,#+0
   \   00000152   0x2103             MOVS     R1,#+3
   \   00000154   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000158   0x.... 0x....      BL       disk_ioctl
   \   0000015C   0x2800             CMP      R0,#+0
   \   0000015E   0xD106             BNE.N    ??f_mkfs_23
   \   00000160   0x9800             LDR      R0,[SP, #+0]
   \   00000162   0x2800             CMP      R0,#+0
   \   00000164   0xD003             BEQ.N    ??f_mkfs_23
   \   00000166   0x9800             LDR      R0,[SP, #+0]
   \   00000168   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000016C   0xD901             BLS.N    ??f_mkfs_24
   \                     ??f_mkfs_23:
   \   0000016E   0x2001             MOVS     R0,#+1
   \   00000170   0x9000             STR      R0,[SP, #+0]
   3884          	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
   \                     ??f_mkfs_24:
   \   00000172   0x9800             LDR      R0,[SP, #+0]
   \   00000174   0x1980             ADDS     R0,R0,R6
   \   00000176   0x1E40             SUBS     R0,R0,#+1
   \   00000178   0x9900             LDR      R1,[SP, #+0]
   \   0000017A   0x1E49             SUBS     R1,R1,#+1
   \   0000017C   0x4388             BICS     R0,R0,R1
   \   0000017E   0x9000             STR      R0,[SP, #+0]
   3885          	n = (n - b_data) / N_FATS;
   \   00000180   0x9800             LDR      R0,[SP, #+0]
   \   00000182   0x1B80             SUBS     R0,R0,R6
   \   00000184   0x2101             MOVS     R1,#+1
   \   00000186   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000018A   0x9000             STR      R0,[SP, #+0]
   3886          	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
   \   0000018C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000018E   0x2D03             CMP      R5,#+3
   \   00000190   0xD107             BNE.N    ??f_mkfs_25
   3887          		n_rsv += n;
   \   00000192   0x9800             LDR      R0,[SP, #+0]
   \   00000194   0xEB10 0x0808      ADDS     R8,R0,R8
   3888          		b_fat += n;
   \   00000198   0x9805             LDR      R0,[SP, #+20]
   \   0000019A   0x9900             LDR      R1,[SP, #+0]
   \   0000019C   0x1808             ADDS     R0,R1,R0
   \   0000019E   0x9005             STR      R0,[SP, #+20]
   \   000001A0   0xE002             B.N      ??f_mkfs_26
   3889          	} else {					/* FAT12/16: Expand FAT size */
   3890          		n_fat += n;
   \                     ??f_mkfs_25:
   \   000001A2   0x9800             LDR      R0,[SP, #+0]
   \   000001A4   0xEB10 0x0909      ADDS     R9,R0,R9
   3891          	}
   3892          
   3893          	/* Determine number of clusters and final check of validity of the FAT sub-type */
   3894          	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
   \                     ??f_mkfs_26:
   \   000001A8   0x9801             LDR      R0,[SP, #+4]
   \   000001AA   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   000001AE   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   000001B2   0x9904             LDR      R1,[SP, #+16]
   \   000001B4   0x1A40             SUBS     R0,R0,R1
   \   000001B6   0xFBB0 0xF6F4      UDIV     R6,R0,R4
   3895          	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
   3896          		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
   \   000001BA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001BC   0x2D02             CMP      R5,#+2
   \   000001BE   0xD103             BNE.N    ??f_mkfs_27
   \   000001C0   0xF640 0x70F6      MOVW     R0,#+4086
   \   000001C4   0x4286             CMP      R6,R0
   \   000001C6   0xD306             BCC.N    ??f_mkfs_28
   \                     ??f_mkfs_27:
   \   000001C8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001CA   0x2D03             CMP      R5,#+3
   \   000001CC   0xD105             BNE.N    ??f_mkfs_29
   \   000001CE   0xF64F 0x70F6      MOVW     R0,#+65526
   \   000001D2   0x4286             CMP      R6,R0
   \   000001D4   0xD201             BCS.N    ??f_mkfs_29
   3897          		return FR_MKFS_ABORTED;
   \                     ??f_mkfs_28:
   \   000001D6   0x200E             MOVS     R0,#+14
   \   000001D8   0xE26F             B.N      ??f_mkfs_1
   3898          
   3899          	switch (fmt) {	/* Determine system ID for partition table */
   \                     ??f_mkfs_29:
   \   000001DA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001DC   0x0028             MOVS     R0,R5
   \   000001DE   0x2801             CMP      R0,#+1
   \   000001E0   0xD002             BEQ.N    ??f_mkfs_30
   \   000001E2   0x2802             CMP      R0,#+2
   \   000001E4   0xD003             BEQ.N    ??f_mkfs_31
   \   000001E6   0xE00C             B.N      ??f_mkfs_32
   3900          	case FS_FAT12:	sys = 0x01; break;
   \                     ??f_mkfs_30:
   \   000001E8   0xF05F 0x0A01      MOVS     R10,#+1
   \   000001EC   0xE00B             B.N      ??f_mkfs_33
   3901          	case FS_FAT16:	sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
   \                     ??f_mkfs_31:
   \   000001EE   0x9801             LDR      R0,[SP, #+4]
   \   000001F0   0xF5B0 0x3F80      CMP      R0,#+65536
   \   000001F4   0xD202             BCS.N    ??f_mkfs_34
   \   000001F6   0xF05F 0x0A04      MOVS     R10,#+4
   \   000001FA   0xE001             B.N      ??f_mkfs_35
   \                     ??f_mkfs_34:
   \   000001FC   0xF05F 0x0A06      MOVS     R10,#+6
   \                     ??f_mkfs_35:
   \   00000200   0xE001             B.N      ??f_mkfs_33
   3902          	default: 		sys = 0x0C;
   \                     ??f_mkfs_32:
   \   00000202   0xF05F 0x0A0C      MOVS     R10,#+12
   3903          	}
   3904          
   3905          	if (_MULTI_PARTITION && part) {
   3906          		/* Update system ID in the partition table */
   3907          		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   3908          		tbl[4] = sys;
   3909          		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
   3910          		md = 0xF8;
   3911          	} else {
   3912          		if (sfd) {	/* No partition table (SFD) */
   \                     ??f_mkfs_33:
   \   00000206   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000020A   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000020E   0xD003             BEQ.N    ??f_mkfs_36
   3913          			md = 0xF0;
   \   00000210   0x20F0             MOVS     R0,#+240
   \   00000212   0xF88D 0x0009      STRB     R0,[SP, #+9]
   \   00000216   0xE05D             B.N      ??f_mkfs_37
   3914          		} else {	/* Create partition table (FDISK) */
   3915          			mem_set(fs->win, 0, SS(fs));
   \                     ??f_mkfs_36:
   \   00000218   0xF44F 0x7200      MOV      R2,#+512
   \   0000021C   0x2100             MOVS     R1,#+0
   \   0000021E   0x9803             LDR      R0,[SP, #+12]
   \   00000220   0x3038             ADDS     R0,R0,#+56
   \   00000222   0x.... 0x....      BL       mem_set
   3916          			tbl = fs->win+MBR_Table;	/* Create partition table for single partition in the drive */
   \   00000226   0x9803             LDR      R0,[SP, #+12]
   \   00000228   0xF200 0x1BF6      ADDW     R11,R0,#+502
   3917          			tbl[1] = 1;						/* Partition start head */
   \   0000022C   0x2001             MOVS     R0,#+1
   \   0000022E   0xF88B 0x0001      STRB     R0,[R11, #+1]
   3918          			tbl[2] = 1;						/* Partition start sector */
   \   00000232   0x2001             MOVS     R0,#+1
   \   00000234   0xF88B 0x0002      STRB     R0,[R11, #+2]
   3919          			tbl[3] = 0;						/* Partition start cylinder */
   \   00000238   0x2000             MOVS     R0,#+0
   \   0000023A   0xF88B 0x0003      STRB     R0,[R11, #+3]
   3920          			tbl[4] = sys;					/* System type */
   \   0000023E   0xF88B 0xA004      STRB     R10,[R11, #+4]
   3921          			tbl[5] = 254;					/* Partition end head */
   \   00000242   0x20FE             MOVS     R0,#+254
   \   00000244   0xF88B 0x0005      STRB     R0,[R11, #+5]
   3922          			n = (b_vol + n_vol) / 63 / 255;
   \   00000248   0x9801             LDR      R0,[SP, #+4]
   \   0000024A   0x19C0             ADDS     R0,R0,R7
   \   0000024C   0x213F             MOVS     R1,#+63
   \   0000024E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000252   0x21FF             MOVS     R1,#+255
   \   00000254   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000258   0x9000             STR      R0,[SP, #+0]
   3923          			tbl[6] = (BYTE)((n >> 2) | 63);	/* Partition end sector */
   \   0000025A   0x9800             LDR      R0,[SP, #+0]
   \   0000025C   0x0880             LSRS     R0,R0,#+2
   \   0000025E   0xF050 0x003F      ORRS     R0,R0,#0x3F
   \   00000262   0xF88B 0x0006      STRB     R0,[R11, #+6]
   3924          			tbl[7] = (BYTE)n;				/* End cylinder */
   \   00000266   0x9800             LDR      R0,[SP, #+0]
   \   00000268   0xF88B 0x0007      STRB     R0,[R11, #+7]
   3925          			ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
   \   0000026C   0x203F             MOVS     R0,#+63
   \   0000026E   0xF88B 0x0008      STRB     R0,[R11, #+8]
   \   00000272   0x2000             MOVS     R0,#+0
   \   00000274   0xF88B 0x0009      STRB     R0,[R11, #+9]
   \   00000278   0x2000             MOVS     R0,#+0
   \   0000027A   0xF88B 0x000A      STRB     R0,[R11, #+10]
   \   0000027E   0x2000             MOVS     R0,#+0
   \   00000280   0xF88B 0x000B      STRB     R0,[R11, #+11]
   3926          			ST_DWORD(tbl+12, n_vol);		/* Partition size in LBA */
   \   00000284   0x9801             LDR      R0,[SP, #+4]
   \   00000286   0xF88B 0x000C      STRB     R0,[R11, #+12]
   \   0000028A   0x9801             LDR      R0,[SP, #+4]
   \   0000028C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000028E   0x0A00             LSRS     R0,R0,#+8
   \   00000290   0xF88B 0x000D      STRB     R0,[R11, #+13]
   \   00000294   0x9801             LDR      R0,[SP, #+4]
   \   00000296   0x0C00             LSRS     R0,R0,#+16
   \   00000298   0xF88B 0x000E      STRB     R0,[R11, #+14]
   \   0000029C   0x9801             LDR      R0,[SP, #+4]
   \   0000029E   0x0E00             LSRS     R0,R0,#+24
   \   000002A0   0xF88B 0x000F      STRB     R0,[R11, #+15]
   3927          			ST_WORD(fs->win+BS_55AA, 0xAA55);	/* MBR signature */
   \   000002A4   0x9803             LDR      R0,[SP, #+12]
   \   000002A6   0x2155             MOVS     R1,#+85
   \   000002A8   0xF880 0x1236      STRB     R1,[R0, #+566]
   \   000002AC   0x9803             LDR      R0,[SP, #+12]
   \   000002AE   0x21AA             MOVS     R1,#+170
   \   000002B0   0xF880 0x1237      STRB     R1,[R0, #+567]
   3928          			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR sector */
   \   000002B4   0x2301             MOVS     R3,#+1
   \   000002B6   0x2200             MOVS     R2,#+0
   \   000002B8   0x9803             LDR      R0,[SP, #+12]
   \   000002BA   0xF110 0x0138      ADDS     R1,R0,#+56
   \   000002BE   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000002C2   0x.... 0x....      BL       disk_write
   \   000002C6   0x2800             CMP      R0,#+0
   \   000002C8   0xD001             BEQ.N    ??f_mkfs_38
   3929          				return FR_DISK_ERR;
   \   000002CA   0x2001             MOVS     R0,#+1
   \   000002CC   0xE1F5             B.N      ??f_mkfs_1
   3930          			md = 0xF8;
   \                     ??f_mkfs_38:
   \   000002CE   0x20F8             MOVS     R0,#+248
   \   000002D0   0xF88D 0x0009      STRB     R0,[SP, #+9]
   3931          		}
   3932          	}
   3933          
   3934          	/* Create BPB in the VBR */
   3935          	tbl = fs->win;							/* Clear sector */
   \                     ??f_mkfs_37:
   \   000002D4   0x9803             LDR      R0,[SP, #+12]
   \   000002D6   0xF110 0x0B38      ADDS     R11,R0,#+56
   3936          	mem_set(tbl, 0, SS(fs));
   \   000002DA   0xF44F 0x7200      MOV      R2,#+512
   \   000002DE   0x2100             MOVS     R1,#+0
   \   000002E0   0x4658             MOV      R0,R11
   \   000002E2   0x.... 0x....      BL       mem_set
   3937          	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
   \   000002E6   0x220B             MOVS     R2,#+11
   \   000002E8   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   000002EC   0x4658             MOV      R0,R11
   \   000002EE   0x.... 0x....      BL       mem_cpy
   3938          	i = SS(fs);								/* Sector size */
   \   000002F2   0xF44F 0x7A00      MOV      R10,#+512
   3939          	ST_WORD(tbl+BPB_BytsPerSec, i);
   \   000002F6   0xF88B 0xA00B      STRB     R10,[R11, #+11]
   \   000002FA   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000002FE   0xEA5F 0x201A      LSRS     R0,R10,#+8
   \   00000302   0xF88B 0x000C      STRB     R0,[R11, #+12]
   3940          	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
   \   00000306   0xF88B 0x400D      STRB     R4,[R11, #+13]
   3941          	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);		/* Reserved sectors */
   \   0000030A   0xF88B 0x800E      STRB     R8,[R11, #+14]
   \   0000030E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000312   0xEA5F 0x2018      LSRS     R0,R8,#+8
   \   00000316   0xF88B 0x000F      STRB     R0,[R11, #+15]
   3942          	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
   \   0000031A   0x2001             MOVS     R0,#+1
   \   0000031C   0xF88B 0x0010      STRB     R0,[R11, #+16]
   3943          	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of rootdir entries */
   \   00000320   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000322   0x2D03             CMP      R5,#+3
   \   00000324   0xD102             BNE.N    ??f_mkfs_39
   \   00000326   0xF05F 0x0A00      MOVS     R10,#+0
   \   0000032A   0xE001             B.N      ??f_mkfs_40
   \                     ??f_mkfs_39:
   \   0000032C   0xF44F 0x7A00      MOV      R10,#+512
   3944          	ST_WORD(tbl+BPB_RootEntCnt, i);
   \                     ??f_mkfs_40:
   \   00000330   0xF88B 0xA011      STRB     R10,[R11, #+17]
   \   00000334   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000338   0xEA5F 0x201A      LSRS     R0,R10,#+8
   \   0000033C   0xF88B 0x0012      STRB     R0,[R11, #+18]
   3945          	if (n_vol < 0x10000) {					/* Number of total sectors */
   \   00000340   0x9801             LDR      R0,[SP, #+4]
   \   00000342   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000346   0xD208             BCS.N    ??f_mkfs_41
   3946          		ST_WORD(tbl+BPB_TotSec16, n_vol);
   \   00000348   0x9801             LDR      R0,[SP, #+4]
   \   0000034A   0xF88B 0x0013      STRB     R0,[R11, #+19]
   \   0000034E   0x9801             LDR      R0,[SP, #+4]
   \   00000350   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000352   0x0A00             LSRS     R0,R0,#+8
   \   00000354   0xF88B 0x0014      STRB     R0,[R11, #+20]
   \   00000358   0xE00F             B.N      ??f_mkfs_42
   3947          	} else {
   3948          		ST_DWORD(tbl+BPB_TotSec32, n_vol);
   \                     ??f_mkfs_41:
   \   0000035A   0x9801             LDR      R0,[SP, #+4]
   \   0000035C   0xF88B 0x0020      STRB     R0,[R11, #+32]
   \   00000360   0x9801             LDR      R0,[SP, #+4]
   \   00000362   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000364   0x0A00             LSRS     R0,R0,#+8
   \   00000366   0xF88B 0x0021      STRB     R0,[R11, #+33]
   \   0000036A   0x9801             LDR      R0,[SP, #+4]
   \   0000036C   0x0C00             LSRS     R0,R0,#+16
   \   0000036E   0xF88B 0x0022      STRB     R0,[R11, #+34]
   \   00000372   0x9801             LDR      R0,[SP, #+4]
   \   00000374   0x0E00             LSRS     R0,R0,#+24
   \   00000376   0xF88B 0x0023      STRB     R0,[R11, #+35]
   3949          	}
   3950          	tbl[BPB_Media] = md;					/* Media descriptor */
   \                     ??f_mkfs_42:
   \   0000037A   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   0000037E   0xF88B 0x0015      STRB     R0,[R11, #+21]
   3951          	ST_WORD(tbl+BPB_SecPerTrk, 63);			/* Number of sectors per track */
   \   00000382   0x203F             MOVS     R0,#+63
   \   00000384   0xF88B 0x0018      STRB     R0,[R11, #+24]
   \   00000388   0x2000             MOVS     R0,#+0
   \   0000038A   0xF88B 0x0019      STRB     R0,[R11, #+25]
   3952          	ST_WORD(tbl+BPB_NumHeads, 255);			/* Number of heads */
   \   0000038E   0x20FF             MOVS     R0,#+255
   \   00000390   0xF88B 0x001A      STRB     R0,[R11, #+26]
   \   00000394   0x2000             MOVS     R0,#+0
   \   00000396   0xF88B 0x001B      STRB     R0,[R11, #+27]
   3953          	ST_DWORD(tbl+BPB_HiddSec, b_vol);		/* Hidden sectors */
   \   0000039A   0xF88B 0x701C      STRB     R7,[R11, #+28]
   \   0000039E   0x0038             MOVS     R0,R7
   \   000003A0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000003A2   0x0A00             LSRS     R0,R0,#+8
   \   000003A4   0xF88B 0x001D      STRB     R0,[R11, #+29]
   \   000003A8   0x0C38             LSRS     R0,R7,#+16
   \   000003AA   0xF88B 0x001E      STRB     R0,[R11, #+30]
   \   000003AE   0x0E38             LSRS     R0,R7,#+24
   \   000003B0   0xF88B 0x001F      STRB     R0,[R11, #+31]
   3954          	n = get_fattime();						/* Use current time as VSN */
   \   000003B4   0x.... 0x....      BL       get_fattime
   \   000003B8   0x9000             STR      R0,[SP, #+0]
   3955          	if (fmt == FS_FAT32) {
   \   000003BA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003BC   0x2D03             CMP      R5,#+3
   \   000003BE   0xD143             BNE.N    ??f_mkfs_43
   3956          		ST_DWORD(tbl+BS_VolID32, n);		/* VSN */
   \   000003C0   0x9800             LDR      R0,[SP, #+0]
   \   000003C2   0xF88B 0x0043      STRB     R0,[R11, #+67]
   \   000003C6   0x9800             LDR      R0,[SP, #+0]
   \   000003C8   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000003CA   0x0A00             LSRS     R0,R0,#+8
   \   000003CC   0xF88B 0x0044      STRB     R0,[R11, #+68]
   \   000003D0   0x9800             LDR      R0,[SP, #+0]
   \   000003D2   0x0C00             LSRS     R0,R0,#+16
   \   000003D4   0xF88B 0x0045      STRB     R0,[R11, #+69]
   \   000003D8   0x9800             LDR      R0,[SP, #+0]
   \   000003DA   0x0E00             LSRS     R0,R0,#+24
   \   000003DC   0xF88B 0x0046      STRB     R0,[R11, #+70]
   3957          		ST_DWORD(tbl+BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
   \   000003E0   0xF88B 0x9024      STRB     R9,[R11, #+36]
   \   000003E4   0x4648             MOV      R0,R9
   \   000003E6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000003E8   0x0A00             LSRS     R0,R0,#+8
   \   000003EA   0xF88B 0x0025      STRB     R0,[R11, #+37]
   \   000003EE   0xEA5F 0x4019      LSRS     R0,R9,#+16
   \   000003F2   0xF88B 0x0026      STRB     R0,[R11, #+38]
   \   000003F6   0xEA5F 0x6019      LSRS     R0,R9,#+24
   \   000003FA   0xF88B 0x0027      STRB     R0,[R11, #+39]
   3958          		ST_DWORD(tbl+BPB_RootClus, 2);		/* Root directory start cluster (2) */
   \   000003FE   0x2002             MOVS     R0,#+2
   \   00000400   0xF88B 0x002C      STRB     R0,[R11, #+44]
   \   00000404   0x2000             MOVS     R0,#+0
   \   00000406   0xF88B 0x002D      STRB     R0,[R11, #+45]
   \   0000040A   0x2000             MOVS     R0,#+0
   \   0000040C   0xF88B 0x002E      STRB     R0,[R11, #+46]
   \   00000410   0x2000             MOVS     R0,#+0
   \   00000412   0xF88B 0x002F      STRB     R0,[R11, #+47]
   3959          		ST_WORD(tbl+BPB_FSInfo, 1);			/* FSInfo record offset (VBR+1) */
   \   00000416   0x2001             MOVS     R0,#+1
   \   00000418   0xF88B 0x0030      STRB     R0,[R11, #+48]
   \   0000041C   0x2000             MOVS     R0,#+0
   \   0000041E   0xF88B 0x0031      STRB     R0,[R11, #+49]
   3960          		ST_WORD(tbl+BPB_BkBootSec, 6);		/* Backup boot record offset (VBR+6) */
   \   00000422   0x2006             MOVS     R0,#+6
   \   00000424   0xF88B 0x0032      STRB     R0,[R11, #+50]
   \   00000428   0x2000             MOVS     R0,#+0
   \   0000042A   0xF88B 0x0033      STRB     R0,[R11, #+51]
   3961          		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
   \   0000042E   0x2080             MOVS     R0,#+128
   \   00000430   0xF88B 0x0040      STRB     R0,[R11, #+64]
   3962          		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
   \   00000434   0x2029             MOVS     R0,#+41
   \   00000436   0xF88B 0x0042      STRB     R0,[R11, #+66]
   3963          		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
   \   0000043A   0x2213             MOVS     R2,#+19
   \   0000043C   0x....             LDR.N    R1,??DataTable14_4
   \   0000043E   0xF11B 0x0047      ADDS     R0,R11,#+71
   \   00000442   0x.... 0x....      BL       mem_cpy
   \   00000446   0xE022             B.N      ??f_mkfs_44
   3964          	} else {
   3965          		ST_DWORD(tbl+BS_VolID, n);			/* VSN */
   \                     ??f_mkfs_43:
   \   00000448   0x9800             LDR      R0,[SP, #+0]
   \   0000044A   0xF88B 0x0027      STRB     R0,[R11, #+39]
   \   0000044E   0x9800             LDR      R0,[SP, #+0]
   \   00000450   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000452   0x0A00             LSRS     R0,R0,#+8
   \   00000454   0xF88B 0x0028      STRB     R0,[R11, #+40]
   \   00000458   0x9800             LDR      R0,[SP, #+0]
   \   0000045A   0x0C00             LSRS     R0,R0,#+16
   \   0000045C   0xF88B 0x0029      STRB     R0,[R11, #+41]
   \   00000460   0x9800             LDR      R0,[SP, #+0]
   \   00000462   0x0E00             LSRS     R0,R0,#+24
   \   00000464   0xF88B 0x002A      STRB     R0,[R11, #+42]
   3966          		ST_WORD(tbl+BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
   \   00000468   0xF88B 0x9016      STRB     R9,[R11, #+22]
   \   0000046C   0x4648             MOV      R0,R9
   \   0000046E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000470   0x0A00             LSRS     R0,R0,#+8
   \   00000472   0xF88B 0x0017      STRB     R0,[R11, #+23]
   3967          		tbl[BS_DrvNum] = 0x80;				/* Drive number */
   \   00000476   0x2080             MOVS     R0,#+128
   \   00000478   0xF88B 0x0024      STRB     R0,[R11, #+36]
   3968          		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
   \   0000047C   0x2029             MOVS     R0,#+41
   \   0000047E   0xF88B 0x0026      STRB     R0,[R11, #+38]
   3969          		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
   \   00000482   0x2213             MOVS     R2,#+19
   \   00000484   0x....             LDR.N    R1,??DataTable14_5
   \   00000486   0xF11B 0x002B      ADDS     R0,R11,#+43
   \   0000048A   0x.... 0x....      BL       mem_cpy
   3970          	}
   3971          	ST_WORD(tbl+BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
   \                     ??f_mkfs_44:
   \   0000048E   0x2055             MOVS     R0,#+85
   \   00000490   0xF88B 0x01FE      STRB     R0,[R11, #+510]
   \   00000494   0x20AA             MOVS     R0,#+170
   \   00000496   0xF88B 0x01FF      STRB     R0,[R11, #+511]
   3972          	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
   \   0000049A   0x2301             MOVS     R3,#+1
   \   0000049C   0x003A             MOVS     R2,R7
   \   0000049E   0x4659             MOV      R1,R11
   \   000004A0   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000004A4   0x.... 0x....      BL       disk_write
   \   000004A8   0x2800             CMP      R0,#+0
   \   000004AA   0xD001             BEQ.N    ??f_mkfs_45
   3973          		return FR_DISK_ERR;
   \   000004AC   0x2001             MOVS     R0,#+1
   \   000004AE   0xE104             B.N      ??f_mkfs_1
   3974          	if (fmt == FS_FAT32)							/* Write backup VBR if needed (VBR+6) */
   \                     ??f_mkfs_45:
   \   000004B0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004B2   0x2D03             CMP      R5,#+3
   \   000004B4   0xD106             BNE.N    ??f_mkfs_46
   3975          		disk_write(pdrv, tbl, b_vol + 6, 1);
   \   000004B6   0x2301             MOVS     R3,#+1
   \   000004B8   0x1DBA             ADDS     R2,R7,#+6
   \   000004BA   0x4659             MOV      R1,R11
   \   000004BC   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000004C0   0x.... 0x....      BL       disk_write
   3976          
   3977          	/* Initialize FAT area */
   3978          	wsect = b_fat;
   \                     ??f_mkfs_46:
   \   000004C4   0xF8DD 0x8014      LDR      R8,[SP, #+20]
   3979          	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
   \   000004C8   0xF05F 0x0A00      MOVS     R10,#+0
   \   000004CC   0xE001             B.N      ??f_mkfs_47
   \                     ??f_mkfs_48:
   \   000004CE   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \                     ??f_mkfs_47:
   \   000004D2   0xF1BA 0x0F00      CMP      R10,#+0
   \   000004D6   0xD17D             BNE.N    ??f_mkfs_49
   3980          		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
   \   000004D8   0xF44F 0x7200      MOV      R2,#+512
   \   000004DC   0x2100             MOVS     R1,#+0
   \   000004DE   0x4658             MOV      R0,R11
   \   000004E0   0x.... 0x....      BL       mem_set
   3981          		n = md;								/* Media descriptor byte */
   \   000004E4   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   000004E8   0x9000             STR      R0,[SP, #+0]
   3982          		if (fmt != FS_FAT32) {
   \   000004EA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004EC   0x2D03             CMP      R5,#+3
   \   000004EE   0xD01A             BEQ.N    ??f_mkfs_50
   3983          			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
   \   000004F0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004F2   0x2D01             CMP      R5,#+1
   \   000004F4   0xD101             BNE.N    ??f_mkfs_51
   \   000004F6   0x....             LDR.N    R0,??DataTable14_6  ;; 0xffff00
   \   000004F8   0xE001             B.N      ??f_mkfs_52
   \                     ??f_mkfs_51:
   \   000004FA   0xF07F 0x00FF      MVNS     R0,#+255
   \                     ??f_mkfs_52:
   \   000004FE   0x9900             LDR      R1,[SP, #+0]
   \   00000500   0x4308             ORRS     R0,R0,R1
   \   00000502   0x9000             STR      R0,[SP, #+0]
   3984          			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT12/16) */
   \   00000504   0x9800             LDR      R0,[SP, #+0]
   \   00000506   0xF88B 0x0000      STRB     R0,[R11, #+0]
   \   0000050A   0x9800             LDR      R0,[SP, #+0]
   \   0000050C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000050E   0x0A00             LSRS     R0,R0,#+8
   \   00000510   0xF88B 0x0001      STRB     R0,[R11, #+1]
   \   00000514   0x9800             LDR      R0,[SP, #+0]
   \   00000516   0x0C00             LSRS     R0,R0,#+16
   \   00000518   0xF88B 0x0002      STRB     R0,[R11, #+2]
   \   0000051C   0x9800             LDR      R0,[SP, #+0]
   \   0000051E   0x0E00             LSRS     R0,R0,#+24
   \   00000520   0xF88B 0x0003      STRB     R0,[R11, #+3]
   \   00000524   0xE02B             B.N      ??f_mkfs_53
   3985          		} else {
   3986          			n |= 0xFFFFFF00;
   \                     ??f_mkfs_50:
   \   00000526   0x9800             LDR      R0,[SP, #+0]
   \   00000528   0xF070 0x00FF      ORNS     R0,R0,#+255
   \   0000052C   0x9000             STR      R0,[SP, #+0]
   3987          			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT32) */
   \   0000052E   0x9800             LDR      R0,[SP, #+0]
   \   00000530   0xF88B 0x0000      STRB     R0,[R11, #+0]
   \   00000534   0x9800             LDR      R0,[SP, #+0]
   \   00000536   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000538   0x0A00             LSRS     R0,R0,#+8
   \   0000053A   0xF88B 0x0001      STRB     R0,[R11, #+1]
   \   0000053E   0x9800             LDR      R0,[SP, #+0]
   \   00000540   0x0C00             LSRS     R0,R0,#+16
   \   00000542   0xF88B 0x0002      STRB     R0,[R11, #+2]
   \   00000546   0x9800             LDR      R0,[SP, #+0]
   \   00000548   0x0E00             LSRS     R0,R0,#+24
   \   0000054A   0xF88B 0x0003      STRB     R0,[R11, #+3]
   3988          			ST_DWORD(tbl+4, 0xFFFFFFFF);
   \   0000054E   0x20FF             MOVS     R0,#+255
   \   00000550   0xF88B 0x0004      STRB     R0,[R11, #+4]
   \   00000554   0x20FF             MOVS     R0,#+255
   \   00000556   0xF88B 0x0005      STRB     R0,[R11, #+5]
   \   0000055A   0x20FF             MOVS     R0,#+255
   \   0000055C   0xF88B 0x0006      STRB     R0,[R11, #+6]
   \   00000560   0x20FF             MOVS     R0,#+255
   \   00000562   0xF88B 0x0007      STRB     R0,[R11, #+7]
   3989          			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
   \   00000566   0x20FF             MOVS     R0,#+255
   \   00000568   0xF88B 0x0008      STRB     R0,[R11, #+8]
   \   0000056C   0x20FF             MOVS     R0,#+255
   \   0000056E   0xF88B 0x0009      STRB     R0,[R11, #+9]
   \   00000572   0x20FF             MOVS     R0,#+255
   \   00000574   0xF88B 0x000A      STRB     R0,[R11, #+10]
   \   00000578   0x200F             MOVS     R0,#+15
   \   0000057A   0xF88B 0x000B      STRB     R0,[R11, #+11]
   3990          		}
   3991          		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   \                     ??f_mkfs_53:
   \   0000057E   0x2301             MOVS     R3,#+1
   \   00000580   0x4642             MOV      R2,R8
   \   00000582   0x4659             MOV      R1,R11
   \   00000584   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000588   0x.... 0x....      BL       disk_write
   \   0000058C   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000590   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000592   0x2800             CMP      R0,#+0
   \   00000594   0xD001             BEQ.N    ??f_mkfs_54
   3992          			return FR_DISK_ERR;
   \   00000596   0x2001             MOVS     R0,#+1
   \   00000598   0xE08F             B.N      ??f_mkfs_1
   3993          		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
   \                     ??f_mkfs_54:
   \   0000059A   0xF44F 0x7200      MOV      R2,#+512
   \   0000059E   0x2100             MOVS     R1,#+0
   \   000005A0   0x4658             MOV      R0,R11
   \   000005A2   0x.... 0x....      BL       mem_set
   3994          		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
   \   000005A6   0x2001             MOVS     R0,#+1
   \   000005A8   0x9000             STR      R0,[SP, #+0]
   \   000005AA   0xE002             B.N      ??f_mkfs_55
   \                     ??f_mkfs_56:
   \   000005AC   0x9800             LDR      R0,[SP, #+0]
   \   000005AE   0x1C40             ADDS     R0,R0,#+1
   \   000005B0   0x9000             STR      R0,[SP, #+0]
   \                     ??f_mkfs_55:
   \   000005B2   0x9800             LDR      R0,[SP, #+0]
   \   000005B4   0x4548             CMP      R0,R9
   \   000005B6   0xD28A             BCS.N    ??f_mkfs_48
   3995          			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   \   000005B8   0x2301             MOVS     R3,#+1
   \   000005BA   0x4642             MOV      R2,R8
   \   000005BC   0x4659             MOV      R1,R11
   \   000005BE   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000005C2   0x.... 0x....      BL       disk_write
   \   000005C6   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000005CA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005CC   0x2800             CMP      R0,#+0
   \   000005CE   0xD0ED             BEQ.N    ??f_mkfs_56
   3996          				return FR_DISK_ERR;
   \   000005D0   0x2001             MOVS     R0,#+1
   \   000005D2   0xE072             B.N      ??f_mkfs_1
   3997          		}
   3998          	}
   3999          
   4000          	/* Initialize root directory */
   4001          	i = (fmt == FS_FAT32) ? au : n_dir;
   \                     ??f_mkfs_49:
   \   000005D4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000005D6   0x2D03             CMP      R5,#+3
   \   000005D8   0xD101             BNE.N    ??f_mkfs_57
   \   000005DA   0x46A2             MOV      R10,R4
   \   000005DC   0xE001             B.N      ??f_mkfs_58
   \                     ??f_mkfs_57:
   \   000005DE   0xF8DD 0xA010      LDR      R10,[SP, #+16]
   4002          	do {
   4003          		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   \                     ??f_mkfs_58:
   \   000005E2   0x2301             MOVS     R3,#+1
   \   000005E4   0x4642             MOV      R2,R8
   \   000005E6   0x4659             MOV      R1,R11
   \   000005E8   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000005EC   0x.... 0x....      BL       disk_write
   \   000005F0   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000005F4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005F6   0x2800             CMP      R0,#+0
   \   000005F8   0xD001             BEQ.N    ??f_mkfs_59
   4004          			return FR_DISK_ERR;
   \   000005FA   0x2001             MOVS     R0,#+1
   \   000005FC   0xE05D             B.N      ??f_mkfs_1
   4005          	} while (--i);
   \                     ??f_mkfs_59:
   \   000005FE   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \   00000602   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000606   0xD1EC             BNE.N    ??f_mkfs_58
   4006          
   4007          #if _USE_ERASE	/* Erase data area if needed */
   4008          	{
   4009          		DWORD eb[2];
   4010          
   4011          		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
   4012          		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
   4013          	}
   4014          #endif
   4015          
   4016          	/* Create FSInfo if needed */
   4017          	if (fmt == FS_FAT32) {
   \   00000608   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000060A   0x2D03             CMP      R5,#+3
   \   0000060C   0xD149             BNE.N    ??f_mkfs_60
   4018          		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
   \   0000060E   0x2052             MOVS     R0,#+82
   \   00000610   0xF88B 0x0000      STRB     R0,[R11, #+0]
   \   00000614   0x2052             MOVS     R0,#+82
   \   00000616   0xF88B 0x0001      STRB     R0,[R11, #+1]
   \   0000061A   0x2061             MOVS     R0,#+97
   \   0000061C   0xF88B 0x0002      STRB     R0,[R11, #+2]
   \   00000620   0x2041             MOVS     R0,#+65
   \   00000622   0xF88B 0x0003      STRB     R0,[R11, #+3]
   4019          		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
   \   00000626   0x2072             MOVS     R0,#+114
   \   00000628   0xF88B 0x01E4      STRB     R0,[R11, #+484]
   \   0000062C   0x2072             MOVS     R0,#+114
   \   0000062E   0xF88B 0x01E5      STRB     R0,[R11, #+485]
   \   00000632   0x2041             MOVS     R0,#+65
   \   00000634   0xF88B 0x01E6      STRB     R0,[R11, #+486]
   \   00000638   0x2061             MOVS     R0,#+97
   \   0000063A   0xF88B 0x01E7      STRB     R0,[R11, #+487]
   4020          		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
   \   0000063E   0x0030             MOVS     R0,R6
   \   00000640   0x1E40             SUBS     R0,R0,#+1
   \   00000642   0xF88B 0x01E8      STRB     R0,[R11, #+488]
   \   00000646   0x0030             MOVS     R0,R6
   \   00000648   0x1E40             SUBS     R0,R0,#+1
   \   0000064A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000064C   0x0A00             LSRS     R0,R0,#+8
   \   0000064E   0xF88B 0x01E9      STRB     R0,[R11, #+489]
   \   00000652   0x1E70             SUBS     R0,R6,#+1
   \   00000654   0x0C00             LSRS     R0,R0,#+16
   \   00000656   0xF88B 0x01EA      STRB     R0,[R11, #+490]
   \   0000065A   0x1E70             SUBS     R0,R6,#+1
   \   0000065C   0x0E00             LSRS     R0,R0,#+24
   \   0000065E   0xF88B 0x01EB      STRB     R0,[R11, #+491]
   4021          		ST_DWORD(tbl+FSI_Nxt_Free, 2);				/* Last allocated cluster# */
   \   00000662   0x2002             MOVS     R0,#+2
   \   00000664   0xF88B 0x01EC      STRB     R0,[R11, #+492]
   \   00000668   0x2000             MOVS     R0,#+0
   \   0000066A   0xF88B 0x01ED      STRB     R0,[R11, #+493]
   \   0000066E   0x2000             MOVS     R0,#+0
   \   00000670   0xF88B 0x01EE      STRB     R0,[R11, #+494]
   \   00000674   0x2000             MOVS     R0,#+0
   \   00000676   0xF88B 0x01EF      STRB     R0,[R11, #+495]
   4022          		ST_WORD(tbl+BS_55AA, 0xAA55);
   \   0000067A   0x2055             MOVS     R0,#+85
   \   0000067C   0xF88B 0x01FE      STRB     R0,[R11, #+510]
   \   00000680   0x20AA             MOVS     R0,#+170
   \   00000682   0xF88B 0x01FF      STRB     R0,[R11, #+511]
   4023          		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR+1) */
   \   00000686   0x2301             MOVS     R3,#+1
   \   00000688   0x1C7A             ADDS     R2,R7,#+1
   \   0000068A   0x4659             MOV      R1,R11
   \   0000068C   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000690   0x.... 0x....      BL       disk_write
   4024          		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR+7) */
   \   00000694   0x2301             MOVS     R3,#+1
   \   00000696   0x1DFA             ADDS     R2,R7,#+7
   \   00000698   0x4659             MOV      R1,R11
   \   0000069A   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000069E   0x.... 0x....      BL       disk_write
   4025          	}
   4026          
   4027          	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
   \                     ??f_mkfs_60:
   \   000006A2   0x2200             MOVS     R2,#+0
   \   000006A4   0x2100             MOVS     R1,#+0
   \   000006A6   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000006AA   0x.... 0x....      BL       disk_ioctl
   \   000006AE   0x2800             CMP      R0,#+0
   \   000006B0   0xD101             BNE.N    ??f_mkfs_61
   \   000006B2   0x2000             MOVS     R0,#+0
   \   000006B4   0xE000             B.N      ??f_mkfs_62
   \                     ??f_mkfs_61:
   \   000006B6   0x2001             MOVS     R0,#+1
   \                     ??f_mkfs_62:
   \   000006B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_mkfs_1:
   \   000006BA   0xB007             ADD      SP,SP,#+28
   \   000006BC   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   4028          }

   \                                 In section .rodata, align 4
   \                     ??vst:
   \   00000000   0x0400 0x0200      DC16 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 0
   \              0x0100 0x0080
   \              0x0040 0x0020
   \              0x0010 0x0008
   \              0x0004 0x0002
   \              0x0000       
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ??cst:
   \   00000000   0x8000 0x4000      DC16 32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512
   \              0x2000 0x1000
   \              0x0800 0x4000
   \              0x2000 0x1000
   \              0x0800 0x0400
   \              0x0200       
   \   00000016   0x00 0x00          DC8 0, 0
   4029          
   4030          
   4031          #if _MULTI_PARTITION
   4032          /*-----------------------------------------------------------------------*/
   4033          /* Divide Physical Drive                                                 */
   4034          /*-----------------------------------------------------------------------*/
   4035          
   4036          FRESULT f_fdisk (
   4037          	BYTE pdrv,			/* Physical drive number */
   4038          	const DWORD szt[],	/* Pointer to the size table for each partitions */
   4039          	void* work			/* Pointer to the working buffer */
   4040          )
   4041          {
   4042          	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
   4043          	BYTE s_hd, e_hd, *p, *buf = (BYTE*)work;
   4044          	DSTATUS stat;
   4045          	DWORD sz_disk, sz_part, s_part;
   4046          
   4047          
   4048          	stat = disk_initialize(pdrv);
   4049          	if (stat & STA_NOINIT) return FR_NOT_READY;
   4050          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   4051          	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
   4052          
   4053          	/* Determine CHS in the table regardless of the drive geometry */
   4054          	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;
   4055          	if (n == 256) n--;
   4056          	e_hd = n - 1;
   4057          	sz_cyl = 63 * n;
   4058          	tot_cyl = sz_disk / sz_cyl;
   4059          
   4060          	/* Create partition table */
   4061          	mem_set(buf, 0, _MAX_SS);
   4062          	p = buf + MBR_Table; b_cyl = 0;
   4063          	for (i = 0; i < 4; i++, p += SZ_PTE) {
   4064          		p_cyl = (szt[i] <= 100) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
   4065          		if (!p_cyl) continue;
   4066          		s_part = (DWORD)sz_cyl * b_cyl;
   4067          		sz_part = (DWORD)sz_cyl * p_cyl;
   4068          		if (i == 0) {	/* Exclude first track of cylinder 0 */
   4069          			s_hd = 1;
   4070          			s_part += 63; sz_part -= 63;
   4071          		} else {
   4072          			s_hd = 0;
   4073          		}
   4074          		e_cyl = b_cyl + p_cyl - 1;
   4075          		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
   4076          
   4077          		/* Set partition table */
   4078          		p[1] = s_hd;						/* Start head */
   4079          		p[2] = (BYTE)((b_cyl >> 2) + 1);	/* Start sector */
   4080          		p[3] = (BYTE)b_cyl;					/* Start cylinder */
   4081          		p[4] = 0x06;						/* System type (temporary setting) */
   4082          		p[5] = e_hd;						/* End head */
   4083          		p[6] = (BYTE)((e_cyl >> 2) + 63);	/* End sector */
   4084          		p[7] = (BYTE)e_cyl;					/* End cylinder */
   4085          		ST_DWORD(p + 8, s_part);			/* Start sector in LBA */
   4086          		ST_DWORD(p + 12, sz_part);			/* Partition size */
   4087          
   4088          		/* Next partition */
   4089          		b_cyl += p_cyl;
   4090          	}
   4091          	ST_WORD(p, 0xAA55);
   4092          
   4093          	/* Write it to the MBR */
   4094          	return (disk_write(pdrv, buf, 0, 1) || disk_ioctl(pdrv, CTRL_SYNC, 0)) ? FR_DISK_ERR : FR_OK;
   4095          }
   4096          
   4097          
   4098          #endif /* _MULTI_PARTITION */
   4099          #endif /* _USE_MKFS && !_FS_READONLY */
   4100          
   4101          
   4102          
   4103          
   4104          #if _USE_STRFUNC
   4105          /*-----------------------------------------------------------------------*/
   4106          /* Get a string from the file                                            */
   4107          /*-----------------------------------------------------------------------*/
   4108          

   \                                 In section .text, align 2, keep-with-next
   4109          TCHAR* f_gets (
   4110          	TCHAR* buff,	/* Pointer to the string buffer to read */
   4111          	int len,		/* Size of string buffer (characters) */
   4112          	FIL* fp			/* Pointer to the file object */
   4113          )
   4114          {
   \                     f_gets:
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x4690             MOV      R8,R2
   4115          	int n = 0;
   \   0000000A   0x2500             MOVS     R5,#+0
   4116          	TCHAR c, *p = buff;
   \   0000000C   0x0026             MOVS     R6,R4
   \   0000000E   0xE7FF             B.N      ??f_gets_0
   4117          	BYTE s[2];
   4118          	UINT rc;
   4119          
   4120          
   4121          	while (n < len - 1) {			/* Read bytes until buffer gets filled */
   4122          		f_read(fp, s, 1, &rc);
   4123          		if (rc != 1) break;			/* Break on EOF or error */
   4124          		c = s[0];
   4125          #if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
   4126          		if (c >= 0x80) {
   4127          			if (c < 0xC0) continue;	/* Skip stray trailer */
   4128          			if (c < 0xE0) {			/* Two-byte sequence */
   4129          				f_read(fp, s, 1, &rc);
   4130          				if (rc != 1) break;
   4131          				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
   4132          				if (c < 0x80) c = '?';
   4133          			} else {
   4134          				if (c < 0xF0) {		/* Three-byte sequence */
   4135          					f_read(fp, s, 2, &rc);
   4136          					if (rc != 2) break;
   4137          					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
   4138          					if (c < 0x800) c = '?';
   4139          				} else {			/* Reject four-byte sequence */
   4140          					c = '?';
   4141          				}
   4142          			}
   4143          		}
   4144          #endif
   4145          #if _USE_STRFUNC >= 2
   4146          		if (c == '\r') continue;	/* Strip '\r' */
   \                     ??f_gets_1:
   \                     ??f_gets_0:
   \   00000010   0x1E78             SUBS     R0,R7,#+1
   \   00000012   0x4285             CMP      R5,R0
   \   00000014   0xDA13             BGE.N    ??f_gets_2
   \   00000016   0xAB00             ADD      R3,SP,#+0
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0xA901             ADD      R1,SP,#+4
   \   0000001C   0x4640             MOV      R0,R8
   \   0000001E   0x.... 0x....      BL       f_read
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD10A             BNE.N    ??f_gets_2
   \                     ??f_gets_3:
   \   00000028   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x280D             CMP      R0,#+13
   \   00000030   0xD0EE             BEQ.N    ??f_gets_1
   4147          #endif
   4148          		*p++ = c;
   \   00000032   0x7030             STRB     R0,[R6, #+0]
   \   00000034   0x1C76             ADDS     R6,R6,#+1
   4149          		n++;
   \   00000036   0x1C6D             ADDS     R5,R5,#+1
   4150          		if (c == '\n') break;		/* Break on EOL */
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x280A             CMP      R0,#+10
   \   0000003C   0xD1E8             BNE.N    ??f_gets_0
   4151          	}
   4152          	*p = 0;
   \                     ??f_gets_2:
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7030             STRB     R0,[R6, #+0]
   4153          	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD100             BNE.N    ??f_gets_4
   \                     ??f_gets_5:
   \   00000046   0x2400             MOVS     R4,#+0
   \                     ??f_gets_4:
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   4154          }
   4155          
   4156          
   4157          
   4158          #if !_FS_READONLY
   4159          #include <stdarg.h>
   4160          /*-----------------------------------------------------------------------*/
   4161          /* Put a character to the file                                           */
   4162          /*-----------------------------------------------------------------------*/
   4163          

   \                                 In section .text, align 2, keep-with-next
   4164          int f_putc (
   4165          	TCHAR c,	/* A character to be output */
   4166          	FIL* fp		/* Pointer to the file object */
   4167          )
   4168          {
   \                     f_putc:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   4169          	UINT bw, btw;
   4170          	BYTE s[3];
   4171          
   4172          
   4173          #if _USE_STRFUNC >= 2
   4174          	if (c == '\n') f_putc ('\r', fp);	/* LF -> CRLF conversion */
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C0A             CMP      R4,#+10
   \   0000000C   0xD103             BNE.N    ??f_putc_0
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0x200D             MOVS     R0,#+13
   \   00000012   0xF7FF 0xFFF5      BL       f_putc
   4175          #endif
   4176          
   4177          #if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
   4178          	if (c < 0x80) {			/* 7-bit */
   4179          		s[0] = (BYTE)c;
   4180          		btw = 1;
   4181          	} else {
   4182          		if (c < 0x800) {	/* 11-bit */
   4183          			s[0] = (BYTE)(0xC0 | (c >> 6));
   4184          			s[1] = (BYTE)(0x80 | (c & 0x3F));
   4185          			btw = 2;
   4186          		} else {			/* 16-bit */
   4187          			s[0] = (BYTE)(0xE0 | (c >> 12));
   4188          			s[1] = (BYTE)(0x80 | ((c >> 6) & 0x3F));
   4189          			s[2] = (BYTE)(0x80 | (c & 0x3F));
   4190          			btw = 3;
   4191          		}
   4192          	}
   4193          #else				/* Write the character without conversion */
   4194          	s[0] = (BYTE)c;
   \                     ??f_putc_0:
   \   00000016   0xF88D 0x4000      STRB     R4,[SP, #+0]
   4195          	btw = 1;
   \   0000001A   0x2401             MOVS     R4,#+1
   4196          #endif
   4197          	f_write(fp, s, btw, &bw);		/* Write the char to the file */
   \   0000001C   0xAB01             ADD      R3,SP,#+4
   \   0000001E   0x0022             MOVS     R2,R4
   \   00000020   0xA900             ADD      R1,SP,#+0
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0x.... 0x....      BL       f_write
   4198          	return (bw == btw) ? 1 : EOF;	/* Return the result */
   \   00000028   0x9801             LDR      R0,[SP, #+4]
   \   0000002A   0x42A0             CMP      R0,R4
   \   0000002C   0xD101             BNE.N    ??f_putc_1
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xE001             B.N      ??f_putc_2
   \                     ??f_putc_1:
   \   00000032   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??f_putc_2:
   \   00000036   0xBD3E             POP      {R1-R5,PC}       ;; return
   4199          }
   4200          
   4201          
   4202          
   4203          
   4204          /*-----------------------------------------------------------------------*/
   4205          /* Put a string to the file                                              */
   4206          /*-----------------------------------------------------------------------*/
   4207          

   \                                 In section .text, align 2, keep-with-next
   4208          int f_puts (
   4209          	const TCHAR* str,	/* Pointer to the string to be output */
   4210          	FIL* fp				/* Pointer to the file object */
   4211          )
   4212          {
   \                     f_puts:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   4213          	int n;
   4214          
   4215          
   4216          	for (n = 0; *str; str++, n++) {
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0xE001             B.N      ??f_puts_0
   \                     ??f_puts_1:
   \   0000000A   0x1C64             ADDS     R4,R4,#+1
   \   0000000C   0x1C76             ADDS     R6,R6,#+1
   \                     ??f_puts_0:
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD009             BEQ.N    ??f_puts_2
   4217          		if (f_putc(*str, fp) == EOF) return EOF;
   \   00000014   0x0029             MOVS     R1,R5
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       f_putc
   \   0000001C   0xF110 0x0F01      CMN      R0,#+1
   \   00000020   0xD1F3             BNE.N    ??f_puts_1
   \   00000022   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000026   0xE000             B.N      ??f_puts_3
   4218          	}
   4219          	return n;
   \                     ??f_puts_2:
   \   00000028   0x0030             MOVS     R0,R6
   \                     ??f_puts_3:
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
   4220          }
   4221          
   4222          
   4223          
   4224          
   4225          /*-----------------------------------------------------------------------*/
   4226          /* Put a formatted string to the file                                    */
   4227          /*-----------------------------------------------------------------------*/
   4228          

   \                                 In section .text, align 2, keep-with-next
   4229          int f_printf (
   4230          	FIL* fp,			/* Pointer to the file object */
   4231          	const TCHAR* str,	/* Pointer to the format string */
   4232          	...					/* Optional arguments... */
   4233          )
   4234          {
   \                     f_printf:
   \   00000000   0xB40D             PUSH     {R0,R2,R3}
   \   00000002   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000006   0xB086             SUB      SP,SP,#+24
   \   00000008   0x000C             MOVS     R4,R1
   4235          	va_list arp;
   4236          	BYTE f, r;
   4237          	UINT i, j, w;
   4238          	ULONG v;
   4239          	TCHAR c, d, s[16], *p;
   4240          	int res, chc, cc;
   4241          
   4242          
   4243          	va_start(arp, str);
   \   0000000A   0xAD10             ADD      R5,SP,#+64
   4244          
   4245          	for (cc = res = 0; cc != EOF; res += cc) {
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0xE006             B.N      ??f_printf_0
   4246          		c = *str++;
   4247          		if (c == 0) break;			/* End of string */
   4248          		if (c != '%') {				/* Non escape character */
   4249          			cc = f_putc(c, fp);
   4250          			if (cc != EOF) cc = 1;
   4251          			continue;
   4252          		}
   4253          		w = f = 0;
   4254          		c = *str++;
   4255          		if (c == '0') {				/* Flag: '0' padding */
   4256          			f = 1; c = *str++;
   4257          		} else {
   4258          			if (c == '-') {			/* Flag: left justified */
   4259          				f = 2; c = *str++;
   4260          			}
   4261          		}
   4262          		while (IsDigit(c)) {		/* Precision */
   4263          			w = w * 10 + c - '0';
   4264          			c = *str++;
   4265          		}
   4266          		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
   4267          			f |= 4; c = *str++;
   4268          		}
   4269          		if (!c) break;
   4270          		d = c;
   4271          		if (IsLower(d)) d -= 0x20;
   4272          		switch (d) {				/* Type is... */
   4273          		case 'S' :					/* String */
   4274          			p = va_arg(arp, TCHAR*);
   4275          			for (j = 0; p[j]; j++) ;
   4276          			chc = 0;
   4277          			if (!(f & 2)) {
   4278          				while (j++ < w) chc += (cc = f_putc(' ', fp));
   4279          			}
   4280          			chc += (cc = f_puts(p, fp));
   4281          			while (j++ < w) chc += (cc = f_putc(' ', fp));
   4282          			if (cc != EOF) cc = chc;
   4283          			continue;
   4284          		case 'C' :					/* Character */
   4285          			cc = f_putc((TCHAR)va_arg(arp, int), fp); continue;
   4286          		case 'B' :					/* Binary */
   4287          			r = 2; break;
   4288          		case 'O' :					/* Octal */
   4289          			r = 8; break;
   4290          		case 'D' :					/* Signed decimal */
   4291          		case 'U' :					/* Unsigned decimal */
   4292          			r = 10; break;
   4293          		case 'X' :					/* Hexdecimal */
   4294          			r = 16; break;
   4295          		default:					/* Unknown type (pass-through) */
   4296          			cc = f_putc(c, fp); continue;
   4297          		}
   4298          
   4299          		/* Get an argument and put it in numeral */
   4300          		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int));
   4301          		if (d == 'D' && (v & 0x80000000)) {
   4302          			v = 0 - v;
   4303          			f |= 8;
   4304          		}
   4305          		i = 0;
   4306          		do {
   4307          			d = (TCHAR)(v % r); v /= r;
   4308          			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
   4309          			s[i++] = d + '0';
   4310          		} while (v && i < sizeof s / sizeof s[0]);
   4311          		if (f & 8) s[i++] = '-';
   4312          		j = i; d = (f & 1) ? '0' : ' ';
   4313          		chc = 0;
   4314          		while (!(f & 2) && j++ < w) chc += (cc = f_putc(d, fp));
   4315          		do chc += (cc = f_putc(s[--i], fp)); while(i);
   4316          		while (j++ < w) chc += (cc = f_putc(' ', fp));
   4317          		if (cc != EOF) cc = chc;
   \                     ??f_printf_1:
   \   00000012   0xF110 0x0F01      CMN      R0,#+1
   \   00000016   0xD000             BEQ.N    ??f_printf_2
   \   00000018   0x0030             MOVS     R0,R6
   \                     ??f_printf_2:
   \   0000001A   0x9900             LDR      R1,[SP, #+0]
   \   0000001C   0x1841             ADDS     R1,R0,R1
   \   0000001E   0x9100             STR      R1,[SP, #+0]
   \                     ??f_printf_0:
   \   00000020   0xF110 0x0F01      CMN      R0,#+1
   \   00000024   0xD004             BEQ.N    ??f_printf_3
   \   00000026   0x7822             LDRB     R2,[R4, #+0]
   \   00000028   0x1C64             ADDS     R4,R4,#+1
   \   0000002A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002C   0x2A00             CMP      R2,#+0
   \   0000002E   0xD104             BNE.N    ??f_printf_4
   4318          	}
   4319          
   4320          	va_end(arp);
   4321          	return (cc == EOF) ? cc : res;
   \                     ??f_printf_3:
   \   00000030   0xF110 0x0F01      CMN      R0,#+1
   \   00000034   0xF040 0x810E      BNE.W    ??f_printf_5
   \   00000038   0xE10D             B.N      ??f_printf_6
   \                     ??f_printf_4:
   \   0000003A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000003C   0x2A25             CMP      R2,#+37
   \   0000003E   0xD009             BEQ.N    ??f_printf_7
   \   00000040   0x990F             LDR      R1,[SP, #+60]
   \   00000042   0x0010             MOVS     R0,R2
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x.... 0x....      BL       f_putc
   \   0000004A   0xF110 0x0F01      CMN      R0,#+1
   \   0000004E   0xD000             BEQ.N    ??f_printf_8
   \   00000050   0x2001             MOVS     R0,#+1
   \                     ??f_printf_8:
   \   00000052   0xE7E2             B.N      ??f_printf_2
   \                     ??f_printf_7:
   \   00000054   0xF05F 0x0800      MOVS     R8,#+0
   \   00000058   0x4647             MOV      R7,R8
   \   0000005A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000005E   0x7822             LDRB     R2,[R4, #+0]
   \   00000060   0x1C64             ADDS     R4,R4,#+1
   \   00000062   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000064   0x2A30             CMP      R2,#+48
   \   00000066   0xD103             BNE.N    ??f_printf_9
   \   00000068   0x2701             MOVS     R7,#+1
   \   0000006A   0x7822             LDRB     R2,[R4, #+0]
   \   0000006C   0x1C64             ADDS     R4,R4,#+1
   \   0000006E   0xE00E             B.N      ??f_printf_10
   \                     ??f_printf_9:
   \   00000070   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000072   0x2A2D             CMP      R2,#+45
   \   00000074   0xD10B             BNE.N    ??f_printf_10
   \   00000076   0x2702             MOVS     R7,#+2
   \   00000078   0x7822             LDRB     R2,[R4, #+0]
   \   0000007A   0x1C64             ADDS     R4,R4,#+1
   \   0000007C   0xE007             B.N      ??f_printf_10
   \                     ??f_printf_11:
   \   0000007E   0x210A             MOVS     R1,#+10
   \   00000080   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000082   0xFB01 0x2108      MLA      R1,R1,R8,R2
   \   00000086   0xF1B1 0x0830      SUBS     R8,R1,#+48
   \   0000008A   0x7822             LDRB     R2,[R4, #+0]
   \   0000008C   0x1C64             ADDS     R4,R4,#+1
   \                     ??f_printf_10:
   \   0000008E   0xF1B2 0x0130      SUBS     R1,R2,#+48
   \   00000092   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000094   0x290A             CMP      R1,#+10
   \   00000096   0xD3F2             BCC.N    ??f_printf_11
   \   00000098   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000009A   0x2A6C             CMP      R2,#+108
   \   0000009C   0xD002             BEQ.N    ??f_printf_12
   \   0000009E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000A0   0x2A4C             CMP      R2,#+76
   \   000000A2   0xD103             BNE.N    ??f_printf_13
   \                     ??f_printf_12:
   \   000000A4   0xF057 0x0704      ORRS     R7,R7,#0x4
   \   000000A8   0x7822             LDRB     R2,[R4, #+0]
   \   000000AA   0x1C64             ADDS     R4,R4,#+1
   \                     ??f_printf_13:
   \   000000AC   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000AE   0x2A00             CMP      R2,#+0
   \   000000B0   0xD0BE             BEQ.N    ??f_printf_3
   \                     ??f_printf_14:
   \   000000B2   0x4693             MOV      R11,R2
   \   000000B4   0xF1BB 0x0061      SUBS     R0,R11,#+97
   \   000000B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BA   0x281A             CMP      R0,#+26
   \   000000BC   0xD201             BCS.N    ??f_printf_15
   \   000000BE   0xF1BB 0x0B20      SUBS     R11,R11,#+32
   \                     ??f_printf_15:
   \   000000C2   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000C6   0x4658             MOV      R0,R11
   \   000000C8   0x2842             CMP      R0,#+66
   \   000000CA   0xD043             BEQ.N    ??f_printf_16
   \   000000CC   0x2843             CMP      R0,#+67
   \   000000CE   0xD039             BEQ.N    ??f_printf_17
   \   000000D0   0x2844             CMP      R0,#+68
   \   000000D2   0xD047             BEQ.N    ??f_printf_18
   \   000000D4   0x284F             CMP      R0,#+79
   \   000000D6   0xD043             BEQ.N    ??f_printf_19
   \   000000D8   0x2853             CMP      R0,#+83
   \   000000DA   0xD004             BEQ.N    ??f_printf_20
   \   000000DC   0x2855             CMP      R0,#+85
   \   000000DE   0xD041             BEQ.N    ??f_printf_18
   \   000000E0   0x2858             CMP      R0,#+88
   \   000000E2   0xD041             BEQ.N    ??f_printf_21
   \   000000E4   0xE042             B.N      ??f_printf_22
   \                     ??f_printf_20:
   \   000000E6   0xF8D5 0xA000      LDR      R10,[R5, #+0]
   \   000000EA   0x1D2D             ADDS     R5,R5,#+4
   \   000000EC   0xF05F 0x0900      MOVS     R9,#+0
   \   000000F0   0xE001             B.N      ??f_printf_23
   \                     ??f_printf_24:
   \   000000F2   0xF119 0x0901      ADDS     R9,R9,#+1
   \                     ??f_printf_23:
   \   000000F6   0xF819 0x000A      LDRB     R0,[R9, R10]
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD1F9             BNE.N    ??f_printf_24
   \   000000FE   0x2600             MOVS     R6,#+0
   \   00000100   0x07B8             LSLS     R0,R7,#+30
   \   00000102   0xD40A             BMI.N    ??f_printf_25
   \   00000104   0xE004             B.N      ??f_printf_26
   \                     ??f_printf_27:
   \   00000106   0x990F             LDR      R1,[SP, #+60]
   \   00000108   0x2020             MOVS     R0,#+32
   \   0000010A   0x.... 0x....      BL       f_putc
   \   0000010E   0x1986             ADDS     R6,R0,R6
   \                     ??f_printf_26:
   \   00000110   0x4648             MOV      R0,R9
   \   00000112   0xF110 0x0901      ADDS     R9,R0,#+1
   \   00000116   0x4540             CMP      R0,R8
   \   00000118   0xD3F5             BCC.N    ??f_printf_27
   \                     ??f_printf_25:
   \   0000011A   0x990F             LDR      R1,[SP, #+60]
   \   0000011C   0x4650             MOV      R0,R10
   \   0000011E   0x.... 0x....      BL       f_puts
   \   00000122   0x1986             ADDS     R6,R0,R6
   \   00000124   0xE004             B.N      ??f_printf_28
   \                     ??f_printf_29:
   \   00000126   0x990F             LDR      R1,[SP, #+60]
   \   00000128   0x2020             MOVS     R0,#+32
   \   0000012A   0x.... 0x....      BL       f_putc
   \   0000012E   0x1986             ADDS     R6,R0,R6
   \                     ??f_printf_28:
   \   00000130   0x4649             MOV      R1,R9
   \   00000132   0xF111 0x0901      ADDS     R9,R1,#+1
   \   00000136   0x4541             CMP      R1,R8
   \   00000138   0xD3F5             BCC.N    ??f_printf_29
   \   0000013A   0xF110 0x0F01      CMN      R0,#+1
   \   0000013E   0xD000             BEQ.N    ??f_printf_30
   \   00000140   0x0030             MOVS     R0,R6
   \                     ??f_printf_30:
   \   00000142   0xE76A             B.N      ??f_printf_2
   \                     ??f_printf_17:
   \   00000144   0x0028             MOVS     R0,R5
   \   00000146   0x1D05             ADDS     R5,R0,#+4
   \   00000148   0x990F             LDR      R1,[SP, #+60]
   \   0000014A   0x6800             LDR      R0,[R0, #+0]
   \   0000014C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000014E   0x.... 0x....      BL       f_putc
   \   00000152   0xE762             B.N      ??f_printf_2
   \                     ??f_printf_16:
   \   00000154   0x2002             MOVS     R0,#+2
   \                     ??f_printf_31:
   \   00000156   0x0779             LSLS     R1,R7,#+29
   \   00000158   0xD50E             BPL.N    ??f_printf_32
   \   0000015A   0x6829             LDR      R1,[R5, #+0]
   \   0000015C   0x1D2D             ADDS     R5,R5,#+4
   \   0000015E   0xE015             B.N      ??f_printf_33
   \                     ??f_printf_19:
   \   00000160   0x2008             MOVS     R0,#+8
   \   00000162   0xE7F8             B.N      ??f_printf_31
   \                     ??f_printf_18:
   \   00000164   0x200A             MOVS     R0,#+10
   \   00000166   0xE7F6             B.N      ??f_printf_31
   \                     ??f_printf_21:
   \   00000168   0x2010             MOVS     R0,#+16
   \   0000016A   0xE7F4             B.N      ??f_printf_31
   \                     ??f_printf_22:
   \   0000016C   0x990F             LDR      R1,[SP, #+60]
   \   0000016E   0x0010             MOVS     R0,R2
   \   00000170   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000172   0x.... 0x....      BL       f_putc
   \   00000176   0xE750             B.N      ??f_printf_2
   \                     ??f_printf_32:
   \   00000178   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000017C   0xF1BB 0x0F44      CMP      R11,#+68
   \   00000180   0xD102             BNE.N    ??f_printf_34
   \   00000182   0x6829             LDR      R1,[R5, #+0]
   \   00000184   0x1D2D             ADDS     R5,R5,#+4
   \   00000186   0xE001             B.N      ??f_printf_33
   \                     ??f_printf_34:
   \   00000188   0x6829             LDR      R1,[R5, #+0]
   \   0000018A   0x1D2D             ADDS     R5,R5,#+4
   \                     ??f_printf_33:
   \   0000018C   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000190   0xF1BB 0x0F44      CMP      R11,#+68
   \   00000194   0xD104             BNE.N    ??f_printf_35
   \   00000196   0x2900             CMP      R1,#+0
   \   00000198   0xD502             BPL.N    ??f_printf_35
   \   0000019A   0x4249             RSBS     R1,R1,#+0
   \   0000019C   0xF057 0x0708      ORRS     R7,R7,#0x8
   \                     ??f_printf_35:
   \   000001A0   0xF05F 0x0A00      MOVS     R10,#+0
   \                     ??f_printf_36:
   \   000001A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001A6   0xFBB1 0xF3F0      UDIV     R3,R1,R0
   \   000001AA   0xFB00 0x1B13      MLS      R11,R0,R3,R1
   \   000001AE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001B0   0xFBB1 0xF1F0      UDIV     R1,R1,R0
   \   000001B4   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000001B8   0xF1BB 0x0F0A      CMP      R11,#+10
   \   000001BC   0xD307             BCC.N    ??f_printf_37
   \   000001BE   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001C0   0x2A78             CMP      R2,#+120
   \   000001C2   0xD101             BNE.N    ??f_printf_38
   \   000001C4   0x2327             MOVS     R3,#+39
   \   000001C6   0xE000             B.N      ??f_printf_39
   \                     ??f_printf_38:
   \   000001C8   0x2307             MOVS     R3,#+7
   \                     ??f_printf_39:
   \   000001CA   0xEB13 0x0B0B      ADDS     R11,R3,R11
   \                     ??f_printf_37:
   \   000001CE   0xAB01             ADD      R3,SP,#+4
   \   000001D0   0xF11B 0x0630      ADDS     R6,R11,#+48
   \   000001D4   0xF80A 0x6003      STRB     R6,[R10, R3]
   \   000001D8   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   000001DC   0x2900             CMP      R1,#+0
   \   000001DE   0xD002             BEQ.N    ??f_printf_40
   \   000001E0   0xF1BA 0x0F10      CMP      R10,#+16
   \   000001E4   0xD3DE             BCC.N    ??f_printf_36
   \                     ??f_printf_40:
   \   000001E6   0x0738             LSLS     R0,R7,#+28
   \   000001E8   0xD505             BPL.N    ??f_printf_41
   \   000001EA   0xA801             ADD      R0,SP,#+4
   \   000001EC   0x212D             MOVS     R1,#+45
   \   000001EE   0xF80A 0x1000      STRB     R1,[R10, R0]
   \   000001F2   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \                     ??f_printf_41:
   \   000001F6   0x46D1             MOV      R9,R10
   \   000001F8   0x07F8             LSLS     R0,R7,#+31
   \   000001FA   0xD502             BPL.N    ??f_printf_42
   \   000001FC   0xF05F 0x0B30      MOVS     R11,#+48
   \   00000200   0xE001             B.N      ??f_printf_43
   \                     ??f_printf_42:
   \   00000202   0xF05F 0x0B20      MOVS     R11,#+32
   \                     ??f_printf_43:
   \   00000206   0x2600             MOVS     R6,#+0
   \   00000208   0xE005             B.N      ??f_printf_44
   \                     ??f_printf_45:
   \   0000020A   0x990F             LDR      R1,[SP, #+60]
   \   0000020C   0x4658             MOV      R0,R11
   \   0000020E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000210   0x.... 0x....      BL       f_putc
   \   00000214   0x1986             ADDS     R6,R0,R6
   \                     ??f_printf_44:
   \   00000216   0x07B8             LSLS     R0,R7,#+30
   \   00000218   0xD404             BMI.N    ??f_printf_46
   \   0000021A   0x4648             MOV      R0,R9
   \   0000021C   0xF110 0x0901      ADDS     R9,R0,#+1
   \   00000220   0x4540             CMP      R0,R8
   \   00000222   0xD3F2             BCC.N    ??f_printf_45
   \                     ??f_printf_46:
   \   00000224   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \   00000228   0x990F             LDR      R1,[SP, #+60]
   \   0000022A   0xA801             ADD      R0,SP,#+4
   \   0000022C   0xF81A 0x0000      LDRB     R0,[R10, R0]
   \   00000230   0x.... 0x....      BL       f_putc
   \   00000234   0x1986             ADDS     R6,R0,R6
   \   00000236   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000023A   0xD1F3             BNE.N    ??f_printf_46
   \                     ??f_printf_47:
   \   0000023C   0x4649             MOV      R1,R9
   \   0000023E   0xF111 0x0901      ADDS     R9,R1,#+1
   \   00000242   0x4541             CMP      R1,R8
   \   00000244   0xF4BF 0xAEE5      BCS.W    ??f_printf_1
   \   00000248   0x990F             LDR      R1,[SP, #+60]
   \   0000024A   0x2020             MOVS     R0,#+32
   \   0000024C   0x.... 0x....      BL       f_putc
   \   00000250   0x1986             ADDS     R6,R0,R6
   \   00000252   0xE7F3             B.N      ??f_printf_47
   \                     ??f_printf_5:
   \   00000254   0x9800             LDR      R0,[SP, #+0]
   \                     ??f_printf_6:
   \   00000256   0xB006             ADD      SP,SP,#+24
   \   00000258   0xE8BD 0x0FF0      POP      {R4-R11}
   \   0000025C   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
   4322          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     Files

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     LfnOfs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     `?<Constant "\\"*:<>?|\\177">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     ExCvt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     `?<Constant "+,;=[]">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x00544146         DC32     0x544146

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     CurrVol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     FatFs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x41615252         DC32     0x41615252

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x61417272         DC32     0x61417272

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x........         DC32     Fsid

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     FatFs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     ??vst

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     ??cst

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x........         DC32     `?<Constant "\\353\\376\\220MSDOS5.0">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x........         DC32     `?<Constant "NO NAME    FAT32   ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x........         DC32     `?<Constant "NO NAME    FAT     ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x00FFFF00         DC32     0xffff00

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"*:<>?|\\177">`:
   \   00000000   0x22 0x2A          DC8 "\"*:<>?|\177"
   \              0x3A 0x3C    
   \              0x3E 0x3F    
   \              0x7C 0x7F    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "+,;=[]">`:
   \   00000000   0x2B 0x2C          DC8 "+,;=[]"
   \              0x3B 0x3D    
   \              0x5B 0x5D    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\353\\376\\220MSDOS5.0">`:
   \   00000000   0xEB 0xFE          DC8 "\353\376\220MSDOS5.0"
   \              0x90 0x4D    
   \              0x53 0x44    
   \              0x4F 0x53    
   \              0x35 0x2E    
   \              0x30 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "NO NAME    FAT32   ">`:
   \   00000000   0x4E 0x4F          DC8 "NO NAME    FAT32   "
   \              0x20 0x4E    
   \              0x41 0x4D    
   \              0x45 0x20    
   \              0x20 0x20    
   \              0x20 0x46    
   \              0x41 0x54    
   \              0x33 0x32    
   \              0x20 0x20    
   \              0x20 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "NO NAME    FAT     ">`:
   \   00000000   0x4E 0x4F          DC8 "NO NAME    FAT     "
   \              0x20 0x4E    
   \              0x41 0x4D    
   \              0x45 0x20    
   \              0x20 0x20    
   \              0x20 0x46    
   \              0x41 0x54    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x00    
   4323          
   4324          #endif /* !_FS_READONLY */
   4325          #endif /* _USE_STRFUNC */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  check_fs
               8 -> disk_read
        0  chk_chr
        8  chk_lock
       24  chk_mounted
              24 -> check_fs
              24 -> clear_lock
              24 -> disk_initialize
              24 -> disk_read
              24 -> disk_status
        0  clear_lock
        0  clmt_clust
        0  clust2sect
       24  cmp_lfn
              24 -> ff_wtoupper
       24  create_chain
              24 -> get_fat
              24 -> put_fat
       40  create_name
              40 -> chk_chr
              40 -> ff_convert
              40 -> mem_set
        0  dec_lock
       16  dir_alloc
              16 -> dir_next
              16 -> dir_sdi
              16 -> move_window
       24  dir_find
              24 -> cmp_lfn
              24 -> dir_next
              24 -> dir_sdi
              24 -> mem_cmp
              24 -> move_window
              24 -> sum_sfn
       24  dir_next
              24 -> clust2sect
              24 -> create_chain
              24 -> get_fat
              24 -> mem_set
              24 -> sync_window
       24  dir_read
              24 -> dir_next
              24 -> move_window
              24 -> pick_lfn
              24 -> sum_sfn
       40  dir_register
              40 -> dir_alloc
              40 -> dir_find
              40 -> dir_next
              40 -> dir_sdi
              40 -> fit_lfn
              40 -> gen_numname
              40 -> mem_cpy
              40 -> mem_set
              40 -> move_window
              40 -> sum_sfn
       16  dir_remove
              16 -> dir_next
              16 -> dir_sdi
              16 -> move_window
       16  dir_sdi
              16 -> clust2sect
              16 -> get_fat
        0  enq_lock
       64  f_chdir
              64 -> chk_mounted
              64 -> ff_memalloc
              64 -> ff_memfree
              64 -> follow_path
              64 -> ld_clust
        0  f_chdrive
       72  f_chmod
              72 -> chk_mounted
              72 -> ff_memalloc
              72 -> ff_memfree
              72 -> follow_path
              72 -> sync_fs
        8  f_close
               8 -> dec_lock
               8 -> f_sync
      112  f_getcwd
             112 -> chk_mounted
             112 -> dir_next
             112 -> dir_read
             112 -> dir_sdi
             112 -> ff_memalloc
             112 -> ff_memfree
             112 -> get_fileinfo
             112 -> ld_clust
       40  f_getfree
              40 -> chk_mounted
              40 -> get_fat
              40 -> move_window
       32  f_gets
              32 -> f_read
       40  f_lseek
              40 -> clmt_clust
              40 -> clust2sect
              40 -> create_chain
              40 -> disk_read
              40 -> disk_write
              40 -> get_fat
              40 -> validate
       88  f_mkdir
              88 -> chk_mounted
              88 -> clust2sect
              88 -> create_chain
              88 -> dir_register
              88 -> ff_memalloc
              88 -> ff_memfree
              88 -> follow_path
              88 -> get_fattime
              88 -> mem_cpy
              88 -> mem_set
              88 -> remove_chain
              88 -> st_clust
              88 -> sync_fs
              88 -> sync_window
       64  f_mkfs
              64 -> disk_initialize
              64 -> disk_ioctl
              64 -> disk_write
              64 -> get_fattime
              64 -> mem_cpy
              64 -> mem_set
       16  f_mount
              16 -> clear_lock
       88  f_open
              88 -> chk_lock
              88 -> chk_mounted
              88 -> dir_register
              88 -> enq_lock
              88 -> ff_memalloc
              88 -> ff_memfree
              88 -> follow_path
              88 -> get_fattime
              88 -> inc_lock
              88 -> ld_clust
              88 -> move_window
              88 -> remove_chain
              88 -> st_clust
       40  f_opendir
              40 -> chk_mounted
              40 -> dir_sdi
              40 -> ff_memalloc
              40 -> ff_memfree
              40 -> follow_path
              40 -> ld_clust
       72  f_printf
              72 -> f_putc
              72 -> f_puts
       24  f_putc
              24 -> f_putc
              24 -> f_write
       16  f_puts
              16 -> f_putc
       32  f_read
              32 -> clmt_clust
              32 -> clust2sect
              32 -> disk_read
              32 -> disk_write
              32 -> get_fat
              32 -> mem_cpy
              32 -> validate
       32  f_readdir
              32 -> dir_next
              32 -> dir_read
              32 -> dir_sdi
              32 -> ff_memalloc
              32 -> ff_memfree
              32 -> get_fileinfo
              32 -> validate
      128  f_rename
             128 -> chk_lock
             128 -> chk_mounted
             128 -> clust2sect
             128 -> dir_register
             128 -> dir_remove
             128 -> ff_memalloc
             128 -> ff_memfree
             128 -> follow_path
             128 -> ld_clust
             128 -> mem_cpy
             128 -> move_window
             128 -> st_clust
             128 -> sync_fs
       72  f_stat
              72 -> chk_mounted
              72 -> ff_memalloc
              72 -> ff_memfree
              72 -> follow_path
              72 -> get_fileinfo
       16  f_sync
              16 -> disk_write
              16 -> get_fattime
              16 -> move_window
              16 -> st_clust
              16 -> sync_fs
              16 -> validate
       16  f_truncate
              16 -> get_fat
              16 -> put_fat
              16 -> remove_chain
              16 -> validate
      112  f_unlink
             112 -> chk_lock
             112 -> chk_mounted
             112 -> dir_read
             112 -> dir_remove
             112 -> dir_sdi
             112 -> ff_memalloc
             112 -> ff_memfree
             112 -> follow_path
             112 -> ld_clust
             112 -> mem_cpy
             112 -> remove_chain
             112 -> sync_fs
       72  f_utime
              72 -> chk_mounted
              72 -> ff_memalloc
              72 -> ff_memfree
              72 -> follow_path
              72 -> sync_fs
       32  f_write
              32 -> clmt_clust
              32 -> clust2sect
              32 -> create_chain
              32 -> disk_read
              32 -> disk_write
              32 -> mem_cpy
              32 -> validate
       16  fit_lfn
       16  follow_path
              16 -> create_name
              16 -> dir_find
              16 -> dir_sdi
              16 -> ld_clust
       24  gen_numname
              24 -> mem_cpy
       24  get_fat
              24 -> move_window
       24  get_fileinfo
              24 -> ff_convert
        4  inc_lock
        0  ld_clust
        4  mem_cmp
        0  mem_cpy
        0  mem_set
       16  move_window
              16 -> disk_read
              16 -> sync_window
       12  pick_lfn
       24  put_fat
              24 -> move_window
       24  remove_chain
              24 -> get_fat
              24 -> put_fat
        0  st_clust
        0  sum_sfn
       16  sync_fs
              16 -> disk_ioctl
              16 -> disk_write
              16 -> mem_set
              16 -> sync_window
       16  sync_window
              16 -> disk_write
        8  validate
               8 -> disk_status


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant "+,;=[]">
      20  ?<Constant "NO NAME    FAT     ">
      20  ?<Constant "NO NAME    FAT32   ">
      12  ?<Constant "\"*:<>?|\177">
      12  ?<Constant "\353\376\220MSDOS5.0">
       4  ??DataTable11
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable7
       4  ??DataTable9
       1  CurrVol
     128  ExCvt
       4  FatFs
      96  Files
       2  Fsid
      16  LfnOfs
     120  check_fs
      20  chk_chr
     142  chk_lock
     886  chk_mounted
      42  clear_lock
      42  clmt_clust
      24  clust2sect
     150  cmp_lfn
     180  create_chain
     672  create_name
      24  cst
      78  dec_lock
      80  dir_alloc
     230  dir_find
     300  dir_next
     214  dir_read
     370  dir_register
      96  dir_remove
     174  dir_sdi
      38  enq_lock
     120  f_chdir
      18  f_chdrive
     134  f_chmod
      36  f_close
     332  f_getcwd
     252  f_getfree
      78  f_gets
     766  f_lseek
     446  f_mkdir
    1728  f_mkfs
      62  f_mount
     518  f_open
     158  f_opendir
     608  f_printf
      56  f_putc
      44  f_puts
     508  f_read
     128  f_readdir
     348  f_rename
      94  f_stat
     170  f_sync
     164  f_truncate
     264  f_unlink
     140  f_utime
     564  f_write
     116  fit_lfn
     150  follow_path
     136  gen_numname
     242  get_fat
     250  get_fileinfo
     226  inc_lock
      34  ld_clust
      32  mem_cmp
      20  mem_cpy
      16  mem_set
      54  move_window
     108  pick_lfn
     288  put_fat
     106  remove_chain
      24  st_clust
      30  sum_sfn
     212  sync_fs
      86  sync_window
      54  validate
      24  vst

 
    103 bytes in section .bss
    264 bytes in section .rodata
 13 850 bytes in section .text
 
 13 850 bytes of CODE  memory
    264 bytes of CONST memory
    103 bytes of DATA  memory

Errors: none
Warnings: 1
